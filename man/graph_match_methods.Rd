% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/graph_match_methods.R
\name{graph_match_FW}
\alias{graph_match_FW}
\alias{graph_match_convex}
\alias{graph_match_percolation}
\alias{graph_match_ExpandWhenStuck}
\alias{graph_match_soft_percolation}
\alias{graph_match_IsoRank}
\alias{graph_match_Umeyama}
\title{Graph Match Methods}
\usage{
graph_match_FW(A, B, seeds = NULL, start = "convex", max_iter = 20)

graph_match_convex(A, B, seeds = NULL, start = "bari",
  max_iter = 100, tol = 1e-05)

graph_match_percolation(A, B, seeds, r = 2)

graph_match_ExpandWhenStuck(A, B, seeds, r = 2)

graph_match_soft_percolation(A, B, seeds, r = 2, max_iter = 2)

graph_match_IsoRank(A, B, start, alpha, max_iter = 1000,
  method = "greedy")

graph_match_Umeyama(A, B, start, alpha = 0)
}
\arguments{
\item{A}{A matrix or an igraph object. Adjacency matrix of \eqn{G_1}.}

\item{B}{A matrix or an igraph object. Adjacency matrix of \eqn{G_2}.}

\item{seeds}{A vector of integers or logicals, a matrix or a data frame. If
there is no error in seeds input can be a vector of seed indices in
\eqn{G_1}. Or if there exists error in seeds, input in the form of a matrix
or a data frame, with the first column being the indices of \eqn{G_1} and
the second column being the corresponding indices of \eqn{G_2}.}

\item{start}{A matrix or a character. Any \code{nns-by-nns} matrix or
character value like "bari" or "convex" to initialize the starting matrix.}

\item{max_iter}{An integer. Maximum iteration time.}

\item{tol}{A number. Tolerance of edge disagreements.}

\item{r}{A number. Threshold of neighboring pair scores.}

\item{alpha}{A number betwen 0 and 1. Bigger alpha means putting more importance
on the information in network topology over other information such as
similarity scores}

\item{method}{A character. Choice of method to extract mapping from score matrix,
including greedy method and the Hungarian algorithm.}
}
\value{
\code{graph_match_FW} returns a list of graph matching results,
  including match correspondence vector of \eqn{G_2} with respect to
  \eqn{G_1} named \code{corr}, doubly stochastic matrix named \code{D},
  permutation matrix named \code{P} based on Frank-Wolfe methodology and
  iteration time of the algorithm named \code{iter}.

\code{graph_match_convex} returns a list of graph matching results,
  including matching correspondence vector of \eqn{G_2} with respect to
  \eqn{G_1} named \code{corr}, doubly stochastic matrix named \code{D} and
  permutation matrix named \code{P} based on convex relaxation method for
  undirected graphs.

\code{graph_match_percolation} returns a list consists of
  matching correspondence of matched pairs with index of nodes in
  \eqn{G_1} named \code{corr_A} and index of nodes in \eqn{G_2} named
  \code{corr_B} returns and the order of matching for matched nodes in
  \eqn{G_1}.

\code{graph_match_ExpandWhenStuck} returns a list consists of
  matching correspondence of matched pairs with index of nodes in
  \eqn{G_1} named \code{corr_A} and index of nodes in \eqn{G_2} named
  \code{corr_B} returns and the order of matching for matched nodes in
  \eqn{G_1}.

\code{graph_match_soft_percolation} returns matching correspondence
  of matched pairs with index of nodes in \eqn{G_1} named \code{corr_A} and
  index of nodes in \eqn{G_2} named \code{corr_B}.

\code{graph_match_IsoRank} returns matching correspondence
  of matched pairs with index of nodes in \eqn{G_1} named \code{corr_A} and
  index of nodes in \eqn{G_2} named \code{corr_B}. If choose the greedy method to
  extract mapping, returns a list with mapping correspondence and order of
  matching for matched nodes in \eqn{G_1}.

\code{graph_match_Umeyama} returns matching correspondence
  of matched pairs with index of nodes in \eqn{G_1} named \code{corr_A} and
  index of nodes in \eqn{G_2} named \code{corr_B}.
}
\description{
Match two given graphs, returns a list of graph matching
  results, including matching correspondence vector of \eqn{G_2} with respect
  to \eqn{G_1}, doubly stochastic matrix and permutation matrix.
}
\examples{
cgnp_pair <- sample_correlated_gnp_pair(n = 10, corr =  0.3, p =  0.5)
g1 <- cgnp_pair$graph1
g2 <- cgnp_pair$graph2
# match G_1 & G_2 with no seeds
graph_match_FW(g1, g2)

# match G_1 & G_2 with some known node pairs as seeds
seeds <- 1:10 <= 3
graph_match_FW(g1, g2, seeds, start = "bari")

# match G_1 & G_2 with some incorrect seeds
hard_seeds <- matrix(c(4,6,5,4),2)
seeds <- rbind(as.matrix(check_seeds(seeds)),hard_seeds)
graph_match_FW(g1, g2, seeds, start = "convex")

seeds <- 1:10 <= 3
graph_match_convex(g1, g2, seeds)

hard_seeds <- matrix(c(4,6,5,4),2)
seeds <- rbind(as.matrix(check_seeds(seeds)),hard_seeds)
graph_match_convex(g1, g2, seeds)

# match G_1 & G_2 using percolation graph matching method
seeds <- 1:5
graph_match_percolation(g1, g2, seeds, r = 2)

# match G_1 & G_2 using Expand When Stuck graph matching method
seeds <- 1:5
graph_match_ExpandWhenStuck(g1, g2, seeds, r = 2)

# match G_1 & G_2 using soft percolation graph matching method
seeds <- 1:5
graph_match_soft_percolation(g1, g2, seeds, r = 2, max_iter = 2)


# match G_1 & G_2 using IsoRank algorithm
startm <- matrix(0, 10, 10)
diag(startm)[1:4] <- 1
GM_IsoRank <- graph_match_IsoRank(g1, g2, startm, alpha = .3, method = "greedy")

# match G_1 & G_2 using Umeyama algorithm
G <- sample_correlated_gnp_pair(10, .9, .5)
G1 <- G$graph1
G2 <- G$graph2
GM_U <- graph_match_Umeyama(G1, G2, startm, alpha = .3)

}
\references{
L. Yartseva and M. Grossglauser (2013), \emph{On the performance
  of percolation graph matching}. COSN, Boston, MA, USA, pages 119–130.

E. Kazemi, S. H. Hassani, and M. Grossglauser (2015),
\emph{Growing a graph matching from a handful of seeds}. Proc. of the VLDB
Endowment, 8(10):1010–1021.

R. Singh, J. Xu, B. Berger (2008), \emph{Global alignment of
multiple protein interaction networks with application to functional
orthology detection}. Proc Natl Acad Sci. USA, pages 12763-12768.

S. Umeyama (1988), \emph{An eigendecomposition approach to weighted
  graph matching problems}. IEEE TPAMI. USA, pages 695-703.
}
