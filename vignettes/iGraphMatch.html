<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>iGraphMatch: an R Package for the Analysis of Graph Matching</title>

<script>// Hide empty <a> tag within highlighted CodeBlock for screen reader accessibility (see https://github.com/jgm/pandoc/issues/6352#issuecomment-626106786) -->
// v0.0.1
// Written by JooYoung Seo (jooyoung@psu.edu) and Atsushi Yasumoto on June 1st, 2020.

document.addEventListener('DOMContentLoaded', function() {
  const codeList = document.getElementsByClassName("sourceCode");
  for (var i = 0; i < codeList.length; i++) {
    var linkList = codeList[i].getElementsByTagName('a');
    for (var j = 0; j < linkList.length; j++) {
      if (linkList[j].innerHTML === "") {
        linkList[j].setAttribute('aria-hidden', 'true');
      }
    }
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore"><code>iGraphMatch</code>: an R Package for the Analysis of Graph Matching</h1>



<div id="abstract" class="section level1">
<h1>Abstract</h1>
<p><code>iGraphMatch</code> is an R package developed for matching the corresponding vertices between two edge-correlated graphs. The package covers three categories of prevalent graph matching algorithms including relaxation-based, percolation-based, and spectral-based, which are applicable to matching graphs under the most general settings: weighted directed graphs of different order and graphs of multiple layers with auxiliary graph matching techniques. We provide versatile options to incorporate prior information in the form of seeds with or without noise and similarity scores. We also implement an S4 class that overloads popular operations for matrices in R for efficient computation of sparse plus low-rank matrices, which is a common structure we can decompose the matrices into in the process of matching graphs. In addition, <code>iGraphMatch</code> provides functions to summarize the graph matching results in terms of several evaluation measures and visualize the matching performance. Finally, the package also enables the users to sample correlated random graph pairs from classic random graph models to generate data for simulations. This paper illustrates the practical applications of the package to the analysis of graph matching by detailed examples using real data from social networks and bioinformatics.</p>
</div>
<div id="sec:intro" class="section level1">
<h1>Introduction</h1>
<!-- \todo{mention somewhere about random permutations inside gm functions, or make those optional} -->
<!-- add in sec background when talk about LAP & QAP -->
<p>The graph matching (GM) problem seeks to find an alignment between the vertex sets of graphs that best preserves common structure across graphs. This is often posed as minimizing edge disagreements of two graphs over all alignments. Formally, given <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, two adjacency matrices corresponding to two graphs <span class="math inline">\(G_1=(V_1, E_1)\)</span> and <span class="math inline">\(G_2=(V_2, E_2)\)</span>, the goal is to find <span class="math display">\[\begin{align*}
    \mathop{\mathrm{argmin}}_{P\in\Pi}\lVert A-PBP^T \rVert_F^2
\end{align*}\]</span> where <span class="math inline">\(\Pi\)</span> is the set of all permutation matrices. GM has wide applications in diverse fields, such as pattern recognition , machine learning , bioinformatics , neuroscience , social network analysis , and knowledge graph queries . More generally, the problem of discovering some true latent alignment between two networks can often be posed as variations on the above problem by adjusting the objective function for the setting.</p>
<p>The well-known graph isomorphism problem is a special case of GM problem when there exists a bijection between the nodes of two graphs which exactly preserves the edge structure. In terms of computational complexity, GM is equivalent to the NP-hard quadratic assignment problem, which is considered a very challenging problem where few theoretical guarantees exist, even in special cases . For certain problems where the graphs are nearly isomorphic, polynomial-time algorithms do exist  but these methods frequently break down for more challenging instances.</p>
<p>This paper presents the detailed functionality of the <code>iGraphMatch</code> R package which serves as a practical tool for the use of prevalent graph matching methodologies. These algorithms utilize either the spectral embedding of vertices , or relaxations of the objective function , or apply ideas from percolation theory . The <code>iGraphMatch</code> package provides versatile options of working with graphs in the form of matrices, igraph objects or lists of either, and matching graphs under a generalized setting: weighted, directed, graphs of a different order, and multilayer graphs.</p>
<!-- DLS: I'm wondering if here is a good place for mentioning need for a package.
Might also skip the division into groups discussion for now since I'm not sure how meaningful it is at this point.
Generally, I think we want to make sure that the introduction (1) emphasizes the need for the package and (2) emphasizes a need for a detailed paper like this one.
-->
<!-- Due to these challenges, many GM approaches have been proposed. -->
<!-- In general, these GM algorithms can be divided into three groups. -->
<!-- The first group of algorithms is based on the spectral embedding of vertices, which was first proposed by \cite{Umeyama}. -->
<!-- The second group uses relaxations of the objective function, including using convex \citep{PATH, FAQ}, concave \citep{PATH}, and indefinite relaxations \citep{FAQ}. -->
<!-- The last group consists of algorithms that apply ideas from percolation theory, where matching information is spread from an initial set of matched nodes \cite{Percolation, ExpandWhenStuck}. -->
<p>In addition, the <code>iGraphMatch</code> package incorporates prior information: seeds and similarities for all the implemented algorithms. <!-- Indeed, many authors including \cite{SGM, IsoRank, Percolation, ExpandWhenStuck} have proposed matching methods that incorporate some form of prior knowledge, such as seeds or similarity scores. --> Seeds, or anchors, refer to partial knowledge of the alignment of two graphs. In practice, seeds can be users with the same name and location across different social networks or pairs of genes with the same DNA sequences. Some algorithms like the percolation algorithm  which matches two graphs by propagating matching information to neighboring pairs require seeds to kick off. All algorithms improve substantially by incorporating seeds and can achieve accurate matching in polynomial time . Similarity scores are another commonly used prior which measures the similarity between pairs of nodes across the graphs. In the bioinformatics area, BLAST similarity score is an example of similarity scores that plays an important role in aligning two PPI networks . Similarity scores are usually generated from nodal covariates that are observed in both networks .</p>
<p>While under many scenarios the availability of exact partial matches, or hard seeding, is not realistic and expensive, the package also enables utilizing noisy prior information. Similarity scores incorporate uncertainty by assigning the pair of nodes with higher similarity scores a bigger chance to match. Seeds with uncertainty and even error can still be handled by self-correcting graph matching algorithms like the  algorithm initialized at the noisy partial matching, called soft seeding.  showed that the  algorithm with soft seeding scheme converges quickly to the true alignment under the correlated Erds-R&#39;enyi model with high probability. Thus, the original intractable problem is reduced to be solvable in polynomial time.</p>
<p>Although there exist some open source software and packages containing graph matching functionality, <code>iGraphMatch</code> package provides a centralized repository for common graph matching methodologies with flexibility, tools for developing graph matching problem methodology, as well as metrics for evaluating and tools for visualizing matching performance. Among the alternative GM packages, the most relevant ones include the <code>igraph</code>  package which focuses on descriptive network analysis and graph visualization based on igraph objects and provides a single graph matching algorithm, the <code>GraphM</code>  package which implements several GM algorithms proposed between 1999 and 2009 in C, and the <code>Corbi</code>  R package which is particularly designed for studies in bioinformatics and <code>SpecMatch</code>  which only involves implementations of spectral embedding based GM algorithms and written in C/C++. None of these packages provide the breadth of tools, flexibility, and ease-of-use provided by the <code>iGraphMatch</code> package.</p>
<p>The rest of this paper is organized as follows. Section @ref(sec:background) describes the theoretical representations of the implemented GM algorithms, correlated random graph models and evaluation metrics. Section @ref(sec:usage) discusses the functionality and usage of R functions in the package, illustrated on the synthetic correlated graph pairs. Section @ref(sec:example) presents more complex examples on real data with several functions involved in the analysis and section @ref(sec:conclusion) gives guidelines on using different GM algorithms under different circumstances and concludes the paper.</p>
<!--chapter:end:index.Rmd-->
</div>
<div id="sec:background" class="section level1">
<h1>Graph matching background</h1>
<p>In this section, we give background on graph matching and related problems followed by descriptions of the principal algorithms implemented in <code>iGraphMatch</code>. For simplicity, we state all the algorithms in the context of matching undirected, unweighted graphs with the same cardinality. All algorithms can also be directly applied to directed and weighted graphs. <!-- by passing the corresponding asymmetric real-valued adjacency matrices into the algorithms. --> In the second subsection, we discuss the techniques for matching graphs with a different number of vertices along with other extensions. To conclude the section, we introduce the statistical models for correlated networks and discuss measures for the goodness of matching.</p>
<p>For the remainder of this paper we use the following notation. Let <span class="math inline">\(G_1=(V_1,E_1)\)</span> and <span class="math inline">\(G_2=(V_2,E_2)\)</span> denote two graphs with <span class="math inline">\(n\)</span> vertices. Let <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> be their corresponding binary symmetric adjacency matrices. In the setting of seeded graph matching, suppose without loss of generality, the first <span class="math inline">\(s\)</span> pairs of nodes are seeds for simplicity. In <code>iGraphMatch</code>, much more flexible seed specifications are possible, which will be illustrated in examples for usage of the package in section @ref(sec:usage). Accordingly, let <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> be partitioned as: <span class="math display">\[\begin{equation} \label{eq:seed_blocks}
A=
\begin{bmatrix}
A_{11} &amp; A_{21}^T \\
A_{21} &amp; A_{22}
\end{bmatrix}\text{ and }
B=
\begin{bmatrix}
B_{11} &amp; B_{21}^T \\
B_{21} &amp; B_{22}
\end{bmatrix}
\end{equation}\]</span> where <span class="math inline">\(A_{11}, B_{11}\in\{0, 1\}^{s\times s}\)</span> denote seed-to-seed adjacencies, <span class="math inline">\(A_{21}, B_{21}\in\{0, 1\}^{(n-s)\times s}\)</span> denote nonseed-to-seed adjacencies and <span class="math inline">\(A_{22}, B_{22}\in\{0, 1\}^{(n-s)\times (n-s)}\)</span> denote nonseed-to-nonseed adjacencies. Let <span class="math inline">\(S\)</span> be an <span class="math inline">\(n\)</span>-by-<span class="math inline">\(n\)</span> real-valued matrix of similarity scores. Let <span class="math inline">\(\Pi\)</span> be the set of all permutation matrices and <span class="math inline">\(\mathcal{D}\)</span> be the set of all doubly stochastic matrices.</p>
<div id="assignment-problems" class="section level3">
<h3>Assignment problems</h3>
<p>Matching or assignment problems are core problems in combinatorial optimization and appear in numerous fields . As we illustrate in Eq. , a general version of the graph matching problem is equivalent to the quadratic assignment problem (QAP). Similarly, QAP is related to the linear assignment problem (LAP) which also plays a role in GM. The LAP asks how to assign <span class="math inline">\(n\)</span> items (eg. workers or nodes in <span class="math inline">\(G_1\)</span>) to <span class="math inline">\(n\)</span> other items (eg. tasks or nodes in <span class="math inline">\(G_2\)</span>) with minimum cost. Let <span class="math inline">\(C\)</span> denote an <span class="math inline">\({n\times n}\)</span> cost matrix, where <span class="math inline">\(C_{ij}\)</span> denotes the cost of matching <span class="math inline">\(i\)</span> to <span class="math inline">\(j\)</span>, then the LAP is to find <span class="math display">\[\begin{equation} \label{eq:LAP}
\begin{aligned}
&amp; \mathop{\mathrm{argmin}}_{P\in \Pi}
&amp; &amp; \mathrm{trace}(C^TP)
\end{aligned}
\end{equation}\]</span> LAP is solvable in <span class="math inline">\(O(n^3)\)</span> time and there are numerous exact and approximate methods for both general  and special cases, such as sparse cost matrices .</p>
<p>The statement of QAP resembles LAP, except that the cost function is expressed as a quadratic function. Given two <span class="math inline">\(n\text{-by-}n\)</span> matrices <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> which can represent flows between facilities and the distance between locations respectively, or the adjacency matrices of two unaligned graphs, the objective function for QAP is: <span class="math display">\[\begin{equation}\label{eq:qap}
\mathop{\mathrm{argmin}}_{P\in \Pi}    \mathrm{trace}(APBP^T).
\end{equation}\]</span> This problem is NP-hard  leading to a core challenge for any graph matching approach. <!-- Note that over the space of all matrices the gradient for the QAP objective function is $2APB^T$ which can be viewed as a cost matrix for a LAP. --></p>
<!-- DLS: Is this the only place we mention similarities.
Also, we include similarities in cases where the algorithm does not reduce to LAP as well.
I think maybe we want to say either reduce to LAP or use LAP methods. -->
<p>As will be illustrated in the rest of the section, some matching algorithms reduce the graph matching problem to solving a LAP. For these algorithms, we include similarity scores <span class="math inline">\(S\)</span> by adding an additional term <span class="math inline">\(\mathrm{trace}(S^TP)\)</span> to the reduced objective function.</p>
</div>
<div id="subsec:gm" class="section level2">
<h2>Graph matching algorithms</h2>
<p>In the <code>iGraphMatch</code> package, we implement three types of prevalent GM algorithms. The first group uses relaxations of the objective function, including convex, concave, and indefinite relaxations. The second group consists of algorithms that apply ideas from percolation theory, where matching information is spread from an initial set of matched nodes. The last group is based on the spectral embedding of vertices.</p>
<!-- DLS: Put more detailed discussion of three types here.
Do we mention that none of these algs are guaranteed to find optimal in general?
 -->
<div id="relaxation-based-algorithms" class="section level3">
<h3>Relaxation-based algorithms</h3>
<!-- Although there are no known efficient algorithms to solve GM, relaxation techniques provide one promising approach. -->
<p>These approaches relax the constraint that <span class="math inline">\(P\)</span> is a permutation matrix to require only that <span class="math inline">\(P\)</span> is doubly stochastic, optimizing over <span class="math inline">\(\mathcal{D}\)</span>, the convex hull of <span class="math inline">\(\Pi\)</span>. When <span class="math inline">\(P\)</span> is a permutation matrix <span class="math display">\[\begin{equation}
\label{eq:ob_func}
    \lVert A-PBP^T \rVert_F^2 = \lVert AP-PB \rVert_F^2 = \lVert A \rVert_F^2 + \lVert B \rVert_F^2 - 2\cdot \mathrm{trace}APBP^T.
\end{equation}\]</span> However, these equalities do not hold for all <span class="math inline">\(P\in \mathcal{D}\)</span>, leading to different relaxations.</p>
<p>The second term of Eq. is a convex function and optimizing it over <span class="math inline">\(P\in\mathcal{D}\)</span> gives the convex relaxation, where the gradient at <span class="math inline">\(P\)</span> to the convex relaxed objective function is <span class="math inline">\(-4 APB + 2A^TAP + 2PBB^T\)</span>. <!-- \todo{is that right?} --> The last equality in Eq.  shows that minimizing edge disagreements is equivalent to maximizing the number of edge agreements, <span class="math inline">\(\mathrm{trace} APBP^T\)</span>, a QAP. Optimizing the indefinite function over <span class="math inline">\(\mathcal{D}\)</span> gives the indefinite relaxation with gradient <span class="math inline">\(-2APB\)</span> .</p>
<table style="width:100%;">
<caption>(#tab:relaxation) Summary of relaxation methods for graph matching problem. <!-- The optimization problem converges at the local minimum. --> <!-- ^[The optimum solution to the indefinite relaxation problem almost always coincides with the permutation matrix under the correlated \ErdosRenyi model.] --></caption>
<colgroup>
<col width="12%"></col>
<col width="19%"></col>
<col width="16%"></col>
<col width="14%"></col>
<col width="19%"></col>
<col width="17%"></col>
</colgroup>
<thead>
<tr class="header">
<th>Relaxation</th>
<th>Objective Function</th>
<th>Domain</th>
<th>GM Algorithm</th>
<th>Optimization Guarantee</th>
<th>Optimum Form</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>None</td>
<td><span class="math inline">\(\lVert A-PBP^T \rVert_F^2\)</span></td>
<td><span class="math inline">\(\Pi\)</span></td>
<td>NA</td>
<td></td>
<td><span class="math inline">\(\Pi\)</span></td>
</tr>
<tr class="even">
<td>Indefinite</td>
<td><span class="math inline">\(\mathrm{tr}ADBD^T\)</span></td>
<td><span class="math inline">\(\mathcal{D}\)</span></td>
<td></td>
<td>Local</td>
<td><span class="math inline">\(\mathcal{D}\)</span> (often <span class="math inline">\(\Pi\)</span>)</td>
</tr>
<tr class="odd">
<td>Convex</td>
<td><span class="math inline">\(\lVert AD-DB \rVert_F^2\)</span></td>
<td><span class="math inline">\(\mathcal{D}\)</span></td>
<td></td>
<td>Global</td>
<td><span class="math inline">\(\mathcal{D}\)</span></td>
</tr>
<tr class="even">
<td>Concave</td>
<td><span class="math inline">\(-\mathrm{tr}(\Delta D)-2\mathrm{tr}(L_1^T D L_2 D^T)\)</span></td>
<td><span class="math inline">\(\mathcal{D}\)</span></td>
<td></td>
<td>Local</td>
<td><span class="math inline">\(\Pi\)</span></td>
</tr>
</tbody>
</table>
<p>Generally, the convex relaxation leads to a solution that is not guaranteed to be near the solution to the original GM. However,  introduced the class of “friendly” graphs based on the spectral properties of the adjacency matrices to characterize the applicability of the convex relaxation. Matching two friendly graphs by using the convex relaxation is guaranteed to find the exact solution to the GM problem. Unfortunately, this class is quite limiting and does not hold for most statistical models or real-world examples. <!-- Specifically, the result is extended to two graphs that satisfy the weak friendliness with bounded weight disagreement. --> <!-- Even if two graphs are unfriendly, we can still guarantee the uniqueness of the solution to the relaxation by introducing additional information on the true alignment, such as seeds. --></p>
<p>Another relaxation is the concave relaxation used in the PATH algorithm . The concave relaxation uses the Laplacian matrix defined as <span class="math inline">\(L=D-A\)</span>, where <span class="math inline">\(D\)</span> is the diagonal degree matrix with diagonal entries <span class="math inline">\(D_{ii}=\sum_{i=1}^N A_{ij}\)</span>. Assume <span class="math inline">\(L_i\)</span> and <span class="math inline">\(D_i\)</span>, <span class="math inline">\(i=1,2\)</span>, are the Laplacian matrices and degree matrices for <span class="math inline">\(G_1\)</span> and <span class="math inline">\(G_2\)</span> respectively, then we can rewrite the objective function as <span class="math display">\[\begin{equation} \label{eq:concave}
\begin{split}
    \lVert A-PBP^T\rVert_F^2 &amp; = \lVert AP-PB \rVert_F^2\\
    &amp; = \lVert (D_1P-PD_2)-(L_1P-PL_2)\rVert_F^2\\
    &amp; = -\mathrm{trace}(\Delta P)+\mathrm{trace}(L_1^2)+\mathrm{trace}(L_2^2)-2\mathrm{trace}(L_1^T P L_2 P^T),
\end{split}
\end{equation}\]</span> where the matrix <span class="math inline">\(\Delta_{ij}=(D_{2_{jj}}-D_{1_{ii}})^2\)</span>. Dropping the terms not dependent on <span class="math inline">\(P\)</span> in equation , we obtain the concave function <span class="math inline">\(-\mathrm{trace}(\Delta P)-2\mathrm{trace}(L_1^T P L_2 P^T)\)</span> on <span class="math inline">\(\mathcal{D}\)</span>.</p>
<p>A summary of the different relaxations is provided in Table . Relaxing the discrete problem to a continuous problem breaks the equivalence to the original formulation of the edge disagreement and enables employing algorithms based on gradient descent.</p>
<div id="methodology" class="section level4">
<h4> methodology</h4>
<p> introduced an algorithm for the relaxed graph matching problem, with each iteration computable in polynomial time, that can find local optima for the relaxations above. The   methodology is an iterative gradient ascent approach composed of two steps. The first step finds an ascent direction that maximizes the gradient ascent. In this case the ascent direction is a permutation matrix which is a vertex of the polytope of doubly stochastic matrices. For the convex, indefinite, and concave relaxations, this corresponds to a LAP with the gradient as the cost function. The second step performs a line search along the ascent direction to optimize the relaxed objective function. As the objectives are all quadratic, this line search is simply requires optimizing a single-variable quadratic function along a line segment. After the iterative algorithm converges, the final step of the procedure is to project the doubly stochastic matrix back to the set of permutation matrices, which is also a LAP.</p>
<p>The various relaxed forms can all serve as the objective function <span class="math inline">\(f(\cdot)\)</span> in the  Methodology, but in all cases a matrix <span class="math inline">\(D^0\in \mathcal{D}\)</span> must be chosen to initialize the procedure. For the convex relaxation, the  methodology is guaranteed to converge to the global optimum regardless of the <span class="math inline">\(D^0\)</span>. On the other hand, the  algorithm for the indefinite relaxation is not guaranteed to find a global optimum so the initialization is critical.</p>
<p>In many instances, the optimal solution to the convex relaxation lies in the interior of <span class="math inline">\(\mathcal{D}\)</span>. This can lead to inaccurate solutions after the last projection step. The local optima for the indefinite relaxation are often at extreme points of <span class="math inline">\(\mathcal{D}\)</span>, meaning the final projection often does nothing.</p>
<p>The default initialization for the indefinite problem is at the barycenter matrix, <span class="math inline">\(D^0 = \frac{1}{n}11^T\)</span>, but many other initialization procedures can be used. These include randomized initializations, initializations based on similarity matrices, and initializing the indefinite relaxation at the interior point solution of the convex relaxation . When prior information regarding a partial correspondence is known to be noisy, rather than incorporating this information as seeds, one can incorporate it as “soft” seeds which are used to generate the initialization .</p>
<!-- Within the framework of soft seeding, noisy seeds are leveraged to generate the initial matrix \citep{soft_seeding}.
In this way, noisy seeds provide prior information about the truth and the noisy part can evolve over iterations at the same time.
Thus, a good strategy is to initialize the indefinite relaxed problem at the optimal value of the convex relaxed problem \citep{relax_paper}.
 -->

<p>When prior information is available in the form of seeds, the seeded graph matching problem  works on the objective function  with the permutation matrix <span class="math inline">\(P^{n\times n}\)</span> substituted by <span class="math inline">\(I_s\oplus P^{(n-s)\times (n-s)}\)</span>, the direct sum of an <span class="math inline">\(s\times s\)</span> identity matrix and an <span class="math inline">\((n-s)\times (n-s)\)</span> permutation matrix. <!-- DLS: Also mention seeds here and include in the displayed eqn below. --> <!-- where $\oplus$ denotes the direct sum of the identity matrix $I_s$ which embeds hard seeds and the permutation matrix to optimize over. --> Employing the indefinite relaxed objective function incorporating seeds, we formulate the problem as finding <span class="math display">\[\begin{align*}
    \hat{P} % &amp;= \argmin_{P\in \Pi} \mathrm{trace} A(I_s\oplus P)B(I_s\oplus P)^T \\
    &amp;= \mathop{\mathrm{argmax}}_{P\in\mathcal{D}} 2\cdot\mathrm{trace}P^TA_{21}B_{21}^T+\mathrm{trace}A_{22}PB_{22}P^T
\end{align*}\]</span> where the gradient to the objective function is <span class="math display">\[\begin{equation} \label{eq:sgm_gradient}
  \nabla f(P)=2\cdot A_{21}B_{21}^T+2\cdot A_{22}PB_{22}.
\end{equation}\]</span></p>
<!-- \todo{is this the right place for this para? - similarity scale para moved to usage section when talk about arguments for gm.} -->
<p>In total, this uses the information between seeded nodes and nonseeded nodes and the nonseed-to-nonseed information. Applying seeded graph matching to the convex relaxation and concave relaxation closely resembles the case of indefinite relaxation.</p>
</div>
<div id="algorithm" class="section level4">
<h4> algorithm</h4>
<p> introduced a convex-concave programming approach to approximately solve the graph matching problem. The concave relaxation has the same solution as the original graph matching problem. <!-- but there is no efficient algorithm to solve it. --> The  algorithm finds a local optimum to the concave relaxation by considering convex combinations of the convex relaxation <span class="math inline">\(F_0(P)\)</span> and the concave relaxation <span class="math inline">\(F_1(P)\)</span> denoted by <span class="math inline">\(F_{\lambda} =(1 - \lambda) F_0 + \lambda F_1\)</span>. <!-- , where $\lambda$ represents the weight between two relaxations. --> Starting from the solution to the convex relaxation (<span class="math inline">\(\lambda=0\)</span>) the algorithm iteratively performs gradient ascent using the FW methodology at <span class="math inline">\(F_\lambda\)</span>, increasing <span class="math inline">\(\lambda\)</span> after each iteration, until <span class="math inline">\(\lambda = 1\)</span>. <!-- to the concave objective function over $\mathcal{D}$, it seeks the local minimum of $F_{\lambda}$ initialized at the optimum from the last iteration using the \textsc{FW} methodology. --> <!-- Each step has the length of $d\lambda$ which is self-adaptive at each iteration and guarantees a significant difference of two objective functions between two successive iterations. --> <!-- 
\begin{algorithm}
\caption{PATH Algorithm}
\label{alg:PATH}
\SetKwInOut{Input}{Input}
\SetKwInOut{Output}{Output}
\Input{$A,B$, similarity scores or seeds matrix $S$, minimal searching increment $d\lambda$, tolerance $\epsilon$}
\Output{permutation matrix $P$}
Set $\lambda=0$;\par
Solve $P^0=\argmin F_0$ by Frank-Worlfe algorithm;\par
\While{$\lambda<1$}{
    $\lambda_{new}=\lambda+d\lambda$;\par
    \eIf{$|F_{\lambda_{new}}(P^{\lambda})-F_{\lambda}(P^{\lambda})|<\epsilon$}{$\lambda=\lambda_{new}$;\par}{
    Solve $P^{\lambda_{new}}=\argmin F_{\lambda_{new}}$ by \textsc{FW} methodology;\par
    $\lambda=\lambda_{new}$;\par
    }
}
\end{algorithm} --></p>
</div>
</div>
<div id="percolation-based-algorithms" class="section level3">
<h3>Percolation-based algorithms</h3>
<p>Under the  methodology, all the nodes admit a correspondence but the (relaxed) matching correspondence evolves through iterations. On the other hand, percolation approaches start with a set of seeds, adding one new match at each iteration. The new matches are fixed and hence not updated in future iterations.</p>
<p>Each iteration expands the set of matched nodes by propagating the current matching information to neighbors. The guiding intuition is that more matched neighbors are an indicator of a more plausible match, an intuition analogous to the gradient ascent approaches above. We will present two algorithms in this category where the  algorithm is an extension to the  algorithm.</p>
<p>There are some distinctions about the inputs and outputs of percolation methods compared to the above relaxation methods. <!--
    Requires seeds or similarity. Similar but not identical to initialization. 
    Not all matched, ordered match. --></p>
<div id="algorithm-1" class="section level4">
<h4> Algorithm</h4>
<p> provides a simple and fast approach to solve the graph matching problem by starting with a handful of seeds and propagating to the rest of the graphs. At each iteration, the matching information up to the current iteration is encoded in a subpermutation matrix <span class="math inline">\(P\)</span> where <span class="math inline">\(P_{ij}=1\)</span> if <span class="math inline">\(i\)</span> is matched to <span class="math inline">\(j\)</span>, and <span class="math inline">\(0\)</span> otherwise. <!-- \begin{equation*} \label{P}
P_{ij}=
    \begin{cases}
    1       & \quad \text{if } (i,j) \text{ is matched}\\
    0  & \quad \text{otherwise} 
  \end{cases}
\end{equation*} --> The  algorithm searches for the most promising new match among the unmatched pairs through the mark matrix, <span class="math inline">\(M=APB\)</span>, <!-- \begin{equation} \label{eq:M}
    M=APB
\end{equation} --> which is the gradient of the indefinite relaxation when extended to sub-doubly stochastic matrices. When similarity scores are available, they are added to the mark matrix to combine topological structure and similarity scores.</p>
<p>Adopting analogous partitions on the adjacency matrices as in equation , we let <span class="math inline">\(A_{21}, B_{21}\)</span> denote sub-matrix corresponding to potential adjacencies between unmatched and matched nodes. Since all the candidates of matched pairs are permanently removed from consideration, we need only consider <span class="math inline">\(M&#39;=A_{21}B_{21}^T\)</span>, the sub-matrix of <span class="math inline">\(M\)</span> corresponding to the unmatched nodes in both graphs. As a result, the  algorithm only uses matched-to-unmatched information to generate new matches.</p>
<p>Moreover, the mark matrix <span class="math inline">\(M\)</span> can also be interpreted as encoding the number of matched neighboring pairs for each pair of nodes <span class="math inline">\(i\in V_1\)</span>, <span class="math inline">\(j\in V_2\)</span>. Suppose <span class="math inline">\(u, u&#39;\in V_1\)</span>, <span class="math inline">\(v,v&#39;\in V_2\)</span>, <span class="math inline">\([u,u&#39;]\in E_1\)</span> and <span class="math inline">\([v,v&#39;]\in E_2\)</span>, then <span class="math inline">\((u&#39;,v&#39;)\)</span> is a neighboring pair of <span class="math inline">\((u,v)\)</span>. In each iteration, while there remain unmatched nodes with more than <span class="math inline">\(r\)</span> matched neighboring pairs, the percolation algorithm matches the pair of nodes with the highest score <span class="math inline">\(M_{uv}\)</span>,<br />
<!-- updating the current match $P$ with $P_{uv} = 1$ and recomputing the mark matrix. --> and adds one mark to all the neighboring pairs of <span class="math inline">\((u,v)\)</span>. Note that the algorithm may stop before all nodes are matched, leading to the return of a partial match.</p>
<p>There is only one tuning parameter in the  algorithm, the threshold <span class="math inline">\(r\)</span> which controls a tradeoff between quantity of matches and quality of matches. With a small threshold, the algorithm has a larger chance of matching wrong pairs. If <span class="math inline">\(r\)</span> is larger, then the algorithm might stop before matching many pairs .</p>
<p>The  algorithm can be generalized to matching weighted graphs by making an adjustment to how we measure the matching information from the neighbors. Since we prefer to match edges with smaller weight differences and higher absolute weights, we propose to adopt the following update formula for the score associated with each pair of nodes <span class="math inline">\((i,j)\)</span>: <span class="math display">\[M_{ij}=M_{ij} + \sum_{u\in N(i)}\sum_{v\in N(j)}1-\frac{|w_{iu}-w_{jv}|}{\max(|w_{iu}|, |w_{jv}|)}.\]</span> Thus, the score contributed by each neighboring pair of <span class="math inline">\((i,j)\)</span> is a number in <span class="math inline">\([0,1]\)</span>. <!-- At the same time, we should set a smaller threshold $r$ accordingly. --></p>

</div>
<div id="algorithm-2" class="section level4">
<h4> Algorithm</h4>
<p> extends the  algorithm to a version that can operate with a smaller number of seeds. <!-- Notice that the quantity of final matches of the \textsc{percolation} algorithm heavily relies on the number of seeds. --> Without enough seeds, when there are no more unmatched pairs with a score higher or equal to the threshold <span class="math inline">\(r\)</span>, the  algorithm would stop even if there are still unmatched pairs.  uses all pairs of nodes with at least one matched neighboring pair, <span class="math inline">\(M_{ij}\geq 1\)</span>, as new seeds to restart the matching process by adding one mark to all of the new seeds’ neighboring pairs, without updating the matched set. If the updated mark matrix consists of new pairs with marks greater or equal to <span class="math inline">\(r\)</span>, then the percolation algorithm continues, leading to larger matched sets. <!-- Notice that such seeds are not as yet qualified for being matched, thus will not be added to the final permutation matrix. --></p>
</div>
</div>
<div id="spectral-based-algorithm" class="section level3">
<h3>Spectral-based algorithm</h3>
<p>Another class of graph matching algorithms uses the spectral properties of adjacency matrices.</p>
<div id="algorithm-3" class="section level4">
<h4> Algorithm</h4>
<p> propose the  algorithm that uses neighboring topology and similarity scores and exploits spectral properties of the solution. The  algorithm is also based on the relaxation-based algorithms by encoding the topological structure of two graphs in <span class="math inline">\(ADB\)</span>, which is again proportional to the gradient of the indefinite relaxation. However, the representations of each term of <span class="math inline">\(ADB\)</span> are slightly different. <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are the column-wise normalized adjacency matrices and <span class="math inline">\(D\)</span> is not necessarily a doubly stochastic matrix yet <span class="math inline">\(D_{ij}\)</span> still indicates how promising it is to match <span class="math inline">\(i\in V_1\)</span> to <span class="math inline">\(j\in V_2\)</span>.</p>
<p>Similar to the idea of  algorithm, the intuition is that the impact of a pair of matched nodes is evenly distributed to all of their neighbors to propagate plausible matches. This is achieved by solving the eigenvalue problem <span class="math display">\[\begin{align}\label{eq:Iso1}
    \mathrm{vec}(D)=(A\otimes B) \mathrm{vec}(D),
\end{align}\]</span> where <span class="math inline">\(\mathrm{vec}(D)\)</span> denotes the vectorization of matrix <span class="math inline">\(D\)</span>, and the right hand side is equivalent to <span class="math inline">\(ADB\)</span>. <!-- Notably, the above equation is equivalent to  --> <!-- $D=ADB$ --> <!-- which leads to the form correlated with the gradient of the relaxation-based algorithms. --> To combine network-topological structure and similarity scores in the objective function, the normalized similarity score <span class="math inline">\(E\)</span> is added to the right hand side of Eq. , where <span class="math inline">\(E=S/\|S\|_1\)</span>, and <span class="math inline">\(|\cdot|_1\)</span> denotes the L1 norm.</p>
<!-- \begin{align}\label{eq:Iso2} -->
<!--    \mathrm{vec}(D)=&\alpha\cdot A\otimes B\cdot \mathrm{vec}(D) + (1-\alpha) \mathrm{vec}(E) \quad 0\le\alpha\le 1  -->
<!-- \end{align} -->
<!-- Note that we can also construct a similarity score matrix from seeds by assigning 1's to elements corresponding to seeds and the remaining elements with 0's.\todo{is this how we do it? I'd think we'd include the seeds in E adding in $A_{12}^TB_{12}$.} -->
<p>Note that when similarity score is not available as prior information, we can also construct a doubly stochastic similarity score matrix from seeds by taking <span class="math inline">\(I_{s\times s}\oplus \frac{1}{n-s}\mathbbm{1}\mathbbm{1}_{(n-s)\times (n-s)}\)</span>. To solve the eigenvalue problem , we resort to the power method. Finally, the global alignment is generated by a greedy algorithm or using the algorithms for solving the linear assignment problem (LAP). <!-- Also note that with some prior information in the form of seeds, we only extract the global mapping from nonseed nodes in the final step.
The same strategy of handling seeds is also applied to the \textsc{Umeyama} algorithm, another spectral-based algorithm that we will illustrate next. --></p>

<!-- \todo{when you normalize is it with the Frobenius norm? - No, it's L1 norm.} -->
</div>
<div id="algorithm-4" class="section level4">
<h4> algorithm</h4>
<p> is a spectral approach to find approximate solutions to the graph matching problem. Assuming eigendecompositions of adjacency matrices <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> as <span class="math inline">\(A=U_A\Lambda_AU_A^T\)</span> and <span class="math inline">\(B=U_B\Lambda_BU_B^T\)</span>, let <span class="math inline">\(|U_A|\)</span> and <span class="math inline">\(|U_B|\)</span> be matrices which takes absolute values of each element of <span class="math inline">\(U_A\)</span> and <span class="math inline">\(U_B\)</span>. Such modification to the eigenvector matrices guarantees the uniqueness of eigenvector selection. The global mapping is obtained by minimizing the differences between matched rows of <span class="math inline">\(U_A\)</span> and <span class="math inline">\(U_B\)</span>: <span class="math display">\[\begin{align*}
    \hat{P}=\mathop{\mathop{\mathrm{argmin}}}_{P\in\Pi}\lVert |U_A|-P|U_B|\rVert_F=\mathop{\mathop{\mathrm{argmax}}}_{P\in\Pi}\mathrm{trace}(|U_B||U_A|^TP)
\end{align*}\]</span></p>
<!-- Still we can include prior information by introducing an additional linear term in the objective function as in the previous Algorithms.\todo{same thing here?} -->
<!-- Finally, this problem can be efficiently solved by the Hungarian algorithm in $O(N^3)$ \citep{Hungarian}. -->
<p>The  algorithm can be generalized to matching directed graphs by eigendecomposing the Hermitian matrices <span class="math inline">\(E_A\)</span> and <span class="math inline">\(E_B\)</span> derived from the asymmetric adjacency matrices of the directed graphs. The Hermitian matrix for the adjacency matrix <span class="math inline">\(A\)</span> is defined as <span class="math inline">\(E_A=A_S+iA_N\)</span>, where <span class="math inline">\(A_S=(A+A^T)/2\)</span> is a symmetric matrix, <span class="math inline">\(A_N=(A-A^T)/2\)</span> is a skew-symmetric matrix and <span class="math inline">\(i\)</span> is the imaginary unit. Similarly, we can define the Hermitian matrix for <span class="math inline">\(B\)</span>. Assume the eigendecompositions of <span class="math inline">\(E_A\)</span> and <span class="math inline">\(E_B\)</span> as follows: <span class="math display">\[\begin{align*}
    E_A=W_A\Gamma_AW_A^*, \quad  E_B=W_B\Gamma_BW_B^*
\end{align*}\]</span> and we aim at searching for: <span class="math display">\[\begin{align*}
    \hat{P}=\mathop{\mathop{\mathrm{argmax}}}_{P\in\Pi}\mathrm{trace}(|W_B||W_A|^TP)
\end{align*}\]</span> Note that the  algorithm works on the condition that two graphs are isomorphic or nearly isomorphic.</p>

</div>
</div>
</div>
<div id="auxiliary-graph-matching-tools" class="section level2">
<h2>Auxiliary graph matching tools</h2>
<!-- \todo{move to usage?} -->
<div id="centering-technique" class="section level3">
<h3>Centering technique</h3>
<p>Instead of encoding the non-adjacencies by zeros in the adjacency matrices, the centering technique  assigns negative values to such edges. The first approach is encoding non-adjacent node-pairs as <span class="math inline">\(-1\)</span> with centered adjacency matrices <span class="math inline">\(\tilde{A}=2A-\textbf{J}\)</span> and <span class="math inline">\(\tilde{B}=2B-\textbf{J}\)</span>, where <span class="math inline">\(\textbf{J}\)</span> is a matrix of all ones. An alternative approach relies on modeling assumptions where the pair of graphs are correlated but do not share a global structure. We match <span class="math inline">\(\tilde{A} = A-\Lambda_A\)</span> and <span class="math inline">\(\tilde{B} = B-\Lambda_B\)</span>, where <span class="math inline">\(\Lambda\)</span> is an <span class="math inline">\(n\text{-by-}n\)</span> matrix with <span class="math inline">\(ij\)</span>-th entry denoting an estimated marginal probability of an edge. In general, <span class="math inline">\(\Lambda\)</span> is unknown but there are methods in the literature to estimate <span class="math inline">\(\Lambda\)</span>.</p>
<p>Matching centered graphs changes the rewards for matching edges, non-edges, and the penalties for mismatches. Adapting the centering technique for the problem at hand can be used to find specific types of correspondences. This can also be combined with constructing multilayer networks out of single layer networks to match according to multiple criteria . <!-- \todo{cite Lin paper and GRAMPA paper}  --> The centering technique can be applied to any of the implemented graph matching algorithm. It is especially useful when padding graphs with differing numbers of vertices to distinguish isolated vertices from padded vertices.</p>
</div>
<div id="padding-graphs-of-different-orders" class="section level3">
<h3>Padding graphs of different orders</h3>
<p>Until this section, we have been considering matching two graphs whose vertex sets are of the same cardinality. However, matching graphs with different orders are commonly seen in real-world problems.</p>
<!-- Except for the \textsc{percolation} algorithm and the \textsc{Isorank} algorithm which is based on the greedy method to find an alignment between two graphs, issues occur when the dimensions of the adjacency matrices $A$ and $B$ differ. -->
<!-- One of the biggest issues associated with this is that the objective function $\lVert A-PBP^T \rVert_F^2$ to the graph matching problem no longer holds since the permutation matrix $P$ ought to be a square matrix. -->
<!-- Another issue applies to algorithms using the Hungarian algorithm as a final step to extract mappings, including the \textsc{Frank-Wolfe} methodology and the \textsc{Umeyama} methodology, as the Hungarian algorithm only works for square matrices. -->
<!-- These lead us to deploy the padding scheme \cite{SGM} to accommodate for the order difference. -->
<p>Suppose <span class="math inline">\(A\in\{0,1\}^{n\times n}\)</span> and <span class="math inline">\(B\in\{0,1\}^{n_c\times n_c}\)</span> with <span class="math inline">\(n_c&lt;n\)</span>. One can then pad the smaller graph with extra vertices to match the order of the larger graph, <span class="math inline">\(\tilde{B}=B\oplus \textbf{0}_{n-n_c}\)</span> and match <span class="math inline">\(A\)</span> and <span class="math inline">\(\tilde{B}\)</span>. Every implemented graph matching algorithm in the <code>iGraphMatch</code> package automatically handles input graphs with a different number of vertices using sparse padding with minimal memory impact.</p>
<p>Since the isolated vertices and the padded vertices share the same topological structure, it can be useful to center the original graphs first then pad the smaller graph in the same manner. This approach serves to differentiate between isolated vertices the padded ones. It’s theoretically verified that in the correlated graph model, the centered padding scheme is guaranteed to find the true correspondence between the nodes of <span class="math inline">\(G_1\)</span> and the induced subgraph of <span class="math inline">\(G_2\)</span> under mild conditions even if <span class="math inline">\(|V_1|\ll|V_2|\)</span>, but the true alignment is not guaranteed without centering .</p>
</div>
<div id="exploiting-sparse-and-low-rank-structure" class="section level3">
<h3>Exploiting sparse and low-rank structure</h3>
<p>Many real-world graphs, especially large graphs, are often very sparse with <span class="math inline">\(o(n^2)\)</span> and often <span class="math inline">\(\theta(n)\)</span> edges. This can increase the difficulty of the graph matching problem due to the fact that there are fewer potential edges to match, but sparse graphs also come with computational advantages. We rely on <code>igraph</code> and <code>Matrix</code> for efficient storage of these structures as well as the efficient implementation of various matrix operations. We also use the LAPMOD algorithm for sparse LAP problems .</p>
<p>Similarly, a low-rank structure appears in some of the procedures including starting at the rank-1 barycenter matrix and the different centering schemes. Since low-rank matrices are generally not sparse and visa-versa we implemented the <code>splr</code> S4 class, standing for sparse plus low-rank matrices. This class inherits from the <code>Matrix</code> class and includes slots for an <span class="math inline">\(n\times n\)</span> sparse matrix <code>x</code> and <span class="math inline">\(n\times d\)</span> dense matrices <code>a</code> and <code>b</code>, to represent matrices of the form <code>x + tcrossprod(a, b)</code>. This class implements efficient methods for matrix multiplication and other operations that exploit the sparse and low-rank structure of the matrices. Specifically, these methods often require only <span class="math inline">\(O(\|x\|_0) + O(nd)\)</span> storage as opposed to <span class="math inline">\(O(n^2)\)</span> required for densely stored matrices, and enjoy analogous computational advantages. While users can also use these matrices explicitly, most use of them is automatic within functions such as <code>init_start</code> and <code>center_graph</code> and the matrices can largely be used interchangeably with other matrices.</p>
</div>
<div id="multi-layered-graph-matching" class="section level3">
<h3>Multi-layered graph matching</h3>
<p>Frequently, networks edges may have categorical attributes and from these categories, we can construct multilayer graphs , where each layer in the networks contains edges from specific categories. For matching two multilayer graphs, the standard graph matching problem can be extended as <span class="math inline">\(\sum_{l=1}^{m}\|A^{(l)} - PB^{(l)}P^T\|_F^2\)</span> where <span class="math inline">\(m\)</span> denotes the number of categories and <span class="math inline">\(A^{(l)}, B^{(l)}\)</span> are the adjacency matrices for the <span class="math inline">\(l\)</span>th layers in each graph. Note, we assume that the layers are aligned, so that layer <span class="math inline">\(l\)</span> corresponds to the same edge-types in both multi-layer networks.</p>
<p>For an <code>igraph</code> object, the function <code>split_igraph</code> can be used to convert a single object with categorical edge attributes into a list with each element only containing the edges with a specific attribute value. The implemented algorithms can seamlessly match multi-layer graphs, which are encoded as a list of either <code>igraph</code> objects or <code>matrix</code>-like objects. We also implemented a <code>matrixlist</code> S4 class that implements many standard matrix operations so that algorithms can be easily extended to work with multilayer networks.</p>
</div>
</div>
<div id="graph-models" class="section level2">
<h2>Correlated random graph models</h2>
<p>The correlated model  is essential in the theoretical study of graph matching algorithms. In a single graph, each edge is present in the graph independently with probability <span class="math inline">\(p\)</span>. The correlated model provides a joint distribution for a pair of graphs, where each graph is marginally distributed as an graph and corresponding edge-pairs are correlated.</p>

<p>To sample a pair of correlated graphs with edge probability <span class="math inline">\(p\)</span>, and Pearson correlation <span class="math inline">\(\rho\)</span>, we first sample three independent graphs <span class="math inline">\(G_1\)</span>, <span class="math inline">\(Z_0\)</span> and <span class="math inline">\(Z_1\)</span> with edge probabilities <span class="math inline">\(p\)</span>, <span class="math inline">\(p(1-\rho)\)</span> and <span class="math inline">\(p+\rho(1-p)\)</span> respectively. Let <span class="math inline">\(G_2 = (Z_1 \cap G_1) \bigcup (Z_0\cap G_1^c)\)</span>.</p>
<p> provide an alternative formulation for the correlated model. First, one samples a single random graph <span class="math inline">\(G\)</span> with edge probability <span class="math inline">\(p&#39;\)</span>. Conditioned on <span class="math inline">\(G\)</span>, each edge in <span class="math inline">\(G\)</span> is present independently in <span class="math inline">\(G_1,G_2\)</span> with probability <span class="math inline">\(s&#39;\)</span>. <!-- All non-edges in $G$ are non-edges in $G_1,G_2$. --> These two parameterizations are related to each other by the relationship <span class="math inline">\(s&#39;=p+\rho(1-p)\)</span> and <span class="math inline">\(p&#39;=p/(p+\rho(1-p))\)</span>. The original parameterization is slightly more general because it allows for the possibility of negative correlation.</p>
<p>In addition to homogeneous correlated random graphs, we also implement heterogeneous generalizations of this model. The stochastic block model  and the random dot product graphs (RDPG) model  can both be regarded as extensions of the model. The stochastic block model is useful to represent the community structure of graphs by dividing the graph into <span class="math inline">\(K\)</span> groups. Each node is assigned to a group and the probability of edges is determined by the group memberships of the vertex pair. For the RDPG model, each vertex is assigned a latent position in <span class="math inline">\(\mathbb{R}^d\)</span> and edge probabilities are given by the inner product between the latent positions of the vertex pair.</p>
<!--
with different ways of specifying the edge probability to incorporate some special properties of graph structures.
-->
<!--
Edges within the same group share the same edge probability while the within-group edge probability can vary across different groups.
There can be edges occurring between the nodes from different groups as well, while the between-group edge probability should be smaller than the within-group edge probability.
-->
<!-- pair of vertices $1\le u\le v\le n$, the edge probability between them is specified by the dot product of two vectors in $\mathbb{R}^d$ drawn.
Given this, the probability of an edge occurring between $\{u,v\}$ is determined by the Bernoulli trial with probability given by the dot product of two latent positions vectors.
Thus, the edge probability matrix $pJ$ in definition \ref{def: ER} is replaced by a random dot product matrix with differing entries. -->
<p>For both of these models, we can consider correlated graph-pairs where marginally they arise from one of these models and again corresponding edge pairs are correlated. <!-- Similar to how we generate a pair of correlated \ErdosRenyi graphs, we provide corresponding functions for generating the correlated RDPG, SBM, and general heterogeneous graph pairs. --></p>
<!-- \todo{put this remark here}In the `iGraphMatch` package, for all graph matching algorithms that are eventually reduced to solving LAPs including all the relaxation-based algorithms, \textsc{Umeyama} algorithm and \textsc{IsoRank} using \textsc{Hungarian} algorithm, we obscure the vertex correspondence by randomly permuting the second network inside these functions to reduce bias. -->
</div>
<div id="sec:measure" class="section level2">
<h2>Measures for goodness of matching</h2>
<p>The ability to assess the quality of the match when ground truth is unavailable is critical for the usage of the matching approaches. There are various topological criteria that can be applied to measure the quality of matching results. At the graph level, the most frequently used structural measures include matching pairs (MP), edge correctness (EC), and the size of the largest common connected subgraph (LCCS) . MP counts the number of correctly matched pairs of nodes, thus can only be used when the true alignment is available. Global counts of common edges (CE) and common non-edges (CNE) can be defined as <span class="math display">\[\begin{align*}
    CE=\frac{1}{2}\sum_{i,j}\mathds{1}\{A_{ij}=PBP^T_{ij} =1\}\quad CNE=\frac{1}{2}\sum_{i,j}\mathds{1}\{A_{ij}=PBP^T_{ij} = 0\},
\end{align*}\]</span> along with error counts such extra edges (EE) and missing edges (ME), <span class="math display">\[\begin{align*}
    EE=\frac{1}{2}\sum_{i,j}\mathds{1}\{A_{ij}=0=1 - PBP^T_{ij}\}\quad ME=\frac{1}{2}\sum_{i,j}\mathds{1}\{A_{ij}= 1 = 1 - PBP^T_{ij}\},
\end{align*}\]</span></p>
<p>EC measures the percentage of correctly aligned edges, that is the fraction CE<span class="math inline">\(/|E_1|\)</span>. The LCCS denotes the largest subset of aligned vertices such that the corresponding induced subgraphs of each graph are connected. <!-- \todo{mathematical definition?} --> Matches with a larger LCCS are often preferable to those with many isolated components.</p>
<p>Another group of criteria measures the goodness of matching at the vertex level. Informally, we aim at testing the hypotheses <!-- \todo{i think reversing these makes more sense} --> <span class="math display">\[H_0^{(v)}: \text{the vertex } v \text{ is not matched correctly by } P^*, \]</span> <span class="math display">\[H_a^{(v)}: \text{the vertex } v \text{ is matched correctly by } P^*\]</span> for each vertex <span class="math inline">\(v\)</span>.</p>
<p>The goal is to address if the permutation matrix found by graph matching algorithm is significantly different from the one sampled from uniformly distributed permutation matrices . Unfortunately, vertex-level matching criteria have only received limited attention in the literature, however, we include two test statistics to measure fit. The row difference statistic is the L<span class="math inline">\(_1\)</span>-norm of the difference between <span class="math inline">\(A\)</span> and <span class="math inline">\(P^*B{P^*}^T\)</span>, namely <span class="math display">\[\begin{equation*}
T_d(v,P^*):=\Vert A_{v\cdot}-(P^*B{P^*}^T)_{v\cdot}\Vert_1.
\end{equation*}\]</span> Intuitively, a correctly matched vertex <span class="math inline">\(v\)</span> should induce a smaller <span class="math inline">\(T_d(v,P^*)\)</span>, which for unweighted graphs corresponds to the number of edge disagreements induced by matching <span class="math inline">\(v\)</span>. Alternatively, the row correlation statistic is defined as <span class="math display">\[\begin{equation*}
T_c(v,P^*):=1 - corr(A_{v\cdot},(P^*B{P^*}^T)_{v\cdot}).
\end{equation*}\]</span> We expect the empirical correlation between the neighborhoods of <span class="math inline">\(v\)</span> in <span class="math inline">\(A\)</span> and <span class="math inline">\(P^*B{P^*}^T\)</span> to be larger for a correctly matched vertex. <!-- The row correlation statistic is preferable to the row difference statistic for weighted graphs since the former statistic put less stress on the weight magnitude. --></p>
<p>We employ permutation testing ideas to the raw statistics as a normalization across vertices. Let us take the row difference statistic for example. The guiding intuition is that if <span class="math inline">\(v\)</span> is correctly matched, the number of errors induced by <span class="math inline">\(P^*\)</span> across the neighborhood of <span class="math inline">\(v\)</span> in <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> (i.e., <span class="math inline">\(T_d(v, P^*)\)</span>) should be significantly smaller than the number of errors induced by a randomly chosen permutation <span class="math inline">\(P\)</span> (i.e., <span class="math inline">\(T_d(v, P)\)</span>).</p>
<p>With this in mind, let <span class="math inline">\(\mathbb{E}_P\)</span> and <span class="math inline">\(\mathrm{Var}_P\)</span> denote the conditional expectation and variance of the raw statistic with <span class="math inline">\(P\)</span> uniformly sampled over all permutation matrices. The normalization is then given by <span class="math display">\[\begin{equation*}
T_p(v,P^*):=\frac{T(v,P^*)-\mathbb{E}_PT(v,P)}{\sqrt{Var_PT(v,P)}}
\end{equation*}\]</span> where <span class="math inline">\(T(v, P)\)</span> can be either of the two test statistics we introduced earlier. <!-- The variance and expectation can either be computed by  --> <!-- Hence, more extreme values are It is more likely that we find the true alignment to a vertex $v$ by $P^*$ if the value of $T_P(v, P^*)$ is larger. --></p>
<p>In addition to measuring match quality, these vertex-wise statistics can also serve as a tool to find which vertices have no valid match in another network, i.e. the vertex entity is present in one network but not the other.</p>
<!--chapter:end:02_gm_background.Rmd-->
</div>
</div>
<div id="sec:usage" class="section level1">
<h1>R functions and usage</h1>
<p>The R package <code>iGraphMatch</code> offers versatile options for graph matching and subsequent analysis. Here we describe the usage of the package including sampling random correlated graph pairs, graph matching, and evaluating matching results.</p>
<div id="sampling-correlated-random-graph-pairs" class="section level2">
<h2>Sampling correlated random graph pairs</h2>
<p>We first illustrate the usage of functions for sampling correlated random graph pairs. The usage of graph matching will be demonstrated on the graph-pairs sampled using these methods.</p>
<p>Functions of the form <code>sample_correlated_*_pair</code> for sampling random graph pairs have the common syntax:</p>
<pre><code>sample_correlated_*_pair(n, ***model parameters***, 
  permutation = 1:n, directed = FALSE, loops = FALSE)</code></pre>
<p>The argument <code>n</code> specifies the number of nodes in each graph, and the default options are to sample a pair of undirected graphs without self-loop whose true alignment is the identity. The <code>permutation</code> argument can be used to permute the vertex labels of the second graph. The <code>model parameters</code> arguments vary according to different random graph models and typically consist of parameters for marginal graph distributions and for correlations between the corresponding edges. The functions each return a named list of two <code>igraph</code> objects.</p>
<p>For the homogeneous correlated graph model, the model parameters are <code>p</code>, the global edge probability, and <code>corr</code>, the Pearson correlation between aligned vertex-pairs. For example, to sample a pair of graphs with 5 nodes from <span class="math inline">\(\mathrm{CorrER}(0.5J, 0.7J)\)</span> we run <!-- \todo{move first lines?} --></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">library</span>(iGraphMatch)</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="kw">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb2-3"><a href="#cb2-3"></a>cgnp_pair &lt;-<span class="st"> </span><span class="kw">sample_correlated_gnp_pair</span>(<span class="dt">n =</span> <span class="dv">5</span>, <span class="dt">corr =</span> <span class="fl">0.7</span>, <span class="dt">p =</span> <span class="fl">0.5</span>)</span>
<span id="cb2-4"><a href="#cb2-4"></a>(cgnp_g1 &lt;-<span class="st"> </span>cgnp_pair<span class="op">$</span>graph1)</span></code></pre></div>
<pre><code>## IGRAPH ad1493e U--- 5 4 -- Erdos renyi (gnp) graph
## + attr: name (g/c), type (g/c), loops (g/l), p (g/n)
## + edges from ad1493e:
## [1] 1--2 2--3 2--5 3--5</code></pre>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a>cgnp_g1[]</span></code></pre></div>
<pre><code>## 5 x 5 sparse Matrix of class &quot;dgCMatrix&quot;
##               
## [1,] . 1 . . .
## [2,] 1 . 1 . 1
## [3,] . 1 . . 1
## [4,] . . . . .
## [5,] . 1 1 . .</code></pre>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a>cgnp_g2 &lt;-<span class="st"> </span>cgnp_pair<span class="op">$</span>graph2</span></code></pre></div>
<!-- From `igraph`, `cgnp_g1[]` converts the `igraph` object to a sparse \pkg{Matrix} form. -->
<!-- In the next subsection, we will demonstrate the usage of the graph matching methods using this sampled pair of correlated \ErdosRenyi graphs.  -->
<p>Since we didn’t obscure the vertex correspondence by assigning a value to the <code>permutation</code> argument, the underlying true alignment is the identity. <!-- , and here the sampled adjacency matrices are binary (unweighted) and symmetric (undirected). --></p>
<p>For the more general heterogeneous correlated graph model, one needs to specify an edge probability matrix and a Pearson correlation matrix. To sample a pair of graphs from the heterogeneous correlated model again with 5 nodes in each graph, and with random edge probabilities and Pearson correlations:</p>
<!-- \todo{note this is undirected} -->
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a>p &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">runif</span>(<span class="dv">5</span><span class="op">^</span><span class="dv">2</span>),<span class="dv">5</span>)</span>
<span id="cb7-2"><a href="#cb7-2"></a>c &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">runif</span>(<span class="dv">5</span><span class="op">^</span><span class="dv">2</span>),<span class="dv">5</span>)</span>
<span id="cb7-3"><a href="#cb7-3"></a>ieg_pair &lt;-<span class="st"> </span><span class="kw">sample_correlated_ieg_pair</span>(<span class="dt">n =</span> <span class="dv">5</span>, <span class="dt">p_mat =</span> p, <span class="dt">c_mat =</span> c)</span></code></pre></div>
<p>Since the default is undirected graphs without self-loops, the entries of <code>p</code> and <code>c</code> along and below the diagonal are effectively ignored.</p>
<p>The stochastic block model requires block-to-block edge probabilities stored in the <code>pref.matrix</code> argument and the <code>block.sizes</code> argument indicates the size of each block, along with the Pearson correlation parameter <code>corr</code>. Next, we sample a pair of graphs from the stochastic block model with two blocks of size 2 nodes and 3 nodes respectively, within-group edge probabilities of .7 and .5, across-group edge probability of .001, and Pearson correlation equal to .5.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a>pm &lt;-<span class="st"> </span><span class="kw">cbind</span>(<span class="kw">c</span>(.<span class="dv">7</span>, <span class="fl">.001</span>), <span class="kw">c</span>(.<span class="dv">001</span>, <span class="fl">.5</span>))</span>
<span id="cb8-2"><a href="#cb8-2"></a>sbm_pair &lt;-<span class="st"> </span><span class="kw">sample_correlated_sbm_pair</span>(<span class="dt">n =</span> <span class="dv">5</span>, <span class="dt">pref.matrix =</span> pm,</span>
<span id="cb8-3"><a href="#cb8-3"></a>                                       <span class="dt">block.sizes =</span> <span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">3</span>), <span class="dt">corr =</span> <span class="fl">0.5</span>)</span></code></pre></div>
<p>The <code>iGraphMatch</code> package also provides functions for sampling a pair of correlated random graphs with junk vertices, i.e vertices that don’t have true correspondence in the other graph by specifying the number of overlapping vertices in the argument <code>ncore</code> or overlapping block sizes in the argument <code>core.block.sizes</code>.</p>
<p>The <code>iGraphMatch</code> package offers auxiliary tools for centering graphs to penalize the incorrect matches as well, which is implemented in the <code>center_graph</code> function with syntax:</p>
<pre><code>center_graph(A, scheme = c(-1, 1), use_splr = TRUE)</code></pre>
<p>with the first input being either a matrix-like or igraph object. The <code>scheme</code> argument specifies the method for centering graphs. Options include a pair of scalars where the entries of the adjacency matrix are linearly rescaled so that their minimum is <code>min(scheme)</code> and their maximum is <code>max(scheme)</code>. Note, <code>scheme = &quot;center&quot;</code> is the same as <code>scheme = c(-1, 1)</code>. Another option is to pass in a single integer, where the returned value is the adjacency matrix minus its best rank-<code>scheme</code> approximation. The last argument <code>use_splr</code> is a boolean indicating whether to return a <code>splrMatrix</code> object. We use <code>use_splr = FALSE</code> here to better display the matrices but <code>use_splr = TRUE</code> will often result in improved performance, especially for large sparse networks. Here, we center the sampled graph <code>cgnp_g1</code> using different schemes:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">center_graph</span>(cgnp_g1, <span class="dt">scheme =</span> <span class="st">&quot;center&quot;</span>, <span class="dt">use_splr =</span> <span class="ot">FALSE</span>)</span></code></pre></div>
<pre><code>## 5 x 5 Matrix of class &quot;dgeMatrix&quot;
##      [,1] [,2] [,3] [,4] [,5]
## [1,]   -1    1   -1   -1   -1
## [2,]    1   -1    1   -1    1
## [3,]   -1    1   -1   -1    1
## [4,]   -1   -1   -1   -1   -1
## [5,]   -1    1    1   -1   -1</code></pre>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">center_graph</span>(cgnp_g1, <span class="dt">scheme =</span> <span class="dv">2</span>, <span class="dt">use_splr =</span> <span class="ot">FALSE</span>)</span></code></pre></div>
<pre><code>## 5 x 5 Matrix of class &quot;dgeMatrix&quot;
##        [,1]   [,2]   [,3] [,4]   [,5]
## [1,]  0.207  0.064 -0.093    0 -0.093
## [2,]  0.064  0.020 -0.029    0 -0.029
## [3,] -0.093 -0.029 -0.458    0  0.542
## [4,]  0.000  0.000  0.000    0  0.000
## [5,] -0.093 -0.029  0.542    0 -0.458</code></pre>
<!-- center_graph(cgnp_g1, scheme = c(-4, 2), use_splr = FALSE) -->
<p>Users can then use the centered graphs as inputs to the implemented graph matching algorithms, which serve to alter rewards and penalties for common edges, common non-edges, missing edges, and extra edges.</p>
</div>
<div id="graph-matching-methods" class="section level2">
<h2>Graph matching methods</h2>
<p>The graph matching methods share the same basic syntax:</p>
<!-- \todo{how consistent is this?} -->
<pre><code>gm(A, B, seeds = NULL, similarity = NULL, method = &quot;indefinite&quot;, 
  ***algorithm parameters***)</code></pre>
<table>
<caption>(#tab:gm-alg) Overview of arguments for different graph matching functions.</caption>
<colgroup>
<col width="17%"></col>
<col width="21%"></col>
<col width="39%"></col>
<col width="21%"></col>
</colgroup>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
<th>Functions</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>start</code></td>
<td>Matrix or character</td>
<td>Initialization of the start matrix for iterations.</td>
<td><code>FW, convex</code></td>
</tr>
<tr class="even">
<td><code>lap_method</code></td>
<td>Character</td>
<td>Method for solving linear assignment problem.</td>
<td><code>FW, convex, PATH, IsoRank</code></td>
</tr>
<tr class="odd">
<td><code>max_iter</code></td>
<td>Number</td>
<td>Maximum number of iterations.</td>
<td><code>FW, convex, PATH, IsoRank</code></td>
</tr>
<tr class="even">
<td><code>tol</code></td>
<td>Number</td>
<td>Tolerance of edge disagreements.</td>
<td><code>FW, convex, PATH</code></td>
</tr>
<tr class="odd">
<td><code>r</code></td>
<td>Number</td>
<td>Threshold of neighboring pair scores.</td>
<td><code>percolation</code></td>
</tr>
<tr class="even">
<td><code>ExpandWhenStuck</code></td>
<td>Boolean</td>
<td><code>TRUE</code> if performs  algorithm.</td>
<td><code>percolation</code></td>
</tr>
</tbody>
</table>
<p>The first two arguments for graph matching algorithms represent two networks which can be matrices, igraph objects, or two lists of either form in the case of multi-layer matching. The <code>seeds</code> argument contains prior information on the known partial correspondence of two graphs. It can be a vector of logicals or indices if the seed pairs have the same indices in both graphs. In general, the <code>seeds</code> argument takes a matrix or a data frame as input with two columns indicating the indices of seeds in the two graphs respectively. The <code>similarity</code> parameter is for a matrix of similarity scores between the two vertex sets, with larger scores indicating higher similarity. Notably, one should be careful with the different scales of the graph topological structure and the vertex similarity information in order to properly address the relative importance of each part of the information. The <code>method</code> argument specifies a graph matching algorithm to use, and one can choose from “indefinite” (default), “convex”, “PATH”, “percolation”, “IsoRank”, “Umeyama”, or a self-defined graph matching function which enables users to test out their own algorithms while remaining compatible with the package. If <code>method</code> is a function, it should take at least two networks, seeds and similarity scores as arguments. Users can also include additional arguments if applicable. The self-defined graph matching function should return an object of the “graphMatch” class with matching correspondence, sizes of two input graphs, and other matching details. <!-- \todo[inline]{I remember the editor mentioned extensibility, which we have not yet implemented, but it would be good to think about that before we resubmit.} --> As an illustrative example, <code>graph_match_rand</code> defines a new graph matching function which matches by randomly permuting the vertex label of the second graph using a random seed <code>rand_seed</code>. We then apply this self-defined GM method to matching the correlated graphs sampled earlier with a specified random seed:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1"></a>graph_match_rand &lt;-<span class="st"> </span><span class="cf">function</span>(A, B, <span class="dt">seeds =</span> <span class="ot">NULL</span>, </span>
<span id="cb15-2"><a href="#cb15-2"></a>                             <span class="dt">similarity =</span> <span class="ot">NULL</span>, rand_seed){</span>
<span id="cb15-3"><a href="#cb15-3"></a>  totv1 &lt;-<span class="st"> </span><span class="kw">nrow</span>(A[[<span class="dv">1</span>]])</span>
<span id="cb15-4"><a href="#cb15-4"></a>  totv2 &lt;-<span class="st"> </span><span class="kw">nrow</span>(B[[<span class="dv">1</span>]])</span>
<span id="cb15-5"><a href="#cb15-5"></a>  nv &lt;-<span class="st"> </span><span class="kw">max</span>(totv1, totv2)</span>
<span id="cb15-6"><a href="#cb15-6"></a></span>
<span id="cb15-7"><a href="#cb15-7"></a>  <span class="kw">set.seed</span>(rand_seed)</span>
<span id="cb15-8"><a href="#cb15-8"></a>  corr &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">corr_A =</span> <span class="dv">1</span><span class="op">:</span>nv, </span>
<span id="cb15-9"><a href="#cb15-9"></a>                     <span class="dt">corr_B =</span> <span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span>nv)[<span class="kw">sample</span>(nv)])</span>
<span id="cb15-10"><a href="#cb15-10"></a></span>
<span id="cb15-11"><a href="#cb15-11"></a>  <span class="kw">graphMatch</span>(</span>
<span id="cb15-12"><a href="#cb15-12"></a>    <span class="dt">corr =</span> corr,</span>
<span id="cb15-13"><a href="#cb15-13"></a>    <span class="dt">nnodes =</span> <span class="kw">c</span>(totv1, totv2),</span>
<span id="cb15-14"><a href="#cb15-14"></a>    <span class="dt">detail =</span> <span class="kw">list</span>(</span>
<span id="cb15-15"><a href="#cb15-15"></a>      <span class="dt">rand_seed =</span> rand_seed</span>
<span id="cb15-16"><a href="#cb15-16"></a>    )</span>
<span id="cb15-17"><a href="#cb15-17"></a>  )</span>
<span id="cb15-18"><a href="#cb15-18"></a>}</span>
<span id="cb15-19"><a href="#cb15-19"></a></span>
<span id="cb15-20"><a href="#cb15-20"></a>match_rand &lt;-<span class="st"> </span><span class="kw">gm</span>(cgnp_g1, cgnp_g2, </span>
<span id="cb15-21"><a href="#cb15-21"></a>                 <span class="dt">method =</span> graph_match_rand, <span class="dt">rand_seed =</span> <span class="dv">123</span>)</span></code></pre></div>
<p>Other arguments vary for different graph matching algorithms with an overview given in Table . The <code>start</code> argument for the  methodology with “indefinite” and “convex” relaxations takes any <span class="math inline">\(nns\text{-by-}nns\)</span> matrix or an initialization method including “bari”, “rds” or “convex”. These represent initializing the iterations at a specific matrix, the barycenter, a random doubly stochastic matrix, or the doubly stochastic solution from “convex” method on the same graphs, respectively.</p>
<p>Moreover, sometimes we have access to side information on partial correspondence with uncertainty. If we still treat such prior information as hard seeds and pass them through the <code>seeds</code> argument for “indefinite” and “convex” methods, incorrect information can yield unsatisfactory matching results. Instead, we provide the option of soft seeding by incorporating the noisy partial correspondence into the initialization of the start matrix. The core function used for initializing the start matrix with versatile options is the <code>init_start</code> function.</p>
<p>Suppose the first two pairs of nodes are hard seeds and another pair of incorrect seed <span class="math inline">\((3,4)\)</span> is soft seeds:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1"></a>hard_seeds &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">5</span> <span class="op">&lt;=</span><span class="st"> </span><span class="dv">2</span></span>
<span id="cb16-2"><a href="#cb16-2"></a>soft_seeds &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">seed_A =</span> <span class="dv">3</span>, <span class="dt">seed_B =</span> <span class="dv">4</span>)</span></code></pre></div>
<p>We generate a start matrix incorporating soft seeds initialized at the barycenter: <!-- $D_{bari}=\frac{1}{n_{ns}-n_{ss}}\mathbbm{1}\mathbbm{1}_{(n_{ns}-n_{ss})\times (n_{ns}-n_{ss})}$, where $n_{ns}$ and $n_{ss}$ are the number of non-hard-seed vertices and the number of soft seeds --></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">as.matrix</span>(start_bari &lt;-<span class="st"> </span><span class="kw">init_start</span>(<span class="dt">start =</span> <span class="st">&quot;bari&quot;</span>, <span class="dt">nns =</span> <span class="dv">3</span>,</span>
<span id="cb17-2"><a href="#cb17-2"></a>      <span class="dt">ns =</span> <span class="dv">2</span>, <span class="dt">soft_seeds =</span> soft_seeds))</span></code></pre></div>
<pre><code>##      [,1] [,2] [,3]
## [1,]  0.0    1  0.0
## [2,]  0.5    0  0.5
## [3,]  0.5    0  0.5</code></pre>
<p>An alternative is to generate a start matrix that is a random doubly stochastic matrix incorporating soft seeds as follow</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1"></a><span class="kw">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="kw">as.matrix</span>(start_rds &lt;-<span class="st"> </span><span class="kw">init_start</span>(<span class="dt">start =</span> <span class="st">&quot;rds&quot;</span>, <span class="dt">nns =</span> <span class="dv">3</span>,</span>
<span id="cb19-3"><a href="#cb19-3"></a>      <span class="dt">ns =</span> <span class="dv">2</span>, <span class="dt">soft_seeds =</span> soft_seeds))</span></code></pre></div>
<pre><code>##      [,1] [,2] [,3]
## [1,] 0.00    1 0.00
## [2,] 0.52    0 0.48
## [3,] 0.48    0 0.52</code></pre>
<p>Then we can initialize the  iterations at any of the start matrix by specifying the <code>start</code> parameter.</p>
<p>When there are no soft seeds, we no longer need to initialize the start matrix by using <code>init_start</code> first. Instead we can directly assign an initialization method to the <code>start</code> argument in the <code>gm</code> function:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1"></a>match_rds &lt;-<span class="st"> </span><span class="kw">gm</span>(cgnp_g1, cgnp_g2, <span class="dt">seeds =</span> hard_seeds,</span>
<span id="cb21-2"><a href="#cb21-2"></a>                <span class="dt">method =</span> <span class="st">&quot;indefinite&quot;</span>, <span class="dt">start =</span> <span class="st">&quot;rds&quot;</span>)</span></code></pre></div>
<p>Below use solution from the convex relaxation as the initialization for the indefinite relaxation.</p>
<!-- 
match_bari <- graph_match_FW(cgnp_g1, cgnp_g2, hard_seeds, start = start_bari)
match_rds <- graph_match_FW(cgnp_g1, cgnp_g2, hard_seeds, start = start_rds)
 -->
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1"></a><span class="kw">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb22-2"><a href="#cb22-2"></a>match_convex &lt;-<span class="st"> </span><span class="kw">gm</span>(cgnp_g1, cgnp_g2, <span class="dt">seeds =</span> hard_seeds,</span>
<span id="cb22-3"><a href="#cb22-3"></a>                   <span class="dt">method =</span> <span class="st">&quot;indefinite&quot;</span>, <span class="dt">start =</span> <span class="st">&quot;convex&quot;</span>)</span></code></pre></div>
<p>Now let’s match the sampled pair of graphs  from the stochastic block model by using  algorithm. Apart from the common arguments for all the graph matching algorithms,  has another argument  representing the minimum number of matched neighbors required for matching a new qualified vertex pair. Here we adopt the default value which is 2. Also, at least one of similarity scores and seeds is required for  algorithm to kick off. Let’s utilize the same set of hard seeds and assume there is no available prior information on similarity scores.</p>
<!-- \todo{sbm_pair takes up a lot of characters} -->
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1"></a>sbm_g1 &lt;-<span class="st"> </span>sbm_pair<span class="op">$</span>graph1</span>
<span id="cb23-2"><a href="#cb23-2"></a>sbm_g2 &lt;-<span class="st"> </span>sbm_pair<span class="op">$</span>graph2</span>
<span id="cb23-3"><a href="#cb23-3"></a>match_perco &lt;-<span class="st"> </span><span class="kw">gm</span>(sbm_g1, sbm_g1, <span class="dt">seeds =</span> hard_seeds, </span>
<span id="cb23-4"><a href="#cb23-4"></a>                  <span class="dt">method =</span> <span class="st">&quot;percolation&quot;</span>, <span class="dt">r =</span> <span class="dv">2</span>)</span>
<span id="cb23-5"><a href="#cb23-5"></a>match_perco</span></code></pre></div>
<pre><code>## gm(A = sbm_g1, B = sbm_g1, seeds = hard_seeds, method = &quot;percolation&quot;, 
##     r = 2)
## 
## Match (5 x 5):
##   corr_A corr_B
## 1      1      1
## 2      2      2</code></pre>
<p>Without enough prior information on partial correspondence,  couldn’t find any qualifying matches. Suppose in addition to the current pair of sampled graphs, the above sampled correlated homogeneous and heterogeneous graphs are different layers of connectivity for the same set of vertices. We can then match the nonseed vertices based on the topological information in all of these three graph layers. To be consistent, let’s still use the  algorithm with threshold  equal to 2 and the same set of seeds.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1"></a>matrix_lA &lt;-<span class="st"> </span><span class="kw">list</span>(sbm_g1, ieg_pair<span class="op">$</span>graph1, cgnp_g1)</span>
<span id="cb25-2"><a href="#cb25-2"></a>matrix_lB &lt;-<span class="st"> </span><span class="kw">list</span>(sbm_g2, ieg_pair<span class="op">$</span>graph2, cgnp_g2)</span>
<span id="cb25-3"><a href="#cb25-3"></a>match_perco_list &lt;-<span class="st"> </span><span class="kw">gm</span>(<span class="dt">A =</span> matrix_lA, <span class="dt">B =</span> matrix_lB, <span class="dt">seeds =</span> hard_seeds, </span>
<span id="cb25-4"><a href="#cb25-4"></a>                       <span class="dt">method =</span> <span class="st">&quot;percolation&quot;</span>, <span class="dt">r =</span> <span class="dv">2</span>)</span>
<span id="cb25-5"><a href="#cb25-5"></a>match_perco_list</span></code></pre></div>
<pre><code>## gm(A = matrix_lA, B = matrix_lB, seeds = hard_seeds, method = &quot;percolation&quot;, 
##     r = 2)
## 
## Match (5 x 5):
##   corr_A corr_B
## 1      1      1
## 2      2      2
## 3      3      3
## 4      4      4
## 5      5      5</code></pre>
<p>With the same amount of available prior information, we are now able to match all the nodes correctly. <!-- when there are multiple layers of connectivity to extract topological information. --></p>
<p>Finally, we will give an example of matching multi-layers of graphs using  algorithm. Unlike the other algorithm, similarity scores are required for  algorithm. Without further information, we adopt the barycenter as the similarity matrix here.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1"></a><span class="kw">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb27-2"><a href="#cb27-2"></a>sim &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(<span class="kw">init_start</span>(<span class="dt">start =</span> <span class="st">&quot;bari&quot;</span>, <span class="dt">nns =</span> <span class="dv">5</span>, </span>
<span id="cb27-3"><a href="#cb27-3"></a>                            <span class="dt">soft_seeds =</span> hard_seeds))</span>
<span id="cb27-4"><a href="#cb27-4"></a>match_IsoRank &lt;-<span class="st"> </span><span class="kw">gm</span>(<span class="dt">A =</span> matrix_lA, <span class="dt">B =</span> matrix_lB, </span>
<span id="cb27-5"><a href="#cb27-5"></a>                    <span class="dt">seeds =</span> hard_seeds, <span class="dt">similarity =</span> sim, </span>
<span id="cb27-6"><a href="#cb27-6"></a>                    <span class="dt">method =</span> <span class="st">&quot;IsoRank&quot;</span>, <span class="dt">lap_method =</span> <span class="st">&quot;LAP&quot;</span>)</span></code></pre></div>
<!-- \todo{right now the class is called "graphMatch"} -->
<p>Graph matching functions return an object of class “graphMatch” which contains the details of the matching results, including a list of the matching correspondence, a call to the graph matching function and dimensions of the original two graphs.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1"></a>match_convex<span class="op">@</span>corr</span></code></pre></div>
<pre><code>##   corr_A corr_B
## 1      1      1
## 2      2      2
## 3      3      5
## 4      4      4
## 5      5      3</code></pre>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1"></a>match_convex<span class="op">@</span>call</span></code></pre></div>
<pre><code>## gm(A = cgnp_g1, B = cgnp_g2, seeds = hard_seeds, method = &quot;indefinite&quot;, 
##     start = &quot;convex&quot;)</code></pre>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1"></a>match_convex<span class="op">@</span>nnodes</span></code></pre></div>
<pre><code>## [1] 5 5</code></pre>
<p>Additionally, “graphMatch” also returns a list of matching details corresponding to the specified method. Table  provides an overview of returned values for different graph matching methods. With the <code>seeds</code> information, one can obtain a node mapping for non-seeds accordingly</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1"></a>match_convex[<span class="op">!</span>match_convex<span class="op">$</span>seeds]</span></code></pre></div>
<pre><code>##   corr_A corr_B
## 3      3      5
## 4      4      4
## 5      5      3</code></pre>
<table>
<caption>(#tab:gm-value) Overview of return values for different graph matching functions.</caption>
<colgroup>
<col width="22%"></col>
<col width="50%"></col>
<col width="27%"></col>
</colgroup>
<thead>
<tr class="header">
<th align="left">Parameter</th>
<th align="center">Description</th>
<th align="right">Functions</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>seeds</code></td>
<td align="center">A vector of logicals indicating if the corresponding vertex is a seed</td>
<td align="right">All the functions</td>
</tr>
<tr class="even">
<td align="left"><code>soft</code></td>
<td align="center">The functional similarity score matrix with which one can extract more than one matching candidates</td>
<td align="right"><code>FW, convex, PATH, IsoRank, Umeyama</code></td>
</tr>
<tr class="odd">
<td align="left"><code>lap_method</code></td>
<td align="center">Choice for solving the LAP.</td>
<td align="right"><code>FW, convex, Umeyama, IsoRank</code></td>
</tr>
<tr class="even">
<td align="left"><code>iter</code></td>
<td align="center">Number of iterations until convergence or reaches the max_iter.</td>
<td align="right"><code>FW, convex, PATH</code></td>
</tr>
<tr class="odd">
<td align="left"><code>max_iter</code></td>
<td align="center">Maximum number of replacing matches.</td>
<td align="right"><code>FW, convex</code></td>
</tr>
<tr class="even">
<td align="left"><code>match_order</code></td>
<td align="center">The order of vertices getting matched.</td>
<td align="right"><code>percolation, IsoRank</code></td>
</tr>
</tbody>
</table>
<p>The “graphMatch” class object can also be flexibly used as a matrix. In addition to the returned list of matching correspondence, one can obtain the corresponding permutation matrix in the sparse form.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1"></a>match_convex[]</span></code></pre></div>
<pre><code>## 5 x 5 sparse Matrix of class &quot;dsCMatrix&quot;
##               
## [1,] 1 . . . .
## [2,] . 1 . . .
## [3,] . . . . 1
## [4,] . . . 1 .
## [5,] . . 1 . .</code></pre>
<p>Notably, multiplicity is applicable to the “graphMatch” object directly without converting to the permutation matrix. This enables obtaining the permuted second graph, that is <span class="math inline">\(PBP^T\)</span> simply by</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1"></a>match_convex <span class="op">%*%</span><span class="st"> </span>cgnp_g2</span></code></pre></div>
<pre><code>## IGRAPH 616caa1 UN-- 5 5 -- Erdos renyi (gnp) graph
## + attr: name_1 (g/c), name_2 (g/c), type_1 (g/c), type_2 (g/c), loops_1
## | (g/l), loops_2 (g/l), p_1 (g/n), p_2 (g/n), name (g/c), type (g/c),
## | loops (g/l), p (g/n), name (v/n)
## + edges from 616caa1 (vertex names):
## [1] 5--3 2--5 2--3 1--5 1--2</code></pre>
<!-- \todo{Explain how the object can be basically used as a matrix.} -->
<!-- `
The `get_perm_mat` function converts a "gm" object into a permutation matrix, which can be easier to work with in some cases.

```r
get_perm_mat(match_convex)
```
-->
</div>
<div id="evaluation-of-goodness-of-matching" class="section level2">
<h2>Evaluation of goodness of matching</h2>
<p>Along with the graph matching methodology, <code>iGraphMatch</code> has many capabilities for evaluating and visualizing the matching performance. After matching two graphs, the function <code>summary</code> can be used to get a summary of the overall matching result in terms of commonly used measures including the number of matches, the number of correct matches, common edges, missing edges, extra edges and the objective function value. The edge matching information is stored in a data frame named <code>edge_match_info</code>. Note that <code>summary</code> outputs the number of correct matches only when the true correspondence is known by specifying the <code>true_label</code> argument with a vector indicating the true correspondence in the second graph. Applying the <code>summary</code> function on the matching result <code>match_convex</code> with <code>true_label = 1:5</code>, indicating the true correspondence is the identity that provides these summaries.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1"></a><span class="kw">summary</span>(match_convex, cgnp_g1, cgnp_g2, <span class="dt">true_label =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>)</span></code></pre></div>
<pre><code>## Call: gm(A = cgnp_g1, B = cgnp_g2, seeds = hard_seeds, method = &quot;indefinite&quot;, 
##     start = &quot;convex&quot;)
## 
## # Matches: 3
## # True Matches:  1, # Seeds:  2, # Vertices:  5, 5
##                   
##   common_edges 4.0
##  missing_edges 0.0
##    extra_edges 1.0
##          fnorm 1.4</code></pre>
<p>Applying the <code>summary</code> function to a multi-layer graph matching result returns edge statistics for each layer.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1"></a><span class="kw">summary</span>(match_IsoRank, matrix_lA, matrix_lB)</span></code></pre></div>
<pre><code>## Call: gm(A = matrix_lA, B = matrix_lB, seeds = hard_seeds, similarity = sim, 
##     method = &quot;IsoRank&quot;, lap_method = &quot;LAP&quot;)
## 
## # Matches: 3, # Seeds:  2, # Vertices:  5, 5
##          layer 1   2   3
##   common_edges 2 3.0 2.0
##  missing_edges 0 3.0 2.0
##    extra_edges 0 3.0 3.0
##          fnorm 0 3.5 3.2</code></pre>
<p>In realistic scenarios, the true correspondence is not available. <!-- and it's important to come up with an approach to measure the goodness of matching for each pair of match. --> As introduced in section , the user can use vertex level statistics to evaluate match performance. The <code>best_matches</code> function evaluates a vertex-level metric and returns a sorted <code>data.frame</code> of the vertex-matches with the metrics. <!-- has the functionality of finding best matched vertices and identifying core vertices when matching two graphs with junk vertices by ranking the likelihood of being a correct match or core vertices for each pair of matched nodes. --> The arguments are the two networks, a specific measure to use, the number of top-ranked vertex-matches to output, and the matching correspondence in the second graph if applicable. As an example here, we apply <code>best_matches</code> to rank the matches from above with the true underlying alignment</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1"></a><span class="kw">best_matches</span>(cgnp_g1, cgnp_g2, <span class="dt">match =</span> match_convex, </span>
<span id="cb44-2"><a href="#cb44-2"></a>             <span class="dt">measure =</span> <span class="st">&quot;row_perm_stat&quot;</span>, <span class="dt">num =</span> <span class="dv">3</span>, </span>
<span id="cb44-3"><a href="#cb44-3"></a>             <span class="dt">true_label =</span> <span class="dv">1</span><span class="op">:</span>igraph<span class="op">::</span><span class="kw">vcount</span>(cgnp_g1))</span></code></pre></div>
<pre><code>##   A_best B_best measure_value precision
## 1      4      4          -1.4      1.00
## 2      3      5          -1.2      0.50
## 3      5      3          -1.2      0.33</code></pre>
<!-- The output is a data frame with each row being a pair of match in the order of the likelihood of being a correct match. -->
<p>Note, <code>best_matches</code> uses seed information from the <code>match</code> parameter and only outputs non-seed matches. Without the true correspondence, <code>true_label</code> would take the default value and the output data frame only contains the first three columns.</p>
<p>To visualize the matches of smaller graphs, the function <code>plot</code> displays edge discrepancies of the two matched graphs by an adjacency matrix or a ball-and-stick plot, depending on the input format of two graphs.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1"></a><span class="kw">plot</span>(cgnp_g1, cgnp_g2, match_convex)</span>
<span id="cb46-2"><a href="#cb46-2"></a><span class="kw">plot</span>(cgnp_g1[], cgnp_g2[], match_convex)</span></code></pre></div>
<div class="figure">
<img src="data:image/png;base64,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" alt="\label{fig:visualization} Match visualizations. Grey, blue, and red colors indicate common edges, missing edges present only in the first network, and extra edges present only in the second network, respectively." width="47.5%" /><img src="data:image/png;base64,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" alt="\label{fig:visualization} Match visualizations. Grey, blue, and red colors indicate common edges, missing edges present only in the first network, and extra edges present only in the second network, respectively." width="47.5%" />
<p class="caption">
 Match visualizations. Grey, blue, and red colors indicate common edges, missing edges present only in the first network, and extra edges present only in the second network, respectively.
</p>
</div>
<p>The plots for visualizing matching performance of <code>match_convex</code> are shown in Figure . Grey edges and pixels indicate common edges, red ones indicate edges only in the second graph. If they were present, blue pixels and edges represent missing edges that only exist in the first graph. The corresponding linetypes are solid, short dash, and long dash.</p>
<!--chapter:end:03_r_usage.rmd-->
</div>
</div>
<div id="sec:example" class="section level1">
<h1>Examples</h1>
<p>In this section, we demonstrate graph matching analysis using <code>iGraphMatch</code> via examples on real datasets, including communication networks, neuronal networks, and transportation networks. Table @ref(tab:dataset-overview) presents brief overviews of the first two datasets. <!-- with regard to the size of graphs, the density of graphs and some other properties of the graphs.  --> Note that the number of edges doesn’t consider weights for weighted graphs, and for directed graphs, an edge from node <span class="math inline">\(i\)</span> to node <span class="math inline">\(j\)</span> and another edge from <span class="math inline">\(j\)</span> to <span class="math inline">\(i\)</span> will be counted as two edges. Tables @ref(tab:edge-summary) and @ref(tab:edge-summary-trans) summarize the edge correspondence between two graphs under the true alignment including the number of common edges, missing edges, and extra edges in two graphs.</p>
<p>In the first Enron email network example, we demonstrate the usage of  methodology and how to improve matching performance by using the centering technique and incorporating adaptive seeds. In the second example using <em>C. Elegans</em> synapses networks, we illustrate how to use soft matching for a challenging graph matching task using  methodology,  algorithm and  algorithm. Finally, we include an example of matching two multi-layer graphs with similarity scores on the Britain transportation networks. <!-- Note that the two networks in the first and last example are of different sizes. --> <!-- In addition to matching two graphs, we will also illustrate how to detect cores, as opposed to junk vertices which are vertices without true alignments in the other graph. --></p>

<!-- DLS: Move transportation to its own table overviewing all layers -->
<!-- 
| Dataset  | # Nodes | # Edges   |  Correlation |  Weighted | Directed  | Loop |
| :---------- | :----------------: | :-------------: | :-------------: |:------------: | :----------------: | :--------------: |
| Enron          |        184       |  488/ 482   |  0.85  |  No       |   Yes    | Yes |
| _C. Elegans_      | 279           |  2194/ 1031   |  0.10  | Yes |  Yes  | Yes |
| Transp.   | 53/2075     |  56/ 8368    |  0.56 | No |  Yes  | No |

Table: (\#tab:dataset-overview) Overview of datasets for examples. 
Two numbers for edges or nodes indicate counts in the two graphs.
Correlation indicates the empirical Pearson's correlation of entries of the adjacency matrices under the true alignment.
The Britain transportation network consists of 5 layers. # edges indicate the total number of edges in all the layers and the correlation column displays the average empirical Pearson's correlation over all the layers.
 -->
<!-- 
  | Dataset  | Common Edges  | Common Non-Edges |  Extra Edges $G_1 \setminus G_2$ | Extra Edges $G_2 \setminus G_1$  |
-->
<!-- DLS: Same here -->

<!-- Table: (\#tab:edge-summary) Edge summary under the true alignments.  The columns indicate the number of common edges, common non-edges, extra edges in $G_1$, and extra edges in $G_2$. -->
<!-- For weighted graphs, we define a pair of corresponding edges as a common edge as long as they both have positive weights. -->
<!-- For the Transportation network, edges are counted across all layers but only within the induced subgraph of $G_2$ corresponding to the true match. -->
<div id="sec:Enron" class="section level2">
<h2>Example: Enron Email Network Data</h2>
<p>The Enron email network data was originally made public by the Federal Energy Commission during the investigation into the Enron Corporation . <!-- DLS: Citation --> Each node of Enron network represents an email address and if there is at least one email sent from one address to another address, a directed edge exists between the corresponding nodes.</p>
<p>The <code>iGraphMatch</code> package includes the Enron email network data in the form of a pair of <code>igraph</code> objects derived from the original data where each graph represents one week of emails between 184 email addresses. The two networks are unweighted and directed with edge densities around 0.01 in each graph and the empirical correlation between two graphs is 0.85. <!-- DLS: Not sure where you got 0.29 from before? --></p>
<p>First, let’s load packages required for the following analysis:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1"></a><span class="kw">library</span>(igraph)</span>
<span id="cb47-2"><a href="#cb47-2"></a><span class="kw">library</span>(iGraphMatch)</span>
<span id="cb47-3"><a href="#cb47-3"></a><span class="kw">library</span>(purrr)</span>
<span id="cb47-4"><a href="#cb47-4"></a><span class="kw">library</span>(dplyr)</span></code></pre></div>
<div id="visualization-of-enron-networks" class="section level3">
<h3>Visualization of Enron networks</h3>
<p>We visualize the aligned Enron networks using the  function with vertices sorted by a community detection algorithm  and degree. For detailed interpretations to figure , please refer to figure .</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1"></a>g &lt;-<span class="st"> </span>igraph<span class="op">::</span><span class="kw">as.undirected</span>(Enron[[<span class="dv">1</span>]])</span>
<span id="cb48-2"><a href="#cb48-2"></a>com &lt;-<span class="st"> </span>igraph<span class="op">::</span><span class="kw">membership</span>(igraph<span class="op">::</span><span class="kw">cluster_fast_greedy</span>(g))</span>
<span id="cb48-3"><a href="#cb48-3"></a>deg &lt;-<span class="st"> </span><span class="kw">rowSums</span>(<span class="kw">as.matrix</span>(g[]))</span>
<span id="cb48-4"><a href="#cb48-4"></a>ord &lt;-<span class="st"> </span><span class="kw">order</span>(<span class="kw">max</span>(deg)<span class="op">*</span>com<span class="op">+</span>deg)</span>
<span id="cb48-5"><a href="#cb48-5"></a><span class="kw">plot</span>(Enron[[<span class="dv">1</span>]][][ord,ord], Enron[[<span class="dv">2</span>]][][ord,ord])</span></code></pre></div>
<div class="figure">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASAAAAEgCAYAAAAUg66AAAAEDmlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPpu5syskzoPUpqaSDv41lLRsUtGE2uj+ZbNt3CyTbLRBkMns3Z1pJjPj/KRpKT4UQRDBqOCT4P9bwSchaqvtiy2itFCiBIMo+ND6R6HSFwnruTOzu5O4a73L3PnmnO9+595z7t4LkLgsW5beJQIsGq4t5dPis8fmxMQ6dMF90A190C0rjpUqlSYBG+PCv9rt7yDG3tf2t/f/Z+uuUEcBiN2F2Kw4yiLiZQD+FcWyXYAEQfvICddi+AnEO2ycIOISw7UAVxieD/Cyz5mRMohfRSwoqoz+xNuIB+cj9loEB3Pw2448NaitKSLLRck2q5pOI9O9g/t/tkXda8Tbg0+PszB9FN8DuPaXKnKW4YcQn1Xk3HSIry5ps8UQ/2W5aQnxIwBdu7yFcgrxPsRjVXu8HOh0qao30cArp9SZZxDfg3h1wTzKxu5E/LUxX5wKdX5SnAzmDx4A4OIqLbB69yMesE1pKojLjVdoNsfyiPi45hZmAn3uLWdpOtfQOaVmikEs7ovj8hFWpz7EV6mel0L9Xy23FMYlPYZenAx0yDB1/PX6dledmQjikjkXCxqMJS9WtfFCyH9XtSekEF+2dH+P4tzITduTygGfv58a5VCTH5PtXD7EFZiNyUDBhHnsFTBgE0SQIA9pfFtgo6cKGuhooeilaKH41eDs38Ip+f4At1Rq/sjr6NEwQqb/I/DQqsLvaFUjvAx+eWirddAJZnAj1DFJL0mSg/gcIpPkMBkhoyCSJ8lTZIxk0TpKDjXHliJzZPO50dR5ASNSnzeLvIvod0HG/mdkmOC0z8VKnzcQ2M/Yz2vKldduXjp9bleLu0ZWn7vWc+l0JGcaai10yNrUnXLP/8Jf59ewX+c3Wgz+B34Df+vbVrc16zTMVgp9um9bxEfzPU5kPqUtVWxhs6OiWTVW+gIfywB9uXi7CGcGW/zk98k/kmvJ95IfJn/j3uQ+4c5zn3Kfcd+AyF3gLnJfcl9xH3OfR2rUee80a+6vo7EK5mmXUdyfQlrYLTwoZIU9wsPCZEtP6BWGhAlhL3p2N6sTjRdduwbHsG9kq32sgBepc+xurLPW4T9URpYGJ3ym4+8zA05u44QjST8ZIoVtu3qE7fWmdn5LPdqvgcZz8Ww8BWJ8X3w0PhQ/wnCDGd+LvlHs8dRy6bLLDuKMaZ20tZrqisPJ5ONiCq8yKhYM5cCgKOu66Lsc0aYOtZdo5QCwezI4wm9J/v0X23mlZXOfBjj8Jzv3WrY5D+CsA9D7aMs2gGfjve8ArD6mePZSeCfEYt8CONWDw8FXTxrPqx/r9Vt4biXeANh8vV7/+/16ffMD1N8AuKD/A/8leAvFY9bLAAAAOGVYSWZNTQAqAAAACAABh2kABAAAAAEAAAAaAAAAAAACoAIABAAAAAEAAAEgoAMABAAAAAEAAAEgAAAAAKtAJY0AAEAASURBVHgB7Z0HvBRF8seL8ABBEBWRR1CUZEbELCpBMWc9RcR86N877y9nOvXUM5z68a+eemc8M3IgCgb0wFMBBUlHTipIEEQkKlHy/vvb2MvsvNnd2fc2v6r32Tcz3T3dPb+Zqamurq6qEjEkSoqAIqAI5ACBqjloU5tUBBQBRcAioAxIHwRFQBHIGQLKgHIGvTasCCgCyoD0GVAEFIGcIaAMKGfQa8OKgCKgDEifAUVAEcgZAsqAcga9NqwIKALKgPQZUAQUgZwhoAwoZ9Brw4qAIqAMSJ8BRUARyBkCyoByBr02rAgoAsqA9BlQBBSBnCGgDChn0GvDioAioAxInwFFQBHIGQLKgHIGvTasCCgCyoD0GVAEFIGcIaAMKGfQa8OKgCKgDEifAUVAEcgZAsqAcga9NqwIKALKgPQZUAQUgZwhoAwoZ9Brw4qAIqAMSJ8BRUARyBkCyoByBr02rAgoAsqA9BlQBBSBnCGgDChn0GvDioAioAxInwFFQBHIGQLKgHIGvTasCCgCyoD0GVAEFIGcIaAMKGfQa8OKgCKgDEifAUVAEcgZAsqAcga9NqwIKALKgPQZUAQUgZwhoAwoZ9Brw4qAIqAMSJ8BRUARyBkCyoByBr02rAgoAsqA9BlQBBSBnCGgDChn0GvDioAioAxInwFFQBHIGQLKgHIGvTasCCgCyoD0GVAEFIGcIaAMKGfQa8OKgCKgDEifAUVAEcgZAsqAcga9NqwIKALKgPQZUAQUgZwhoAwoZ9Brw4qAIqAMSJ8BRUARyBkCyoByBr02rAgoAsqA9BlQBBSBnCGgDChn0GvDioAioAxInwFFQBHIGQLKgHIGvTasCCgCyoD0GVAEFIGcIaAMKGfQa8OKgCKgDEifAUVAEcgZAsqAcga9NqwIKALKgPQZUAQUgZwhoAwoZ9Brw4qAIqAMSJ8BRUARyBkCyoByBn3yhocMGSLPPPNM8oIZLDFgwAB57bXXMthC8qp79+4t/fv3T15QSxQcAtULrseVqMPfffedTJs2LadXPGfOHFmxYkVO+/D1119LnTp1ctoHbTwzCKgElBlctVZFQBEIgYAyoBAgaRFFoDIhgMS7dOnSpJdMmVWrViUtl6iAMqBE6GieIlDJEFi3bp107txZ+vbtG/fKKdOlSxdp3769lJaWyk033SSRSCRu+UQZyoASoaN5ikAlQmDChAly7LHHyldffZXwqu+++25p1KiRfPvttzJjxgz58MMPZfDgwQnPiZepDCgeMpquCFQyBLp16ybXX3+9nHbaaQmvnJnRG2+8UWrWrCn77LOPdO/eXfr165fwnHiZOgsWDxmTvnLlypzOAC1ZssSOsWfPnp2gl5nNWr58ufz000+Syz5wH3755ZeM9IHZtcaNG2cWxIDaN2zYIGPHjpUmTZoE5JZNQi9To0YNqVu3btlMX8qWLVtk0qRJcuSRR/pyxM4mIr0E0ZQpU2SnnXaSjz/+OCjbpm3evFm+//57ad68ebTM3nvvLSNGjIgep7KjDCgOWoxpd999d2nZsmWcEplPXrNmjWzatEnGjx+f+cbitICScdu2bTJ8+PA4JTKfDAOsWrWqDBo0KO2NMYyYO3eu/ZKnvfIEFTJ06dixs9SssXuCUjuytmxZJ1WqVpdqVWvuSIyzt23bFtm85Sdp0aJFmRJdu3aVZ599tkw6CTCfZITimeehXr160aIwRe5ReUgZUBzUAJmHPpdf/jhd0+Q0InDEEUcIUh5DiWxSw4YNpaRkFzl4vwfT3uyWLWtl4ZKHrI4m3ZXzUYb4ONauXdvur169utxSpOqALIT6TxFQBMIgUKtWLdljjz1k3rx50eLse4dk0YwQO8qAQoCkRRSByo7AyJEjBct86PLLL5dHH31UkHyYMevTp49cfPHF5YJIGVC5YEvvSVs3b0lvhVqbIpBmBHr27CkDBw60td5xxx12gmbfffeVTp06yTXXXCMnnHBCuVpUHVC5YEvvSTMGDpBDyvkFSW9PtDZFQOS9994rA8PMmTOjaeiBmJRAd1a/fn2pXr38bKT8Z0a7ozsVRUCZT0UR1PNzgUCDBg0q3KwOwSoMYeYq+H7suMxVrjUrAnmAgEpAeXAT4nVhp913i5el6UWAQJUqEam10+a0XwnGgoVCKgHl8Z3aPYdGkHkMi3atiBBQBlREN1MvRREoNASUARXaHdP+KgJFhIAyoCK6mXopikChIaAMKIN3bOvWreK1n8hgU1q1IlCQCCgDyuBtq1KlivUYF7aJHxatlmGf7VhjE/Y8LacIFCoCOg2fwTvHavpdd901dAuNm9QTfkqKQGVBQCWgLNxpfPqMHj06Cy1pE4pAYSGgElAW7hee7I455pi4LU2ePFkOPfTQuPmaUZwImBG67FR7U9ovrpoaIqYd04KvkEgCGzduDLwOVhUrKQKVEQEdgmXprv/888/Wr3FQc173lkH5mqYIFCsCyoCydGdxPo6j8ESErqiigd4S1e/NY71Qttrytst+mKB3/nP0uDgRUAaUxfuK86ZEBFNAUsoGweyy1Zb/enIda97fHz3OHQLKgDKE/dq1a2X9+vUJayfsDgTjIarAuHHjhBAn2SDC0WSrLf/17L///v4kPa6kCCgDytCNJ45VPKWza9JJIMRxwr9uMgnJnadbRaBYEFAGlKE7SeSAICNErzK6TZs2tnXiMeVKGsnQ5QdWC0MmyGA8+uGHH+JlaXqRIqB2QFm+sbyEfh+6KIMXLlwoBx10UGBvGKoRh4kgiQzT2rdvL9WqVQssm6vEReMnSO0Gu8uuzZvH7QJr44gIOmrUKBuD3F8QU4XKRDgk26lO+p2HVduU/jozdV9UAkqC7CoThnbesM+TlIrN3mZetKn/2h4rm8ib7su+cc1aWTl6jJ19QhKYM2eODf38zYB3pcb3i2RAv7fsyxlbm9g4TATOW/7NN7LntkgM85ny5r/8xWOOJ/XuE3PsP0AhPH36dH9y0uMfJk6SH6dOkxGPPibLZ82W0kPbSv299kp4HoHsCINMyODRfd+StaZtaIXBaOGYsdKqVauE5yfLnDdsuKxepFJUMpwS5fOBXLBgQaIiNg8Vg/eHGqE8pAwoCWq7NG0q+3Q6MUmp2OyqRjo55NJLbCJSi4s9/t8pk2X/c8+xUgCKZ242s1Frm+8lrU89RWrUqS1ICX5iTRkSTwMzZNv76KNisttedmnMsf+gXY/u8vXXX9uYTkFmACyY5ZcqNT6snTQ65GA5/rZbpEHrVlLVREaoYvoZhpAAm3Y4Vmr+Gt538847y0YjPVWU9unUUeo1yX6c94r2O1/Ov//++6Wped6x2kfKdpMk/v7NmjXLRkXlg+J+nFseKqghGC8nL6yXiNTofYGI0tisWbMywxzvOWH3iQ9P4DW23ja853vz2IeQKA4++GB7zp577ik//vijTT/wwAOj9XEdEyZMiIY1+fzzz2WXXXax5/BlmT9/frRdrhEJiJk1GBf10dbO5sXdK4nUwdesdevWtl5wWTJ9hux50IG2P/yjLacMjyaanSce7y8dO7WUww47zA4PMZZctGiRYM/EFjzctcNg6Rt5yYi+M9RyYX0pz3W4Yen3RuKkPpgufU92fd72VpnytXbdTWrW3dmbbPf9112mQCVP+PLLL+Wll16yzyRho6+//nq5/fbb5bXXXiuDDEuHOnToIP/5z3+ieSUlJdH9VHbCfbJSqTGDZR955JEox3Wcd8aMGbbFESNGCEsaunTpIsQtGjJkSFp6gmhJnHi2iX4wBhgkP6aZKcs+L6lL56V1+2xZ/4XymS8OTAJmhcTEOd52aR/iISGPY1dPsot0Me5pm5d6m09URlEeNPQ59bSDpPmv+hzqcG2663HXRz9IWzJhoqycMzdZd2w9rj5vYcfgqc8R5VKhbVspv/0j4D/Pf93+/Mp+/O6778pFF11kGT4fvFtuuUX69+9v760fGxjQ4YcfLkye8OFwW3+5MMdVzMMTfMfCnJ3lMgB07LHHWu7smgYshjJIHA8++KANEfvOO+/YMnxNyS8P8SKwiNT7QpSnnnSeg+SBxDJm1Dq57PK26ay60tZ1xBFHyLPPPitss0lMOrRufbB0PenOtDe7bt0KGf7F4/aj5q/8pJNOkqefftqfLBdccIF07NhRbrzxRpvHpAdS77Jly8Qf/+u0006zZiPkEa6Zc1944QWpW7dumXqTJRTUEAwdxh//+EfLdb0i35QpUywTcvGpL7zwQrnnnnvkk08+kbPOOisZBgWT74Y4ixalphQvmAvUjqYFgerVa9hh7YABA8rUF49JMDT2rklkWAxhIOtnQBx37txZ/vCHPwgjkB49egjhmv/xj3+UaS9ZQsEwIDjy3LlzhWEYwy1E9gceeEBuuOEGqy/x29GgO0ACSkSDBg2yw5qgMkHDhKByuUg78cTUlOK56GOhtImilRentLQ0sMsMQ9GHFBJVqVLVfqRTsThHbcE75sjtuwkUl862d+/e0UN0hNddd508+eST0bRUdgqGAfGgICLeeuut8vbbbwvcvXv37oJid/HixVaB671wuDncOxExdg0yFuQcGJDTSySqI9N52P0ccMAB9otGnxgx55sNUKYxyGT9YIlUEO85iCcxpKNP5htq9Cfpt9mpWjX1KXE+2EzgOGIfY1qW7HgJXSdDuCuuuCIqGfGelNelTMEwIJSzQ4cOjWLRrVs3O3YfPHiwZUIsZfASx0Hc21uG8TC/IEL38+c//zkoK6tp2MygfD7uuOPstCiGfMyIKaUHAYYTvEzZ1gGlp/fpq4Vh1Pnnny9XXXWVNDdSHyONSy7ZbkpCKyNHjrSzy4w0mLHFtu2xxx6zM7Ivv/yy/O53vytXZwpmFgxbFqYJ/QTnhXszbe0lOHg+v6ibNjFjVnaWhy+Mf/YH5sOwE5MArgnmyCxUoRHGl+Uxeiy06yzE/h511FFy9dVX29ktZkUxzXjooYeil9KzZ08ZOHCgPYY58T62aNHCztrCvC+//PJo2VR2CkYCQhzs1auXneLmhRw+fLiMHTtWmD5EfGY68MUXX5Tf/va3dozKC4r0kK80Yfwi86XZVUobx84ccGMZZjGERIJjJs4Zfh1yyCH2chiWoZBOxUYmH3DYbbfdhJ9SfiKATvWuu+6yhrL169eP6aQ3vBQqgY8++sha9NesWbPcM800UDASEEoypktROiMFIC6+/vrrdhzKOP6VV16Ru+++2yoT4dAYUKHjyVc65ti9LPOZNm1azAJNzAlq165vGQ9SD4RCEF0EY+11P/0sk4bMlcmfDQ200cin62UYHGR9nU991L7EIoDZip/5xJbYcYThbHnNXFwtBSMB0WHGqfzwqIdE5FUSo6BmKpE8DPoKhWA4fvpq+npp3mJzdMEmQy6uFUX8/E+HynV/7iazh3zsPy3vjpHi2rVrl3f90g7lDwIFIwF5IcNU3Mt8XB5phcJ81q3bJFs2x+qAOCb91DNamVmFNmah6s/y+KMfS80azeS7+Rtkp1r1pZ75Qg0Y+L6MWVH+leNr15q2t8S27TDMxnbQoE+y0Yy2UQAIFCQDKgBck3bxq5nLZMXKWI+JP/+8QWZMW2qGZL8I+dWq7mzE4d2NRWsDOenkg2X0qO/l4IsvMorCTrJ1U4ukbcQrMH3aElm9KjhCR7xz0plercre6axO6ypgBApqCFbAOJfp+uFH7Fi4icsMVq032KO2/VF4zz23W6Je0/Pw6LlnnLXdgdm+LXYTfuWlo49pVt5T03Le6We2Tks9hV5JVeMPqHad2MXV6bimqtXSX2c6+hVUh0pAQahkOQ3mk27aYuyFvhv5Zbqr1foUgbQioAworXDmT2VVjXuEn0uqx/h0wQYnkUvU/Om99qSyIKBDsCK90zhFa2uMy7wU5PJ1+bL1snDBz9KufWNvUd1XBLKCQEoS0KefflrGIVhWeqmNhEagT+/JMWV7v544GOKaNRvNWrq1MefogSKQLQRSkoDOPfdc69Tq9NNPF/bZepfwZ6vT2k58BLr3ONRmYi2NIWaPKxLb4eyz767CT0kRyAUCKUlArK/6+9//btcqsQQfY8BTTz1Vnn/++ajj9VxcRGVvkzVis2fPjsKAy1M+DLrsIQqJ7uQpAikxIBgOK4dx1bh8+XJhJTo+R2677TbrzJr1IUrZQ4AVyXhJZJmKl9kQ5ofFhP4wNwvHjpN1S5fFdHD8+PExx3qgCGQTgZSGYK5jhJrBNYb7sVaJIHvel8CV1W3mEOCDAHm9Q3LMIlavK5JlS9dJnZ1rSKODD5J33hsu3S49nWKW/N7uXHo6t/Pm/WTW7yUe5i1csEoaN6lrfB2l9E1MZzezXleVqsYOqPbmtLdbtWr660x7J3+tMCUGxErzjz/+2EZJaNSokXUA/+ijj9otEReUsouAn/HEa33q1Jlmke7usnXbOjN8ji216PufZfEPC4TFsZmixYvWJGVAS35cK41KdzYMKFO90HrzEYGUGFDfvn2tWI8TL3RA+IVVqafit3XOtyulRcvdrI0OQ6qgBaphW8EA8etBH8lBF10gC0aNlvHGT9K2kvpSbdpY2WPfvaTlxhUyxyxoXWaCHDZo2UL2Ngt31y391lSfOQZ0bIcddROKiAggfk+Dhx/ZJOwlarkiQiAleZc4Teh/mhuPaYTtYAhAeA7iBxEjCG99SqkjsHz59jVhMPPyMp+B78y0DVc3i1VhPtCmhnvI0R1PNC5LmkjbK66Rn3drK3t0Ok3W77mHrG3TSkYtriF19motbbp2tuWz8a++cSdSYlb3e2nGO9udp48ePdqbrPuVAIGUGBAvCKFx/vnPf1oPhMy+XHrppfLGG2/IKaecIjh5V0qMAH6qCa3jpaOObmoPU/UYiLT0xRdf2HNZX4XyGX0cM2Lr1xuXHuZD8Y2RdBruWV2GDR8sGzbNMxJrLfvhwLXmYe0byoSJ2V2u0fyE46Wm8SODaxHn1bHNmWfYa+BjplS5EEhpCOagwYkWuiCkHl4AvPYRCsd57HPldFsWASKixtPdwOBTGdLCyI4//njL+Nu2bStjxoyx94BYTYRLwVarU6dOdih2jPE79LWJEoK7V/wL0Y/NWzbZCJdle1nxFD5OuEbxX08186xAxHJzrmeR2qB4uNhM/VeUCKQkAV177bV2dgVG89RTT1l/sO+9956dkidSBTNhSokR4KV0MZf8JceMniYfDZpk8fS6wGQ6PSjCB+4w8YGELda3386VrZtbW2+R6FfOOOMMy3h+mjdf5m9qJAtXmhj0a3YxkusyU/Zbex5MYvQrr9r2/H0JcwwDQQoLIvQ88SJNUB5m43w6EaQPclt7oP8qBQIpSUC8FMyEnXPOOTZmeKVAqBwXyYuJPgPf1alQteobpF79DdbNrHd6HB/RSC1+ckMYXubOnTvabJzaE4KZtF92300mTZ1i/UfPmTPHDr3Q4zE8m2+U0wzD9jZhoRmmeduzFYX85/rgLx4vdNDEiRNtKGjv9bg63NZflx5nDwEkU4bHYfyN432UjyCuWctLKTGgUaNG2XbQNeAQnhcDaYg47Uo7EIABEELaTwyN/AEUKYNjffxcL1ksUsPcUD8hMQVJTZwDI0FyoD2GYJhHuKEN92ft2rX2/iz5cats27pBdtt9Z6sbIpYaAQ4HDPhQ6u/SyN9kqGOuM+h6vCfPm/uT7NGwjun/9qFX3Z33kpLqOxnD1R3O+LkOaO3q7c8RC2S3bN1mrmW7TyRvfcW0b4RX4w8o/dFNqlQt+7EKg9v9999vVzqgUuE5+ve//x3oYRSJ/Oyzz7bBElasWCFEzPjb3/4WlWjDtOXKpDQE4+uK1TNfy6OPPlqOMV9PxH0efrim0g4E3PBiR0r8PaJLHnrooUZCKZXWbVJz1kU76IGQOJC4iA7imN9+++1ndTxEMTi+wwlmyNxKjjv2BNsW8b0595SuXa1E4u0djCtzZN46pbxDgNhzhL3CTAJpmdlYZreDiOAPMCiG8ugaP/zwQ7sqIqhssrQq5mEL/bQRqA9Oh8KZmOsECySMzMMPPywwJyIgIJIVAzFE4EvgHSoUw3Ulu4bFkybLz0ZSa3x4e6li/uo1LW77HGJaEW0l24EJkVqJ6puJsM9MTmCzx3KpsIRZDazg8ccft6fgO4qwVkg7/o8pUu9bb71lhRAK33vvvTaqKrPhqVLoIRidQ/FMR++7775oO3y5uXkoHRkCaNzyKDQFucMs1f7nniO/GHsdjBqVCg8BhAEYx5/+9KcynYfpEVnGTyw079ixYzQZJgMjY4jl1Q9S9/dmNrV58+YxZV0IqWhiyJ3QQzAWPqJPuPLKK8tUTYREhgHohdJF6DFQjgYRYMVTWCbKC6pL02IRaHjgATZhs1mTtaG6rouIRacwjpBY0M8xC+n/BekSuSpCWnld67hy/tlXFM+8m96yqGH85cIiFVoCIhQO+gXGezfeeGNM/XQK5sMMWbqICI1wVWJSO+KY1fgQnBkxkCloKFGeLaD/QiHwwvOfSYfjG8leZm1fdfMQKxUeAryn+IKKp8MJuiI8KmDE6sjtexc1k0c5iHw3+UQASn85WyjEv9BPGNO6WD2j78H2h5kwjNkwSrzmmmvsLE1Xo9CsKMFJiVHtxqKuPpZ5kE77c+fOlZdfflkuu+wyu/wjUZ47X7fxEWB2Drcc/Fq0jNgJhSXfzpEfps+If1LIHOyEmPZXym8EmHZn9OCIfZZa1alTxyXZLZFQSfeX9Q7JYk5IchCaAVEPCmiC2J933nk2fCudYRp+ypQpVhpx7iGStJkwG8kHfdOTTz4ZU442sFG4+OKLbTqKcKSyTz75xLYfLy+mEj0IRICHzInq3N/27dtL4/3aSLN2270rctLnn39e5twwa//4SvJFVspvBNAL9evXT1A+o2ohvPkll1wS7TQjET5U0OWXXy54wUDywZi1T58+0fcyekLInZSeDMzqsVmZPHmynX7D6RUzYeh/mP1C6+5VWIXsQ0wxJB/ERy7KS9i7+G1O4NooxPjCxsvz1uHfZ2HtsGHD/Mn2mHGus6cJLFBEidyzZPctaHKBjwIMKxElsoZOdF628rCH4mXjYxZE6DeZeMkImQ9t9XXplw6rlWPygPvICIP1eNwzJpdY8+kIWx9ULL169ZI77rhDLrjgAhO9d1/7cfn9738vJ5xwgiua0jYUA+JLx5ovlE3Y/tA5fo6YfmeZBlp3FqtWhGA+QcSD4re4RBHGkA3pJ15eUF0urUkTs0rcrKEKIpiPf/oxqFwxpzELgpQbDwfyC524vlatWsXM6nivqbS01HtY1PsPPPCAMALhfa9fv37MtXqXBqEHGj58uBU4KFcRCTcpA0LEwsDNablxwcq6L6bzmJLDNgipBQkok07JuGhEPi855RdGePHyvOX9+1xXvOUS2P/4le3+84v9mFlIQvnEe8C807aFigVfe77m2bYDyle8YMj8wlAyqTlMHUl1QMw6Ifm89tprdgYMaYMXE9cRKJ0ZC+KgDItIrKMzRQy3GIZ5CUUYZvyJ8rzldT81BJByt5iVAr+s3xx4Ih+geEPYwBM0URHwIZBUAkIpxRoRN/3N+bh56NatmzXbfuWVV+Sqq67yVZv+ww4dOtgv8YsvvmjHor1797a2QFhrYrHMVzooL109wZn7GrPcZGczA7DeMN+GB+yfrqrzup7Fi9fIhl+2yP4HbPc/TWd5JpBIkTz97jby+mK0c3mHQEIGxPouxvm4XnXE0AsjQB5Cpm2xgM4G8bDD7JgFu+eee+yDj1TmdEaJ8tLRvxpGCtzFhDrGd031WsWx3CQMLs6ZPGN+N+TC5gMxfb2ZdIguJF2zSaqXVDXpCR+pME1qmUqEQMKnheEWxBDMkVNOobDKJPPp3r278PMSLwAWmxg+4lfHS4nyvOXKu1+yUy3hB5XEUZSXt253HsZdy5Yts7MLLs27xfgSBSHK82yTYz6066Se76ZNlzmRbXLmmWea4fFPRiqqLaWNdzwr2e6jtld4CCRkQIkux335EpXJRB4zMn7m49pJlOfK5PO2atUSo8yP71uFD4GzPs3WdSD5IH2iZ8M+a9LEWVJ/1xJZs3qbnHJqVxnfd6LtykEHx34QUukfw7zSUmVcqWBWLGXLzYBYa6KUXgQ2bojI0iUbjYQTXC+6rmyTV/Kh7Tmzt5oFx/vK58PnGWZZXXpceaSdDcUrQnkd6n81Y1mlZEBVtkWkJANW4iXlsAPK9nPl2gvFgNC7uKk5557id7/7XcyCNCr861//an0Qu8p1uwOBWbNmWbzwoxKPdtt9J+MwLNgOKt452U7vcnIL22SnzvvaLauuMUjFborhcaLri9fXzidtrytevqYXLwIJGRBMx6uAdjAEpZGnUpFDqOw2rL5s/oiRUtr2EKlpjCwLgbC/whp9p1p7y9Sps8vFgArhOrWPmUEgIQPCPP2zzz7LTMtaayACpcb2pqR2fktB3o4jAeGqZeuWRbLNKKS9xGwp64rcxIU3z7uP5AQjC8ukvefqfmEjkJABFfalFWbva9YtLD/IrAXkF0QYKmJBX8NYlS/76mvZu8NxQcWs1FSeoVtgZZpYUAioJrmgbldhdBapBxsxbLSYLa1l1gs1bn+YfPTRR9Z+zF2Fs6KeO2elS9JtJUNAGVAR33Cci6fiFzhdUOBNzxvltKqZxsd2ilhlTOUzbIMImggtXbLOWtXjGF2pciGgQ7Aivt+4KIm3kj2bl82iVn649CBSB8MyfMsgIbFlDeH48d/FeFjIZv+0rdwhoAwod9hnvOV4q9jDNIxiGD9L+HxJlTgPswMWs7JIGc+ZxJFyxOQGP7wq4EeGYIWs9SPunAsp5MoW9dYo7TNiB/TrCoZCwE4ZUCHcJV8fv5q5TDZu2CKHHpY5XzUwCIZLqRJeEjDfwI0H0/NIPDAgJCD0QRhTvvHaOGPEWE3atT/CxqAiLhozaXhiVKpcCKgOqADvNyvTM8l8gASbLpZgpEqzZ8+2eiekr3Hjxtk6mGLHUtoFGOjUpVT2ar7JTLs3t9PvGLfiZbM8DC/V/mn5/EJAGVB+3Y+Y3vTpPTnmuBAOcOzVv+9238G4bYFYu0cgS7eso2nTpjaqwovPfRGVenCr4qztC+E6tY/pQUAZUHpwzEgt3XvscHtb0QZYVOqn2UM+lnUpRM/0nx90jOR08imtbJbXMp59d4xiHLcuv+l2iFWSM/uFBOSm5YPqTTVtjdFhzflUjWhTxS3b5ZUBZRtxX3tDP50ri3/YEY/Jlx14iA5o8sTFgXnxEp304c1vdeopUsc4pE8H4SoE+x/cibRstX1lu/NgiQsRwjfNn7dMhn021zY3acJaw3xqWWf4SERISeV1bB7U/7pmzV2Lk7oEZWlaigjgeTReIFBXFXo+fIe5H/c8DCkDCoNSBsuwENP50IERDR+6IzZTvGazoQOK17Y/fZvR30BINfyQctDlsDh11c+bZPBH38hbfafY9ClTR0mDhtttgM48u43xbbRKtjs7L5++yd8XPU4vAgT7ZBa0S5cu1gPmkCFD4jbAEBpXMe7Xrl27uGW9GcqAvGjkeB9G1LHzPjnuRfjmt5qlFl+//4E9ASdlxBfDVSvKZ4ZU+7YolS3bZkmNWnPtkOu777YYx2XzbRSThQsXWhsgjCU/HzbPnkvASaX8QAAJJl4gUH8PkX74kHBvMcHgR6ScMKQMKAxKFSxDSKNMUFCwwEy04+r0X0fESDwrG+7wFe3K4S2BqXUcqJ1++uk29NHUqVON58R2vy44RVKqbm2ByD/muFLp32+qOT31WTfXZiFuqxhJscQMW9L9qx5y+JMIs0SBQP3nYeuF2QaGr8x+YmAadkJB7YD8aGbgOKxuY9WqDbLkx7XSuk04vQyWxd+P+680PfKIDPS6bJVB14Hb3gkTJtjhV93Va6RVxxNjTmT6HReyrIifNHGmkXQayvJlG2TBd5ulZes6Nsw2Yv4VVzWOGxwwpkI9SIoAw18WAgctbUFCxTYrGSHNhA32ibTL0JsApUi/1P/qq6/aj1CydpQBJUOogvmIp2E9GZaUVJOdd66ZUoss9AxLPJTY9rjZqLDnxSvH1441XyieoVrVS2KKMvOG8huHZR988IE037ulEdNnGiV1U6lTd63RFdUSbICwgAYj9k8++eSYOvQgdQQ2GwbEMOj2228vczIfkYceeqhMuj8hUSBQf1l0fsTXe+qpp2zWnXfeacO3Yw1PvMBEpAwoEToVzGPmgKGHd2Fmoipr1y4xSrzYlzhRefIatN4+5Z2sHPnoW5htSme4ZCLS+qPSur7AfCCkH7cUo0rVaZbZ8GC6JRkwKNaDjRkzxpZ3/8aMWihHH9vMHeo2JAI1zYeBe+IMP8OcRoRg7gN0ww03CJFPwgb7RFfEz9F9991nJSAi5ySzblcG5FDLwNZJCBmoulxVhhG9y1VxCicF+Y12AS3d1lW3S/3KpRNy152L7bPPPhudaicAwYIFC4y0Oj+mKy4QaEyiOXj//fftR80N0ZkNdYEM/GX9x1X9CflyzDiW9UNeQkR3dgZu6zffD2Oz4K1T9/MXgTVrv8/fzhVZzxhCoVPkx5o9byBQ3rE33ngjGgiUS0e6wpMBhKR03XXXWet2VA6PPfaYrWcPE8QzGeUtA7rrrrvkmmuuien/I488ErUzcPYGaOChVGwWYirVg7xBgK8uCs1+/frJO++8o/Hac3hnkGAI9nn33XebiCWlwrvnDQTas2dPGThwoO3hpZdean3HI902a9ZM0P0999xzoXqfd0MwfMXcfPPN8uabbwrGTV7i4XziiSfk+uuvjyYz3ee1WSCCBw/vZZddZldjh50OjFaoOzlDgHuFAzVmag444AA7s5azzmjDdgIhXiDQ7Qak20GCWT3zzDNWCY0eqUEK1vV5JwEh+SDyPfnkk2UeAYyb0BM4WwPsDRhvpmKzUKZSTcgbBFBKn3TSSXYmLBfRX7MNhLUDWm/sgNL9M7ZF6SLer3iBQP1t8F6mwnw4P+8koMcff9waMvXp0yfm+ghbjKUsoiDDLYAhPDQae5RlYW0WvJW+/vrrEs+8HB0UP6XiRmDRokXCRw+pK4jatGkjf/nLX4KyNC0NCOQdA0KqCaIlS5ZYkfDWW2+1nvQGDBhgY8ezqjoVmwVv3YxZ49kpwHzw2KdU3AjgvxrFa4sWLQIvNIwiNfBETQyFQN4xoHi9JvTL0KFDo9ndunUTpg4HDx5s1xmFtVmIVmB2WC7AL4iYcevRo0dQlqYVEQLYy3Tt2lUV3jm6p3mnA4qHAyb9L730UplszPixWwhrs1CmgiJKWDR+giz/1XRhcp9/FdGV7biUyW8mv645n3wma43ErJT/CBQMA0IU7tWrV3R9C1N9Y8eOlfPPPz+pzUL+34b09LDJ4e2lgdFZQId2vzQ9leZZLYdelvy6WpzcRXY2Ft9K+Y9AwQzBUBIy5ELpzHBr1apVghLZad2xWWAK/p577hFcQ3htFvL/NmgPFYHKiUDeMqDu3btbJbP3tqCT4bd06VJBImImzBHrjuLZLLgyulUEFIH8QiBvGVAimLAXCaJUbBaCztc0RSCrCOAPyNgApZtKjNeDQqGC0QEVCqDaT0VAEQiPgDKg8FhpyTxGIJ0RNfL4Mouua8qA8uCWTn9nQB70orC70KlTp8K+gErae2VAeXDj9zvzjDzohXZBEcg+AsqAso95mRarm1Xg6aDFkybLitnfpqOqgq5j7tDhxhBxaeA1/DRvvvWjHZipiVlHoCBnwbKOUoE02KjtIQXS08x2s/mJx0uVqsHf1vrN95Zd9lI3r5m9A+FrVwYUHqu8Lxnvpcv7jqe5g1WNf5p4hKlGlQT58c7T9MwgoAwoM7hqrYpAUgSqRERqbNiYtFyqBTaZYAiFQsFyaqH0Pkv99Pudrmiz1Od+/rrS3Za//mI+VuwK7+4qA0pyz1Ybh1XffTEiSanUsie8/KrMHjxEpvZ9K+bE1T8slnnDPo9J04PwCMwb/oWsXvRD+BO0ZM4R0CFYkltQz0T15JdOOvzaqwOrq9e4VPgplQ+BfTvFRmUtXy16VjYRUAkom2hrW4pAASIQFCIr6DII001kk1RIGVAqaGlZRaASIhAUIssPw/333y9NmzaVY445xkZDxYVyGFIGFAYlLaMIVEIECJFFyGUCRSSiL7/80nornTBhgg3/ja/1oLj0QXUoAwpCRdMUAUXARgthZjEoRJYXnnfffVcuuugi6xqZ2G633HKL9O/f3870essF7asSOggVk1bVWNIy9o0XriXOaWlNZkyNc3yiwOaKCPrIQxgvWkk2+kUYbgwIMxFkcuXKlaHjXqXzWnGe9/PmTXLz1Imhqt1onsVqBoPqHid88U7cZu7XL6Y8nkH9dMYZZ0jv3r39yYHH8UJk+QsTDh2HgI4IkcU9W7FiRdRjqcvzb5UB+RH59ZgHfv369fYXp0jGk3ErO23atKQicCY78vTTTwui+L333pvJZhLW/eCDD0qdOnWsT/CEBcuRWaNGDalbt245zqzYKe3atZNv58wRonKEoXXr1tmAnPHCSHnr4MNJvDN/rDzKcL1hKexHB2Zar169aLWEOoJ4bpzL5Gimb0cZkA8Q7yE3IOxN8J6Xrn1uJF/9XEphvPhIQbnsAxIgv1z2IV331NVDFFEiuoSlVK891Xhmbdu2FcIqQ/hdD6vDoTx9I3CoI7ffuHFjlxR3qwwoLjSaoQhUHgQI+LDl1yUchLlKhSjPMMwR+zBAPl7JSBlQMoQ0XxGoBAgcd9xxKV3lyJEjpVmzZnaYR6AIwmNdddVV0rx5cxs+/ZJLLglVn86ChYJJCykCioAXgZ49e8rAgQNt0lFHHWWn6w8//HBp1aqVHco99NBD3uJx91UCiguNZigCigAIBIXImjlzZgw4DzzwgJ22R19Yv379mLxEB8qAEqGjeYqAIhAaASZMUjWVUAYUGt7sF2zdurWEmXbNZM8OOuigmBmOTLYVr26mrHONQ7y+aXrFEKhijMyMWyQlRUARUASyj4AqobOPubaoCCgCvyKgDEgfBUVAEcgZAsqAcga9NqwIKALKgPQZUAQUgZwhoAwoZ9Brw4qAIqAMKE+egU2bNlkXBrgx4IdBl59YY+PW6/jzKnr87bffyubNm8tUs3TpUlm1alWZdBIS5QWekCAxnttPh4fb+q8/nX1I0D3NyhACyoAyBGyq1R555JF2xbdb+Y3ti6MRI0bYldNdunSxK4+HDBnistKyHTNmjGDvs2zZsmh9uH+gvfbt20tpaancdNNNUQdTifKiFaS4E+T2c9asWTGYgA2uP6FM9CHFLmvxdCCAHZBSbhEwjsciJSUlkfnz50eMDyL7M1982ym2LVu2jPTr188ev/322xHj/iDi8ivScyN1RJ5//nlbn3mWIsaHTLS6Xr16RS699NKIkcQic+fOjbRo0SLy0Ucf2fxEedEKQu4Yh2ARs4jRXr9ZEBlz1ltvvRXp0KFDFBOwMVJa2vsQ06geZBUBlYDSwcUrWMeMGTOkYcOGdmUxfmLwQeRM2qdMmSJ4Rrz44ottKxdeeKEt+8knn1SwVZGhQ4fKiy++KIMGDSpT14ABA+TGG2+0Fsj77LOPXQ9kmKAtlyivTEVJEpB8zBMf6PZz8uTJwgJH8HC4sIXS2YckXdTsDCKgDCiD4IatmhcNF7DHH3+84IQM51ATJ2531WmkojKe7fC/8v3334etPm45XDDgSJyX3Evogqgf1wqO8K5HWqI8VzaVLW4/X3311UDPgJMmTZJx48YJS1LAxUhkdllIuvuQSn+1bHoRUAaUXjzLVRsSAMyAr/rChQvliCOOkPPOO89KPosXLy7zcuL+EneXFSUnZfnrQbGLUtjrZhO3pbSZKM9fT5jjRB4nced57rnnWre0o0ePFqTBO+64I+19CNNPLZMZBJQBZQbXlGol9Enfvn3t0Iqh2H333WeljenTp1ul8+rVq2Pq4ziMu8uYk1I4cO4/nWtNTnVtJspLoYlQRXGefuutt9ph4GGHHSbXXXed/Pvf/466Zg3qX6iKtVDeIKAMKA9uxfvvvy9ffPFFtCc4xK9WrZoNc8Jwi2GYl5iORy+TKUIywqUm7ThinyFZojxXNh1bhlkMz5YvXx6tDlzwo5ytPkQb1p2MIaAMKGPQhq8Y6YKvO1907IEee+wxOfHEEy0TMLNAVgGLspih2htvvGFtgZi2zyRdfvnl8uijj1rJ56uvvpI+ffpEFeGJ8tLVJzMrKJ9//rk8/PDD9roZir788stZ7UO6rkXrSYBAVufctLFABIxxXcREIogYRW/EDMEixgYoMnv27GjZYcOG2fQ999wzsv/++0eMtBTNS8eOYXq4ZImZhjeSR8QwQTtFT7vG4120qUR50UIp7rz55psR/zS8mR2MnH766REj7UWMDVDk2muvtWYBVJ2JPqTYZS2eBgTUH1AC5pztLKx8CY0SFEvJ3GurfDXMIKvdYgiEi003/e1tPFGet1xF97HExiFZkNI8W32o6DXo+cEIKAMKxkVTFQFFIAsIqA4oCyBrE4qAIhCMgDKgYFw0VRFQBLKAgDKgLICsTSgCikAwAsqAgnHRVEVAEcgCAsqAsgCyNqEIKALBCCgDCsZFUxUBRSALCCgDygLI2oQioAgEI6AMKBgXTVUEFIEsIKAMKAsgaxOKgCIQjIAyoGBcNFURUASygIAyoCyArE0oAopAMALKgIJx0VRFQBHIAgLKgLIAciaa+O6772xomkzUrXUqAtlCQBlQtpBOQzs46Dr//POtozK8E+KoHV/SY8eOTal2PDDiXfDHH39M6TwtrAikGwFlQOlGNEP1jRw5UoxzLjGxsayXwGnTpskLL7xgo6jClPAjpKQIFBoC24MsFVqvK1l/8Ql9xhln2GgZOGUnhA9ENNNTTjlFDjjgALn55puty9JKBo1eboEjoBJQAdxAAgjiN/r111+PMh/XbeJ14a8ZBuVo69atNtAfjIlwOviPfvfdd112me3dd98tv/3tb2PSaZN4YS78j3HJKn/+859tDK9DDjnERuUgcCGeGp955hnZb7/9LEP829/+Fq2HkM9HHXWUEHceRolnRWKeJepL9GTdqRQIqARUALd5/PjxNj47zCaIiJ3lpb/85S/yyCOPyJ/+9CcrNX344YdWd/Taa6/JFVdc4S1q94l4gVLbSwzpCFqIm1iIfBOa2cYKg/EwBPzHP/4hOKwnYOH1118vM2fOlD/+8Y/SqVMnOfTQQwVXqv/9738t80FXhbP9f/7zn3LBBRfInDlzMhrZw3stup/HCKTBr7RWkWEETKBC6yA+TDMmsKGNs/7Xv/41pjhx3hs1ahTBAf17771nndCbSBO2TPfu3W0Mdu8JJkiiLWMCEdrka665xh4bJhMthrN482hHjIQTTWvWrFnUgf2QIUNsvmGG0fwFCxbYNKO/iqbpTuVFQIdgefxxcF0jeijK5zBEmGdiavXo0SOmOKF0mPVC8igvETTRROWInn7wwQfbsMktWrSIpjVp0kRMRI/oMTtIRI4Mg7LO5b1BBV2ebisfAsqACuCeozf55ptv4vaUl3nDhg02n+EUU+z+yKlNmza1+YsWLYpbT7IMmIuXCJ6IOYCXSPMTQQ69VKNGDUFPpaQIKAMqgGcABoQSetasWYG9/d///V/ZbbfdrIRD6GQj0JeZll+xYoU9l8iiQYTU5KWVK1d6D+1+EHMpUyggAYaopAgEIaAMKAiVPEs788wzxehvrALZzygY7hAttX379rYMM1/Q8OHD7db94xjDRb/EQj7pfoaDcllJEcg0AsqAMo1wGuonGOFbb70lzIadffbZ8q9//UvQ9dx///12homAfcxIQcw+nXrqqXLLLbcI0+AbN26UDz74wMZZZ6YqSBoxkVit3ubvf/+7laKY1me2SkkRyDQCyoAyjXCa6j/hhBOkX79+NkLo73//e4Fp3HvvvVbXg80OwzRHvXv3tjY8TH2jwMbG53/+53/k//7v/1yRmC0K6osvvlgYypWWlgo2P8RhV1IEMo2ARkbNNMIZqH/btm12NothGYaG8eiXX36xEo2ZLo9XJCYdZTa6Jr+yOaaQHigCaURAGVAawdSqFAFFIDUEdAiWGl5aWhFQBNKIgDKgNIKpVSkCikBqCCgDSg0vLa0IKAJpREAZUBrB1KoUAUUgNQSUAaWGl5ZWBBSBNCKgDCiNYGpV5UeA5SMsuDWr9eNWEnb9GC5EqMu5EolbYQUzsEqnnUT9SpTnbZ563Ho+b3qx71cqBsRKbiyB3a+kpERYnd2lS5cyfpWnTJkSLYfdTaFQofYbP0J16tQp4xgN3F966SVp1aqVNcJkrRs+jZYtWxZ4S2BkJ510kq0Ly+5M0dq1awVvAPR58ODBMc3gBwnDT7wHsPAWOyyvo7aYwuYAh27U07lzZ39W8R9XJk8kxmuf9UVTs2bNiFn/FDEPhz02dzli3JxGzIMehcMsdYjmma9YND3fdwqx32aZSRRrY5UdA/HAgQOjecba29437tfJJ58cU84dPPfcc9HyTzzxhEtO69ZIVpFLLrkk2s6gQYNi6u/WrZvN4zkza/Qi5oNnj1988cWYchwYd7vRazrmmGPK5Bd7AiunKw05BuR1kIUzrdNOO80+IObrGjGLMi0eMJ1169bZXyEBVEj9xiEajtJgKO7nZ0Au3yw/sbfBLL6NljXuYmNuDc7OjGV4ND8TDMhEJokYX9zRNui3lwHBnMzaPJtPWeihhx6yx0FMs2vXrtG6KiMDqlRDMPOwlCGcaeFrmRXhuKxgoSeE4y7WX/FjCMZYHh/J/PC5gw/mXXfdVTp06CDTp0+3rkkRoUkzD1oZ/z2EzjnxxBNll112sb6TWW/lHdqdc845tm7qYtEoyyEQ3Vlw6i1HPm0j3teuXdv6YvaK9/5+uwvGxeptt91mV83TR67LP3QI24c333zTLnoFM1fXl19+6ZqyW9afgRXr1+IRi2TB+7DDDhPzIgYWo36IBbkQx9WrV7dr3Fjn5qXrrrtOGBrFc13ryoLnRRddZPt32WWXuWS5/fbbbRo4xNMfcd9mzJhhh4oMByHvAl8CBtSrV8+muz47f0i4TPHSq6++Kv/5z38CPRR4yxX1fswnpMgPgiQgd8m4PTU3OmJ0ETbJP5Thy0Y+P1ybGgYQMeN2e2ycf0XMwxVp0KCBHcpRhrYcGeYTHe5RjuEeZa6++mpXJGL89Ni0li1b2i8o9bv2zOJSW86s04qYxaI2nfqPPvroiHkZ7bHx12zL+PtNolFwWperrj7j1yda97PPPmvP41+YPtAO9fCV54tNfzkGA8PkonUZxmzTn3rqqWiaf8esuo8gpYCtWQhry/slILBjuAy2d955Z8QwTlvOMOmY6oxLEptuGF/kvPPOs/uJJCCzgDc6NOrbt28EacUNlYwP7Zi6vQfGH3bkiy++sElcM9fuL298ctt0w4AjxpF/xHxMrJtcXNQ6+uGHHyLGSX/EOIqL4J6WeiqjBFTph2DugXAPLVvI/yJ7GdBvfvObCEMd4x7DPjg8PGeddZZ9kXiwOea3fPlyW5dxSWqPzdc2YhaIRoyvHcuQYEQMKSD38h944IERo8S0dTmmiD9m6LPPPrP1GIWszSeNl/jKK6+MvP322xyW6TdpvLj0B+YFA8HPc8+ePW0aQxbnGzpMH3jxqctIC1Rt6YYbboj06tUrYiQDlxR5+umnbZp7WaMZcXbiMSCKG9cgtk2HK8wX39aOjKtZ+wEwEocdQrt7mYgBca5RFNt6YRBt2rSx+0bB7apNuo3HgDjRO7Si3yZAQEx9JpCAbQ//3EYKtPvKgGIgKr6DRBKQEbvtQ2Ccf9kLT8SAzNDBluElcC/FO++8Y9NgMC5t6tSpllGY2TabxpfWRJCwv+OPP96mOQnEvfxm5iYK/K233mrLOKZo3LJG6+bhhzGZEDdWwnEn+ftNugmNY8+DSThCf+IkIV4AKEwfHnzwwWgfULDeddddERP5wlVb7m08BvTxxx9HzFDTShBIR07/YmYuo0zowgsvtH1y1xGWAZnV/xEzXIteD5j69UqJLigeA/rDH/5g64ThI5GZYaOVrpw06JTuMCGoMjOgSq8DMszCkhGJ7da8hL+mxN/gBgNiGt8RfnQgM/PhkqzuBh/MzouhmR0RfDPzGzFihC1npI9oeXbMUCN67HQc6J+g1q1bCzG8cI1Kf/HZY1422WuvvcS8qNHz/DtMzUNe5/DE6MJ5GeR3Ip+oD+blEvOltucRtsdE37Chf8xwMO7UuC1czn+EF8JG5sknn7S6uokTJ1o9kJEGrcM1tob5W9yWLFki5iW3cchozkhfQiiieIQOC72Yo6uuusrGLnPH5dkaqVeY/kcXNGnSJDEzX1bPZfiMjWjLs0BYI8gMX21/nS6OZ4H+Gwm1PE0X5DkaF8zcNoLvORekRkpKeiPxQOgnxyz86U4hSTovk5/B8RB6ycvUeIj9hFKaF8UMuSzT4SXjoTfDLOsd0V+eY9pAeU3cLjNUtEV4EZyPafMljzktUR/wPzRq1CjBxStKZKPXsNihZH/llVesIjemsgoejBs3ztbgmCV9wxkbTtjw+OgUvWBgJLyY1szwRowUKmaIGpPuDmBsZpjmDsUMG61yOZkSO3pCwA79hdmAqesbgSEhF5XEMRjipHmJCLg33XSTGOnYTjJ484p1v+wTXqxXGnBdPCgE1XOzJ0gx/nA2AaellISkgbEjRHvMvhCY75NPPrFMwcugklWM1GSGXfZLypebr7+TpJAMcCYWREaXZJNNrC87S8QB0UlxQMYMjpNogs71p/F15xrAjZfXBSOk3LBhw6LFzVBQjGJXKhKFg8pcNA8n4eFkDWYHgSsMnXvm/Tm8mYVDQoxHd9xxh53tpLzRAVk8wJf7VF5ybXPdzJZBDhckV67H21f2mUmFkDw59s+W2cxi/WfArjTkdEDmKxoxEkt0BsncWztmZybFkV+X4lVCo9tx5M41DMAmmSleWxfp1AGhDOWYds0DZhXWHKP4xNYIcvoXp0sizc2mGD/QHFrlsZnStXWhCH/44YcjTpdkvrK2jL/fJJohWAQbJ9pkFs6dw7FhvvY8/oXpQ//+/W096DVMPHqr4DYvlU0zLl+jdYWZBYsWNjvxdEDYbNFPZqhMeGc7a8Qx+hfvrJu3rjA6IP+sF8pyNwvm9HLeOoP2g3RAPCfcC/qIgh89DwaJHBtJLKiaSq0DgttXGnIMiIeBH0pYoz+xD7axY4nBwf8iV4QBUfHjjz9ulZG0ywOJEtUxLfLDvPyU+/TTT63hJFPT7jqME3prUUu+v9+kQTBN4yM6ag7A+ffcc09UkUuZsH3AsA4FtDMngJkzK8bMoKN0MSAYOrN4tOGu18SmtzOQri3/NhkDgukb+y9bH1bLjmDGtAE2c+fOdclxt0EMiMJMNDjjVuqDsaFAj8cwK7MSWl2ymickm2RCJwsGbBgRVoQMQ7QGkegaWEcUlljwiLKzuQkoyPCrIoRxIz+GFRgHZpJYpIoBKENap1vJZHvpqBtsmCwA64re73T0Jx/rUAaUj3dF+6QIVBIEKrUSupLcY71MRSBvEVAGlLe3RjumCBQ/AsqAiv8e6xUqAnmLgDKgvL012jFFoPgRUAZU/PdYr1ARyFsElAHl7a3RjikCxY+AMqDiv8d6hYpA3iKgDChvb412TBEofgSUARX/PdYrVATyFgFlQHl7a7RjikDxI6AMqPjvsV6hIpC3CCgDyttbox1TBIofAWVAxX+P9QoVgbxFQBlQ3t4a7ZgiUPwIKAMq/nusV6gI5C0CyoDy9tZoxxSB4kdAGVDx32O9QkUgbxFQBpS3t0Y7pggUPwLKgIr/HusVKgJ+BN5UAAAAWklEQVR5i4AyoLy9NdoxRaD4EVAGVPz3WK9QEchbBJQB5e2t0Y4pAsWPgDKg4r/HeoWKQN4ioAwob2+NdkwRKH4ElAEV/z3WK1QE8hYBZUB5e2u0Y4pA8SPw/xg0aWbcZASbAAAAAElFTkSuQmCC" alt="\label{fig:Enron_graph} Asymmetric adjacency matrices of aligned Enron Corporation communication networks. The vertices are sorted by a community detection algorithm \citep{community_detection} and degree." width="0.6\textwidth" />
<p class="caption">
 Asymmetric adjacency matrices of aligned Enron Corporation communication networks. The vertices are sorted by a community detection algorithm  and degree.
</p>
</div>
<p>Note that 37 and 32 out of the total 184 nodes are isolated from the other nodes in two graphs respectively, indicating the corresponding employees haven’t sent or received emails from other employees. This adds difficulty to matching since it’s impossible to distinguish the isolated nodes based on topological structure alone. We first keep only the largest connected component of each graph.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1"></a>vid1 &lt;-<span class="st"> </span><span class="kw">which</span>(<span class="kw">largest_cc</span>(Enron[[<span class="dv">1</span>]])<span class="op">$</span>keep)</span>
<span id="cb49-2"><a href="#cb49-2"></a>vid2 &lt;-<span class="st"> </span><span class="kw">which</span>(<span class="kw">largest_cc</span>(Enron[[<span class="dv">2</span>]])<span class="op">$</span>keep)</span>
<span id="cb49-3"><a href="#cb49-3"></a></span>
<span id="cb49-4"><a href="#cb49-4"></a>vinsct &lt;-<span class="st"> </span><span class="kw">intersect</span>(vid1, vid2) </span>
<span id="cb49-5"><a href="#cb49-5"></a>v1 &lt;-<span class="st"> </span><span class="kw">setdiff</span>(vid1, vid2)</span>
<span id="cb49-6"><a href="#cb49-6"></a>v2 &lt;-<span class="st"> </span><span class="kw">setdiff</span>(vid2, vid1)</span>
<span id="cb49-7"><a href="#cb49-7"></a>A &lt;-<span class="st"> </span>Enron[[<span class="dv">1</span>]][][<span class="kw">c</span>(vinsct, v1), <span class="kw">c</span>(vinsct, v1)]</span>
<span id="cb49-8"><a href="#cb49-8"></a>B &lt;-<span class="st"> </span>Enron[[<span class="dv">2</span>]][][<span class="kw">c</span>(vinsct, v2), <span class="kw">c</span>(vinsct, v2)]</span></code></pre></div>
<p>The sizes of largest connect components of two graphs are 146 and 151, which are different. <!-- The number of core vertices $n_c$ is 145, the rest are junk vertices with cardinality $n_j=$ 6. --> We reorder two graphs so that the first 145 nodes are aligned and common to both graphs.</p>
</div>
<div id="matching-largest-connected-components-using-fw-algorithm" class="section level3">
<h3>Matching largest connected components using FW Algorithm</h3>
<p>Let’s assume the Enron email communication network from the second week is anonymous, and we aim at finding an alignment between the email addresses from the first network and the second one to de-anonymize the latter. Additionally, we want to find the email addresses that are active in both months. <!-- , that is to detect the core vertices. --></p>
<p>Suppose no prior information on partial alignment is available in this example. <!-- In addition to the \textsc{FW} algorithm, other algorithms implemented in the `iGraphMatch` package require prior information in the form of either seeds or similarity scores, and thus are not applicable here. --> <!-- DLS: Above sentence is a bit confusing. Maybe be more clear that FW doesn't strictly require prior information. --> We match the two largest connected components using the  algorithm with indefinite relaxation since seeds and similarity scores are not mandatory for this method.</p>
<p>Without any prior information,  and  arguments take default values which are . For the  argument, we assign equal likelihood to all the possible matches by initializing at the barycenter. Since two graphs are of different sizes, the  function automatically pads the smaller graph with extra 0’s.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1"></a><span class="kw">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb50-2"><a href="#cb50-2"></a>match_FW &lt;-<span class="st"> </span><span class="kw">gm</span>(<span class="dt">A =</span> A, <span class="dt">B =</span> B, <span class="dt">start =</span> <span class="st">&quot;bari&quot;</span>, <span class="dt">max_iter =</span> <span class="dv">200</span>)</span>
<span id="cb50-3"><a href="#cb50-3"></a><span class="kw">head</span>(match_FW)</span></code></pre></div>
<pre><code>##   corr_A corr_B
## 1      1     27
## 2      2      2
## 3      3     30
## 4      4      4
## 5      5      5
## 6      6      6</code></pre>
<p>Then, we check the summary of matching performance in terms of matched nodes, matched edges and the graph matching objective function.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1"></a><span class="kw">summary</span>(match_FW, A, B)</span></code></pre></div>
<pre><code>## Call: gm(A = A, B = B, start = &quot;bari&quot;, max_iter = 200)
## 
## # Matches: 151, # Seeds:  0, # Vertices:  146, 151
##                   
##   common_edges 353
##  missing_edges 134
##    extra_edges 128
##          fnorm  16</code></pre>
<!-- If the ground truth alignment is available, users can pass in the true alignment via \code{true_label}, and the report will also provide information on the number of correctly matched vertices. -->
<p>In this example, we can evaluate the matching result based on statistics on matched edges. Without any seeds or similarity scores, around 72% of edges are correctly matched. <!-- DLS: 80% of edges means ? Use inline r code here. --></p>
</div>
<div id="centering-the-larger-graph" class="section level3">
<h3>Centering the larger graph</h3>
<p>We can try to improve performance by centering <code>B</code> by assigning -1 to non-edges, so that we penalize edges that are missing in <code>B</code> but present in <code>A</code>.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1"></a>A_center &lt;-<span class="st"> </span><span class="kw">center_graph</span>(<span class="dt">A =</span> A, <span class="dt">scheme =</span> <span class="st">&quot;naive&quot;</span>, <span class="dt">use_splr =</span> <span class="ot">TRUE</span>)</span>
<span id="cb54-2"><a href="#cb54-2"></a>B_center &lt;-<span class="st"> </span><span class="kw">center_graph</span>(<span class="dt">A =</span> B, <span class="dt">scheme =</span> <span class="st">&quot;center&quot;</span>, <span class="dt">use_splr =</span> <span class="ot">TRUE</span>)</span>
<span id="cb54-3"><a href="#cb54-3"></a><span class="kw">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb54-4"><a href="#cb54-4"></a>match_FW_center &lt;-<span class="st"> </span><span class="kw">gm</span>(<span class="dt">A =</span> A_center, <span class="dt">B =</span> B_center, </span>
<span id="cb54-5"><a href="#cb54-5"></a>                           <span class="dt">start =</span> <span class="st">&quot;bari&quot;</span>, <span class="dt">max_iter =</span> <span class="dv">200</span>)</span>
<span id="cb54-6"><a href="#cb54-6"></a><span class="kw">summary</span>(match_FW_center, A, B)</span></code></pre></div>
<pre><code>## Call: gm(A = A_center, B = B_center, start = &quot;bari&quot;, max_iter = 200)
## 
## # Matches: 151, # Seeds:  0, # Vertices:  146, 151
##                   
##   common_edges 399
##  missing_edges  88
##    extra_edges  82
##          fnorm  13</code></pre>
<!-- Running \textsc{FW} algorithm on the centered graphs raises the flag that convergence may not occur with the maximum number of iterations set to be 200. -->
<!-- One might want to increase the value for \code{max_iter} argument or change random seed in this case to make the algorithm converge so that the results can be more reliable. -->
<!-- Here we choose to set a different random seed in the \code{set.seed} function. -->
<!-- I don't like that at this point we've changed two things, the centering and the seed, so it kind of obscures what's making the difference. What performance do we get if we use uncentered here. -->
<!-- DLS: result is below. We could just set seed to 1 for the first match in the example and then never run into the warnings. -->
<p>From the summary tables, we would prefer matching Enron networks with the application of the centering scheme, since we get more matched common edges, as well as fewer missing edges and extra edges.</p>
</div>
<div id="matching-with-adaptive-seeds" class="section level3">
<h3>Matching with adaptive seeds</h3>
<!-- The \code{summary} function measures the matching performance on the graph level, and it's especially useful when the ground truth is available and \code{summary} returns the number of correct matches as a straightforward measure of the overall matching performance.
In this example, we have no access to the ground truth but would still want to rank the matched pairs of vertices in the order of their likelihood of being correct matches. -->
<p>Supposing we have no access to ground truth, we use the  function to measure and rank the vertex-wise matching performance. Below shows the 6 matches that minimize the row permutation statistic. <!-- The \code{num} argument reflects the number of top ranked vertices the user is trying to extract from the entire matching.
Here we target at ranking all the matched pairs of nodes and set \code{num=151}. --> <!-- DLS: made this the default --></p>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1"></a>bm &lt;-<span class="st"> </span><span class="kw">best_matches</span>(<span class="dt">A =</span> A, <span class="dt">B =</span> B, <span class="dt">match =</span> match_FW_center, </span>
<span id="cb56-2"><a href="#cb56-2"></a>             <span class="dt">measure =</span> <span class="st">&quot;row_perm_stat&quot;</span>)</span>
<span id="cb56-3"><a href="#cb56-3"></a><span class="kw">head</span>(bm)</span></code></pre></div>
<pre><code>##      A_best B_best measure_value
## V83      65     65         -40.6
## V75      57     57          -3.4
## V147    115    115          -3.2
## V59      43     43          -2.9
## V64      48     48          -2.3
## V51      36     36          -1.9</code></pre>
<p>Since seeded graph matching enhances the graph matching performance substantially , it may be useful to use some of these best matches as seeds to improve matching results. Here, we use adaptive seeds, taking the <span class="math inline">\(k\)</span> best matches and using them as seeds in a second run of the matching algorithm. <!-- provided precision is high using the matches \code{best_matches} as seeds and running \textsc{FW} algorithm again may improve the matching results. --> The table below displays edge statistics and objective function values for different number of adaptive seeds used. The second column in the table shows the matching precision of the adaptive seeds based on ground truth. Incorporating adaptive seeds and repeating the  matching procedure on centered graphs further improve the matching results, compared with the case without any adaptive seeds when <span class="math inline">\(ns=0\)</span>. The first 40 pairs of matched nodes ranked by  function are all correctly matched, and this is also when matching is improved the most.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1"></a>match_w_hard_seeds &lt;-<span class="st"> </span><span class="cf">function</span>(ns){</span>
<span id="cb58-2"><a href="#cb58-2"></a>  seeds_bm &lt;-<span class="st"> </span><span class="kw">head</span>(bm, ns)</span>
<span id="cb58-3"><a href="#cb58-3"></a>  precision &lt;-<span class="st"> </span><span class="kw">mean</span>(seeds_bm<span class="op">$</span>A_best <span class="op">==</span><span class="st"> </span>seeds_bm<span class="op">$</span>B_best)</span>
<span id="cb58-4"><a href="#cb58-4"></a>  match_FW_center_seeds &lt;-<span class="st"> </span><span class="kw">gm</span>(<span class="dt">A =</span> A_center, <span class="dt">B =</span> B_center,</span>
<span id="cb58-5"><a href="#cb58-5"></a>                           <span class="dt">seeds =</span> seeds_bm, <span class="dt">similarity =</span> <span class="ot">NULL</span>,</span>
<span id="cb58-6"><a href="#cb58-6"></a>                           <span class="dt">start =</span> <span class="st">&quot;bari&quot;</span>, <span class="dt">max_iter =</span> <span class="dv">100</span>)</span>
<span id="cb58-7"><a href="#cb58-7"></a>  edge_info &lt;-<span class="st"> </span><span class="kw">summary</span>(match_FW_center_seeds, A, B)<span class="op">$</span>edge_match_info</span>
<span id="cb58-8"><a href="#cb58-8"></a>  <span class="kw">cbind</span>(ns, precision, edge_info)</span>
<span id="cb58-9"><a href="#cb58-9"></a>}</span>
<span id="cb58-10"><a href="#cb58-10"></a><span class="kw">set.seed</span>(<span class="dv">12345</span>)</span>
<span id="cb58-11"><a href="#cb58-11"></a><span class="kw">map_dfr</span>(<span class="kw">seq</span>(<span class="dt">from =</span> <span class="dv">0</span>, <span class="dt">to =</span> <span class="dv">80</span>, <span class="dt">by =</span> <span class="dv">20</span>), match_w_hard_seeds)</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="right">ns</th>
<th align="right">precision</th>
<th align="right">common</th>
<th align="right">missing</th>
<th align="right">extra</th>
<th align="right">fnorm</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">0</td>
<td align="right">NaN</td>
<td align="right">394</td>
<td align="right">93</td>
<td align="right">87</td>
<td align="right">13</td>
</tr>
<tr class="even">
<td align="right">20</td>
<td align="right">1.00</td>
<td align="right">402</td>
<td align="right">85</td>
<td align="right">79</td>
<td align="right">13</td>
</tr>
<tr class="odd">
<td align="right">40</td>
<td align="right">1.00</td>
<td align="right">410</td>
<td align="right">77</td>
<td align="right">71</td>
<td align="right">12</td>
</tr>
<tr class="even">
<td align="right">60</td>
<td align="right">0.97</td>
<td align="right">400</td>
<td align="right">87</td>
<td align="right">81</td>
<td align="right">13</td>
</tr>
<tr class="odd">
<td align="right">80</td>
<td align="right">0.92</td>
<td align="right">402</td>
<td align="right">85</td>
<td align="right">79</td>
<td align="right">13</td>
</tr>
</tbody>
</table>
<p>As the number of adaptive seeds increases, the precision of adaptive seeds decreases. Note that if they are treated as hard seeds, incorrect matches will remain in the matched set and might cause a cascade of errors. An alternative way is to treat the top-ranked matches as soft seeds embedded in the start matrix to handle the uncertainty. In this way, adaptive seeds not only provide prior information but also evolve over iterations. The table below shows that the matching performance for soft seeding approach always outperforms hard seeding approach regardless of the number of adaptive seeds being used.</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1"></a>match_w_soft_seeds &lt;-<span class="st"> </span><span class="cf">function</span>(ns){</span>
<span id="cb59-2"><a href="#cb59-2"></a>  seeds_bm &lt;-<span class="st"> </span><span class="kw">head</span>(bm, ns)</span>
<span id="cb59-3"><a href="#cb59-3"></a>  precision &lt;-<span class="st"> </span><span class="kw">mean</span>(seeds_bm<span class="op">$</span>A_best <span class="op">==</span><span class="st"> </span>seeds_bm<span class="op">$</span>B_best)</span>
<span id="cb59-4"><a href="#cb59-4"></a>  start_soft &lt;-<span class="st"> </span><span class="kw">init_start</span>(<span class="dt">start =</span> <span class="st">&quot;bari&quot;</span>, </span>
<span id="cb59-5"><a href="#cb59-5"></a>                           <span class="dt">nns =</span> <span class="kw">max</span>(<span class="kw">dim</span>(A)[<span class="dv">1</span>], <span class="kw">dim</span>(B)[<span class="dv">1</span>]), </span>
<span id="cb59-6"><a href="#cb59-6"></a>                           <span class="dt">soft_seeds =</span> seeds_bm)</span>
<span id="cb59-7"><a href="#cb59-7"></a>  match_FW_center_soft_seeds &lt;-<span class="st"> </span><span class="kw">gm</span>(<span class="dt">A =</span> A_center, <span class="dt">B =</span> B_center, </span>
<span id="cb59-8"><a href="#cb59-8"></a>                           <span class="dt">start =</span> start_soft, <span class="dt">max_iter =</span> <span class="dv">100</span>)</span>
<span id="cb59-9"><a href="#cb59-9"></a>  edge_info &lt;-<span class="st"> </span><span class="kw">summary</span>(match_FW_center_soft_seeds, A, B)<span class="op">$</span>edge_match_info</span>
<span id="cb59-10"><a href="#cb59-10"></a>  <span class="kw">cbind</span>(ns, precision, edge_info)</span>
<span id="cb59-11"><a href="#cb59-11"></a>}</span>
<span id="cb59-12"><a href="#cb59-12"></a><span class="kw">set.seed</span>(<span class="dv">12345</span>)</span>
<span id="cb59-13"><a href="#cb59-13"></a><span class="kw">map_dfr</span>(<span class="kw">seq</span>(<span class="dt">from =</span> <span class="dv">0</span>, <span class="dt">to =</span> <span class="dv">80</span>, <span class="dt">by =</span> <span class="dv">20</span>), match_w_soft_seeds)</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="right">ns</th>
<th align="right">precision</th>
<th align="right">common</th>
<th align="right">missing</th>
<th align="right">extra</th>
<th align="right">fnorm</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">0</td>
<td align="right">NaN</td>
<td align="right">394</td>
<td align="right">93</td>
<td align="right">87</td>
<td align="right">13</td>
</tr>
<tr class="even">
<td align="right">20</td>
<td align="right">1.00</td>
<td align="right">410</td>
<td align="right">77</td>
<td align="right">71</td>
<td align="right">12</td>
</tr>
<tr class="odd">
<td align="right">40</td>
<td align="right">1.00</td>
<td align="right">410</td>
<td align="right">77</td>
<td align="right">71</td>
<td align="right">12</td>
</tr>
<tr class="even">
<td align="right">60</td>
<td align="right">0.97</td>
<td align="right">400</td>
<td align="right">87</td>
<td align="right">81</td>
<td align="right">13</td>
</tr>
<tr class="odd">
<td align="right">80</td>
<td align="right">0.92</td>
<td align="right">409</td>
<td align="right">78</td>
<td align="right">72</td>
<td align="right">12</td>
</tr>
</tbody>
</table>
</div>
<div id="core-vertices-detection" class="section level3">
<h3>Core vertices detection</h3>
<p>The function  can also be used to detect core vertices. Suppose the ground truth is known and that the first 145 vertices are core vertices. The mean precision of detecting core vertices and junk vertices using  function is displayed in figure . A lower rank is a stronger indicator of a core vertex and a higher rank is a stronger indicator of a junk vertex. Let <span class="math inline">\(r^C_i, 1\le i\le n_c\)</span> and <span class="math inline">\(r^J_j, 1\le j\le n_j\)</span> denote the ranks associated with each core vertex and each junk vertex. The figure shows the precision of identifying core vertices at each low rank <span class="math inline">\(r\)</span>, i.e. <span class="math inline">\(\frac{1}{r}\sum_{i = 1}^{n_c}\mathbbm{1}_{r^C_i\le r}\)</span>, and the precision of identifying junk vertices at each high rank <span class="math inline">\(r\)</span>, i.e. <span class="math inline">\(\frac{1}{r}\sum_{j = 1}^{n_j}\mathbbm{1}_{r^J_j\ge n_c+n_j-r}\)</span>, which are separated by the vertical lines.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1"></a>nc &lt;-<span class="st"> </span><span class="kw">length</span>(vinsct)</span>
<span id="cb60-2"><a href="#cb60-2"></a>nj &lt;-<span class="st"> </span><span class="kw">max</span>(<span class="kw">length</span>(v1), <span class="kw">length</span>(v2))</span>
<span id="cb60-3"><a href="#cb60-3"></a>core_precision &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span>nc <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">map_dbl</span>(<span class="op">~</span><span class="kw">mean</span>(bm<span class="op">$</span>A_best[<span class="dv">1</span><span class="op">:</span>.x]<span class="op">&lt;=</span>nc))</span>
<span id="cb60-4"><a href="#cb60-4"></a>junk_precision &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span>nj <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">map_dbl</span>(<span class="op">~</span><span class="kw">mean</span>(bm<span class="op">$</span>A_best[(nc<span class="op">+</span>.x)<span class="op">:</span>(nc<span class="op">+</span>nj)]<span class="op">&gt;</span>nc))</span></code></pre></div>
<p>Core detection performance is substantially better than chance, as represented by the dotted horizontal lines. The top 88 are all core vertices indicating good overall performance for core identification. For junk identification, the junk vertices are ranked 63, 54, 50, 14, 6, 5 according to which have the lowest score, indicating that some junk vertices are difficult to identify.</p>
<div class="figure">
<img src="data:image/png;base64,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" alt="\label{fig:core}Mean precision for identifying core and junk vertices for the Enron networks by using the row permutation test. The vertical lines separate the performance of identifying core vertices with low ranks from junk vertices with high ranks. The horizontal lines indicate the performance of a random classifier." width="0.5\textwidth" height="0.24\textheight" />
<p class="caption">
Mean precision for identifying core and junk vertices for the Enron networks by using the row permutation test. The vertical lines separate the performance of identifying core vertices with low ranks from junk vertices with high ranks. The horizontal lines indicate the performance of a random classifier.
</p>
</div>
<!-- Maybe instead of this figure we just cite some precision at k values for various k, for both junk and core. -->
</div>
</div>
<div id="sec:CE" class="section level2">
<h2>Example: C. Elegans Network Data</h2>
<p>The <em>C. Elegans</em> networks consist of the chemical synapses network and the electrical synapses network of the roundworm, where each of 279 nodes represents a neuron and each edge represents the intensity of synapse connections between two neurons . Matching the chemical synapses network to the electrical synapses network is essential for understanding how the brain functions. These networks are quite sparse with edge densities of 0.03 and 0.01 in each graph and the empirical correlation between two graphs is 0.1.</p>
<div id="a-challenging-task" class="section level3">
<h3>A challenging task</h3>
<p>For simplicity, we made the networks unweighted and undirected for the experiments, and we assume the ground truth is known to be the identity.</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1"></a>C1 &lt;-<span class="st"> </span>C.Elegans[[<span class="dv">1</span>]][] <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span></span>
<span id="cb61-2"><a href="#cb61-2"></a>C2 &lt;-<span class="st"> </span>C.Elegans[[<span class="dv">2</span>]][] <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span></span>
<span id="cb61-3"><a href="#cb61-3"></a><span class="kw">plot</span>(C1[], C2[])</span>
<span id="cb61-4"><a href="#cb61-4"></a>match &lt;-<span class="st"> </span><span class="kw">gm</span>(C1, C2, <span class="dt">start =</span> Matrix<span class="op">::</span><span class="kw">Diagonal</span>(<span class="kw">nrow</span>(C1)))</span>
<span id="cb61-5"><a href="#cb61-5"></a><span class="kw">plot</span>(C1[], C2[], match)</span></code></pre></div>
<div class="figure">
<img src="data:image/png;base64,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" alt="\label{fig:edge} Edge discrepancies for the matched graphs with the true correspondence and FW algorithm starting at the true correspondence. Green pixels represents an edge in the chemical graph while no edge in the electrical graph. Red pixels represent only an edge in the electrical graph. Grey pixels represent there is an edge in both graphs and white represents no edge in both graphs." height="0.24\textheight" keepaspectratio /><img src="data:image/png;base64,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" alt="\label{fig:edge} Edge discrepancies for the matched graphs with the true correspondence and FW algorithm starting at the true correspondence. Green pixels represents an edge in the chemical graph while no edge in the electrical graph. Red pixels represent only an edge in the electrical graph. Grey pixels represent there is an edge in both graphs and white represents no edge in both graphs." height="0.24\textheight" keepaspectratio />
<p class="caption">
 Edge discrepancies for the matched graphs with the true correspondence and FW algorithm starting at the true correspondence. Green pixels represents an edge in the chemical graph while no edge in the electrical graph. Red pixels represent only an edge in the electrical graph. Grey pixels represent there is an edge in both graphs and white represents no edge in both graphs.
</p>
</div>
<div class="sourceCode" id="cb62"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1"></a>nv &lt;-<span class="st"> </span><span class="kw">nrow</span>(C1)</span>
<span id="cb62-2"><a href="#cb62-2"></a>id_match &lt;-<span class="st"> </span><span class="kw">graphMatch</span>(<span class="kw">data.frame</span>(<span class="dt">corr_A =</span> <span class="dv">1</span><span class="op">:</span>nv, <span class="dt">corr_B =</span> <span class="dv">1</span><span class="op">:</span>nv), nv)</span>
<span id="cb62-3"><a href="#cb62-3"></a>i_sum &lt;-<span class="st"> </span><span class="kw">summary</span>(id_match, C.Elegans[[<span class="dv">1</span>]], C.Elegans[[<span class="dv">2</span>]])</span>
<span id="cb62-4"><a href="#cb62-4"></a>m_sum &lt;-<span class="st"> </span><span class="kw">summary</span>(match, C.Elegans[[<span class="dv">1</span>]], C.Elegans[[<span class="dv">2</span>]], id_match)</span>
<span id="cb62-5"><a href="#cb62-5"></a>i_emi &lt;-<span class="st"> </span>i_sum<span class="op">$</span>edge_match_info</span>
<span id="cb62-6"><a href="#cb62-6"></a>m_emi &lt;-<span class="st"> </span>m_sum<span class="op">$</span>edge_match_info</span></code></pre></div>
<p>Matching the <em>C. Elegans</em> networks is a challenging task. Figures  depict the edge discrepancies of two networks under the true alignment and the matching correspondence using  algorithm initialized at the true alignment. <!-- \todo{is it feasible to refer to figure 1 here to avoid detailed explanation?} --> <!-- The figures were generated by using the \code{plot} function in the `iGraphMatch` package on the chemical synapses network and the electrical synapses network. --> <!-- One can refer to Figure \ref{fig:visualization} for more details. --> <!-- Blue pixels represent edges only in the chemical network and red pixels are edges only in the electrical network. --> <!-- Grey pixels represent edges in both graphs and white pixels non-edges in both graphs. --> The alignment found using  is not the identity with 124 out of 279 nodes correctly matched <!-- \todo{how far from identity?}  --> and improves upon the identity in terms of the number of edge discrepancies. <!-- 
DLS: Again, not sure where these numbers came from.
For the true alignment, there are 4201 edge errors and 376 common edges while the alignment yielded by \textsc{FW} initialized at the true correspondence has 3265 edge errors and 836 common edges.
--> For the true alignment, there are 116 edge errors and 1380 common edges while the alignment yielded by  initialized at the true correspondence has 267.5 edge errors and 1078 common edges. Hence, this graph matching object does not have a solution at the true alignment. One can try to use other objective functions to enhance the matching result, however we do not investigate this here. Overall, while most performance measures are poor, our results illustrate the spectrum of challenges for graph matching.</p>
</div>
<div id="soft-matching-map3" class="section level3">
<h3>Soft matching: MAP@3</h3>
<p>Considering matching <em>C. Elegans</em> graphs is quite challenging, let’s assume 20 pairs of vertices are known as seeds, which are chosen at random. Accordingly, we generate a similarity matrix with 1’s corresponding to seeds, and the rest being barycenter.</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1"></a>seeds &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="kw">nrow</span>(C1), <span class="dv">20</span>)</span>
<span id="cb63-2"><a href="#cb63-2"></a>sim &lt;-<span class="st"> </span><span class="kw">init_start</span>(<span class="dt">start =</span> <span class="st">&quot;bari&quot;</span>, <span class="dt">nns =</span> <span class="kw">nrow</span>(C1), <span class="dt">soft_seeds =</span> seeds)</span></code></pre></div>
<p>In addition to one-on-one matching, we will also conduct soft matching, which is to find three most promising matches to each non-seed vertex. We achieve the goal of soft matching by finding the top 3 largest values in each row of the doubly stochastic matrix from the last iteration of  methodology with indefinite relaxation and  algorithm, as well as the normalized matrix from the last iteration of the power method for  algorithm. To evaluate the matching performance, we will look at both matching precision: <span class="math inline">\(precision=\frac{1}{n_m-s}\sum_{i\in V_m\setminus S}P_{ii}\)</span>, and Mean Average Precision @ 3 (MAP@ 3):<span class="math inline">\(MAP@3 = \frac{1}{n_m-s}\sum_{i\in V_m\setminus S}\mathbbm{1}_{\{i\in T_i\}}\)</span>, where <span class="math inline">\(T_i\)</span> is the set of 3 most promising matches to node <span class="math inline">\(i\)</span>.</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1"></a><span class="kw">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb64-2"><a href="#cb64-2"></a>m_FW &lt;-<span class="st"> </span><span class="kw">gm</span>(<span class="dt">A =</span> C1, <span class="dt">B =</span> C2, <span class="dt">seeds =</span> seeds, </span>
<span id="cb64-3"><a href="#cb64-3"></a>           <span class="dt">similarity =</span> sim, <span class="dt">method =</span> <span class="st">&quot;indefinite&quot;</span>,</span>
<span id="cb64-4"><a href="#cb64-4"></a>           <span class="dt">start =</span> <span class="st">&quot;bari&quot;</span>, <span class="dt">max_iter =</span> <span class="dv">100</span>)</span>
<span id="cb64-5"><a href="#cb64-5"></a>m_PATH &lt;-<span class="st"> </span><span class="kw">gm</span>(<span class="dt">A =</span> C1, <span class="dt">B =</span> C2, <span class="dt">seeds =</span> seeds,</span>
<span id="cb64-6"><a href="#cb64-6"></a>             <span class="dt">similarity =</span> <span class="ot">NULL</span>, <span class="dt">method =</span> <span class="st">&quot;PATH&quot;</span>,</span>
<span id="cb64-7"><a href="#cb64-7"></a>             <span class="dt">epsilon =</span> <span class="dv">1</span>, <span class="dt">tol =</span> <span class="fl">1e-05</span>)</span>
<span id="cb64-8"><a href="#cb64-8"></a>m_Iso &lt;-<span class="st"> </span><span class="kw">gm</span>(<span class="dt">A =</span> C1, <span class="dt">B =</span> C2, <span class="dt">seeds =</span> seeds,</span>
<span id="cb64-9"><a href="#cb64-9"></a>             <span class="dt">similarity =</span> <span class="kw">as.matrix</span>(sim), <span class="dt">method =</span> <span class="st">&quot;IsoRank&quot;</span>,</span>
<span id="cb64-10"><a href="#cb64-10"></a>             <span class="dt">max_iter =</span> <span class="dv">50</span>, <span class="dt">lap_method =</span> <span class="st">&quot;LAP&quot;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb65"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1"></a>match_eval &lt;-<span class="st"> </span><span class="cf">function</span>(match){</span>
<span id="cb65-2"><a href="#cb65-2"></a>  precision &lt;-<span class="st"> </span><span class="kw">mean</span>(match<span class="op">$</span>corr_A <span class="op">==</span><span class="st"> </span>match<span class="op">$</span>corr_B) </span>
<span id="cb65-3"><a href="#cb65-3"></a>  order &lt;-<span class="st"> </span><span class="kw">apply</span>(match<span class="op">$</span>soft, <span class="dt">MARGIN =</span> <span class="dv">1</span>, <span class="dt">FUN =</span> order, <span class="dt">decreasing =</span> <span class="ot">TRUE</span>)</span>
<span id="cb65-4"><a href="#cb65-4"></a>  top3 &lt;-<span class="st"> </span><span class="kw">t</span>(order[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>,]) <span class="op">-</span><span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="kw">ncol</span>(order) </span>
<span id="cb65-5"><a href="#cb65-5"></a>  MAP3 &lt;-<span class="st"> </span><span class="kw">mean</span>(<span class="kw">apply</span>(top3, <span class="dt">MARGIN =</span> <span class="dv">1</span>, <span class="dt">FUN =</span> <span class="cf">function</span>(v){<span class="dv">0</span> <span class="op">%in%</span><span class="st"> </span>v}))</span>
<span id="cb65-6"><a href="#cb65-6"></a>  </span>
<span id="cb65-7"><a href="#cb65-7"></a>  <span class="kw">round</span>(<span class="kw">data.frame</span>(precision, MAP3),<span class="dv">4</span>)</span>
<span id="cb65-8"><a href="#cb65-8"></a>}</span>
<span id="cb65-9"><a href="#cb65-9"></a></span>
<span id="cb65-10"><a href="#cb65-10"></a><span class="kw">sapply</span>(<span class="kw">list</span>(m_FW, m_PATH, m_Iso), match_eval) <span class="op">%&gt;%</span><span class="st"> </span></span>
<span id="cb65-11"><a href="#cb65-11"></a><span class="st">  </span>knitr<span class="op">::</span><span class="kw">kable</span>(<span class="dt">col.names =</span> <span class="kw">c</span>(<span class="st">&quot;Frank Wolfe&quot;</span>, <span class="st">&quot;PATH&quot;</span>, <span class="st">&quot;IsoRank&quot;</span>), </span>
<span id="cb65-12"><a href="#cb65-12"></a>               <span class="dt">booktabs =</span> <span class="ot">TRUE</span>, <span class="dt">digits =</span> <span class="dv">2</span>)</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="left">Frank Wolfe</th>
<th align="left">PATH</th>
<th align="left">IsoRank</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">precision</td>
<td align="left">0.0896</td>
<td align="left">0.086</td>
<td align="left">0.0789</td>
</tr>
<tr class="even">
<td align="left">MAP3</td>
<td align="left">0.0968</td>
<td align="left">0.1111</td>
<td align="left">0.0824</td>
</tr>
</tbody>
</table>
<p>MAP@ 3 is slightly higher than precision for each method. Soft matching provides an alternative way of matching by generating a set of promising matching candidates.</p>
</div>
</div>
<div id="sec:Transp" class="section level2">
<h2>Example: Britain Transportation Network</h2>
<p>To demonstrate matching multi-layer networks-layers, we consider two graphs derived from the Britain Transportation network . The network reflects the transportation connections in the UK, with five layers representing ferry, rail, metro, coach, and bus. A smaller template graph was constructed based on a random walk starting from a randomly chosen hub node, a node that has connections in all the layers. The template graph has 53 nodes and 56 connections in total and is an induced subgraph of the original graph.</p>
<p>Additionally, based on filter methods from , the authors of that paper also provided a list of candidate matches for each template node, where the true correspondence is guaranteed to be among the candidates. The number of candidates ranges from 3 to 1059 at most, with an average of 241 candidates for each template vertex. Thus, we made an induced subgraph from the transportation network with only candidates, which gave us the world graph with 2075 vertices and 8368 connections.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1"></a>tm &lt;-<span class="st"> </span>Transportation[[<span class="dv">1</span>]]</span>
<span id="cb66-2"><a href="#cb66-2"></a>cm &lt;-<span class="st"> </span>Transportation[[<span class="dv">2</span>]]</span>
<span id="cb66-3"><a href="#cb66-3"></a>candidate &lt;-<span class="st"> </span>Transportation[[<span class="dv">3</span>]]</span></code></pre></div>
<p>Figure  visualizes the transportation connections for the induced subgraphs, where means of transportation are represented by different colors. Note that all edges in the template are common edges shared by two graphs, <!-- while the world graph is denser with some extra edges. --> where 40%, 24.1%, 37.5%, 31.7% and 25.6% of edges in the world graph are in template for each layer. All graphs are unweighted, directed, and do not have self-loops. Tables @ref(tab:edge-summary-trans) further displays an overview and edge summary regarding each layer of the Britain Transportation Network. <!-- The average over the layers of the empirical correlation between the induced graphs is 0.559.\todo{Change to, proportion of edges in world that are in template for each layer.} --> A true correspondence exists for each template vertex in the world graph, our goal is to locate each template vertex in the Britain Transportation network by matching two multi-layer graphs with different number of vertices.</p>

<div class="figure">
<img src="data:application/pdf;base64,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r5tfqL/Y/9LuZe902PT9VxmvZl6XvFF/c+At623/u5h3EzO577HvKz+Yfuj5GPTx7qeMT59+A/eE8/sKZW5kc3RyZWFtCmVuZG9iagoyIDAgb2JqCjw8Ci9YT2JqZWN0IDw8IC9JbTEgMSAwIFIgPj4KL1Byb2NTZXQgWyAvUERGIF0KPj4KZW5kb2JqCjUgMCBvYmoKPDwKL1R5cGUgL1BhZ2VzCi9Db3VudCAxCi9LaWRzIFszIDAgUl0KPj4KZW5kb2JqCjExIDAgb2JqCjw8Ci9UeXBlIC9DYXRhbG9nCi9QYWdlcyA1IDAgUgo+PgplbmRvYmoKMTIgMCBvYmoKPDwKL1Byb2R1Y2VyIChwZGZUZVgtMS40MC4xNykKL0NyZWF0b3IgKFRlWCkKL0NyZWF0aW9uRGF0ZSAoRDoyMDIwMTEyMzIzMzY0MC0wNScwMCcpCi9Nb2REYXRlIChEOjIwMjAxMTIzMjMzNjQwLTA1JzAwJykKL1RyYXBwZWQgL0ZhbHNlCi9QVEVYLkZ1bGxiYW5uZXIgKFRoaXMgaXMgcGRmVGVYLCBWZXJzaW9uIDMuMTQxNTkyNjUtMi42LTEuNDAuMTcgKFRlWCBMaXZlIDIwMTYpIGtwYXRoc2VhIHZlcnNpb24gNi4yLjIpCj4+CmVuZG9iagp4cmVmCjAgMTMKMDAwMDAwMDAwMCA2NTUzNSBmIAowMDAwMDAwMjM1IDAwMDAwIG4gCjAwMDAwNDUwNzcgMDAwMDAgbiAKMDAwMDAwMDEzMSAwMDAwMCBuIAowMDAwMDAwMDE1IDAwMDAwIG4gCjAwMDAwNDUxNDIgMDAwMDAgbiAKMDAwMDA0MTg2NSAwMDAwMCBuIAowMDAwMDQyMDA3IDAwMDAwIG4gCjAwMDAwNDIxMDUgMDAwMDAgbiAKMDAwMDA0MjEzOSAwMDAwMCBuIAowMDAwMDQyMzgwIDAwMDAwIG4gCjAwMDAwNDUxOTkgMDAwMDAgbiAKMDAwMDA0NTI0OSAwMDAwMCBuIAp0cmFpbGVyCjw8IC9TaXplIDEzCi9Sb290IDExIDAgUgovSW5mbyAxMiAwIFIKL0lEIFs8ODg5NTk0MEFERUU4NjVFQTg0QzlBMzY2MURCNUEyNjY+IDw4ODk1OTQwQURFRTg2NUVBODRDOUEzNjYxREI1QTI2Nj5dID4+CnN0YXJ0eHJlZgo0NTUwOQolJUVPRgo=" alt="\label{Fig:trans_net} Visualization of the template graph (left) and the world graph (right) with corresponding vertices, both derived from the Britain Transportation network with five layers: ferry, rail, metro, coach, and bus. Edges represent transportation transactions and each color indicates a different means of transportation from a different layer of network." width="0.6\linewidth" />
<p class="caption">
 Visualization of the template graph (left) and the world graph (right) with corresponding vertices, both derived from the Britain Transportation network with five layers: ferry, rail, metro, coach, and bus. Edges represent transportation transactions and each color indicates a different means of transportation from a different layer of network.
</p>
</div>
<!-- Maybe make this using the igm plot functions. -->
<p>Based on the candidates, we specify a start matrix that is row-stochastic which can be used for the  argument in the graph matching function for  methodology. For each row node, its value is either zero or the inverse of the number of candidates for that node. To ensure that template nodes only get matched to candidates, we constructed a similarity score matrix by taking the start matrix <span class="math inline">\(\times 10^5\)</span>, so that a high similarity score is assigned to all the template-candidate pairs.</p>
<p>Then we match the template graph with the world graph using  algorithm. The template graph stored in  and world graph  are lists of 5 matrices of dimensions 53 and 2075 respectively. <!-- One can directly input two multi-layer graphs of different cardinalities into graph matching function, and it will automatically handle the multi-layers and pad the smaller graphs with extra nodes to match the size of the larger graph for each layer. --> Since we have no information on seeds, we assign  to the  argument, the  algorithm will initialize the mark matrix using prior information in the similarity score matrix.</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb67-1"><a href="#cb67-1"></a>match &lt;-<span class="st"> </span><span class="kw">gm</span>(<span class="dt">A =</span> tm, <span class="dt">B =</span> cm, <span class="dt">similarity =</span> similarity, </span>
<span id="cb67-2"><a href="#cb67-2"></a>            <span class="dt">method =</span> <span class="st">&quot;percolation&quot;</span>, <span class="dt">r =</span> <span class="dv">4</span>)</span>
<span id="cb67-3"><a href="#cb67-3"></a><span class="kw">summary</span>(match, tm, cm)</span></code></pre></div>
<pre><code>## Call: gm(A = tm, B = cm, similarity = similarity, method = &quot;percolation&quot;, 
##     r = 4)
## 
## # Matches: 53, # Seeds:  0, # Vertices:  53, 2075
##          layer    1  2    3    4    5
##   common_edges 10.0 13  9.0 12.0 10.0
##  missing_edges  0.0  1  0.0  1.0  0.0
##    extra_edges 22.0 35 21.0 25.0 35.0
##          fnorm  4.7  6  4.6  5.1  5.9</code></pre>
<p>The  function outputs edge statistics and objective function values for each layer separately. To further improve matching performance, one can replicate all the analysis in the first example on Enron dataset, such as using the centering scheme and adaptive seeds. Finally, one can refer to the match report to compare matching performance and pick the best one.</p>
<!--chapter:end:04_example.Rmd-->
</div>
</div>
<div id="sec:conclusion" class="section level1">
<h1>Conclusions</h1>
<p>In this work, we detail the methods and usage of the R package <code>iGraphMatch</code> for finding and assessing an alignment between the vertex sets of two edge-correlated graphs. The package implements common steps for the analysis of graph matching: seamless matching of generalized graphs, evaluation of matching performance, and visualization. For each of the graph matching methodologies, we provide versatile options for the form of input graphs and the specification of available prior information. <!-- Most graph matching methodologies require bulky matrix operations, which is especially the case for graphs of a large scale. 
Accordingly, the package also implements an \pkg{S}3 class for matrices with the sparse plus low-rank structure for computational gains. --> Through the discussion in section , we demonstrate the broad functionality and flexibility of the package by analyzing diverse graph matching problems on real data step by step. The package also provides tools for simulating correlated graphs which can be used in the development and enhancement of graph matching methods.</p>
<p>Methods for graph matching are still under active development. We plan to include other novel methods as the field continues to develop. In the short term we are looking to introduce a suite of additional matching methods that have recently been proposed in the literature.</p>
<p>One of the biggest challenges for graph matching is evaluating the quality of a match, especially at the vertex level. This has received minimal attention in the previous literature. We provide measures of goodness of matching on the vertex level and demonstrate their effectiveness empirically. These baseline methods implement a permutation testing framework for assessing matches that can be readily extended to other metrics.</p>

<p>The primary authors for the package are Vince Lyzinski, Zihuan Qiao, and Daniel Sussman. Joshua Agterberg, Lujia Wang, and Yixin Kong also provided important contributions. We also want to thank all of our users, especially Youngser Park, for their feedback and patience as we continue to develop the package.</p>
<p>This work was supported in part by grants from DARPA (FA8750-20-2-1001 and FA8750-18-0035) and from MIT Lincoln Labs.</p>
<!--chapter:end:05-conclusion.Rmd-->
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
