[{"path":"/articles/iGraphMatch.html","id":"abstract","dir":"Articles","previous_headings":"","what":"Abstract","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"iGraphMatch R package developed matching corresponding vertices two edge-correlated graphs. package covers three categories prevalent graph matching algorithms including relaxation-based, percolation-based, spectral-based, applicable matching graphs general settings: weighted directed graphs different order graphs multiple layers auxiliary graph matching techniques. provide versatile options incorporate prior information form seeds without noise similarity scores. also implement S4 class overloads popular operations matrices R efficient computation sparse plus low-rank matrices, common structure can decompose matrices process matching graphs. addition, iGraphMatch provides functions summarize graph matching results terms several evaluation measures visualize matching performance. Finally, package also enables users sample correlated random graph pairs classic random graph models generate data simulations. paper illustrates practical applications package analysis graph matching detailed examples using real data social networks bioinformatics.","code":""},{"path":"/articles/iGraphMatch.html","id":"sec:intro","dir":"Articles","previous_headings":"","what":"Introduction","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"graph matching (GM) problem seeks find alignment vertex sets graphs best preserves common structure across graphs. often posed minimizing edge disagreements two graphs alignments. Formally, given \\(\\) \\(B\\), two adjacency matrices corresponding two graphs \\(G_1=(V_1, E_1)\\) \\(G_2=(V_2, E_2)\\), goal find \\[\\begin{align*}     \\mathop{\\mathrm{argmin}}_{P\\\\Pi}\\lVert -PBP^T \\rVert_F^2 \\end{align*}\\] \\(\\Pi\\) set permutation matrices. GM wide applications diverse fields, pattern recognition (Berg, Berg, Malik (2005), Caelli Kosinov (2004), Conte et al. (2004)), machine learning (Liu Qiao (2012), Cour, Srinivasan, Shi (2007)), bioinformatics (Nabieva et al. (2005), Ito et al. (2001)), neuroscience (Chen et al. (2015)), social network analysis (Narayanan Shmatikov (2009)), knowledge graph queries (Hu et al. (2018)). generally, problem discovering true latent alignment two networks can often posed variations problem adjusting objective function setting. well-known graph isomorphism problem special case GM problem exists bijection nodes two graphs exactly preserves edge structure. terms computational complexity, GM equivalent NP-hard quadratic assignment problem, considered challenging problem theoretical guarantees exist, even special cases (Finke, Burkard, Rendl (1987)). certain problems graphs nearly isomorphic, polynomial-time algorithms exist (Aflalo, Bronstein, Kimmel (2015a), Umeyama (1988)) methods frequently break challenging instances. paper presents detailed functionality iGraphMatch R package serves practical tool use prevalent graph matching methodologies. algorithms utilize either spectral embedding vertices (Umeyama (1988)), relaxations objective function (Zaslavskiy, Bach, Vert (2009), V. Lyzinski et al. (2016)), apply ideas percolation theory (Yartseva Grossglauser (2013), Kazemi, Hamed Hassani, Grossglauser (2015)). iGraphMatch package provides versatile options working graphs form matrices, igraph objects lists either, matching graphs generalized setting: weighted, directed, graphs different order, multilayer graphs. addition, iGraphMatch package incorporates prior information: seeds similarities implemented algorithms. Seeds, anchors, refer partial knowledge alignment two graphs. practice, seeds can users name location across different social networks pairs genes DNA sequences. algorithms like percolation algorithm (Yartseva Grossglauser (2013), Kazemi, Hamed Hassani, Grossglauser (2015)) matches two graphs propagating matching information neighboring pairs require seeds kick . algorithms improve substantially incorporating seeds can achieve accurate matching polynomial time (Vince Lyzinski, Fishkind, Priebe (2014)). Similarity scores another commonly used prior measures similarity pairs nodes across graphs. bioinformatics area, BLAST similarity score example similarity scores plays important role aligning two PPI networks (Singh, Xu, Berger (2008)). Similarity scores usually generated nodal covariates observed networks (Kelley et al. (2004), Belongie, Malik, Puzicha (2002)). many scenarios availability exact partial matches, hard seeding, realistic expensive, package also enables utilizing noisy prior information. Similarity scores incorporate uncertainty assigning pair nodes higher similarity scores bigger chance match. Seeds uncertainty even error can still handled self-correcting graph matching algorithms like Frank-Wolfe algorithm initialized noisy partial matching, called soft seeding. Fang, Sussman, Lyzinski (2018) showed Frank-Wolfe algorithm soft seeding scheme converges quickly true alignment correlated Erds-R'enyi model high probability. Thus, original intractable problem reduced solvable polynomial time. Although exist open source software packages containing graph matching functionality, iGraphMatch package provides centralized repository common graph matching methodologies flexibility, tools developing graph matching problem methodology, well metrics evaluating tools visualizing matching performance. Among alternative GM packages, relevant ones include igraph (Csardi Nepusz (2006)) package focuses descriptive network analysis graph visualization based igraph objects provides single graph matching algorithm, GraphM (Zaslavskiy, Bach, Vert (2009)) package implements several GM algorithms proposed 1999 2009 C, Corbi (Huang, Wu, Zhang (2013)) R package particularly designed studies bioinformatics SpecMatch (Mateus et al. (2008)) involves implementations spectral embedding based GM algorithms written C/C++. None packages provide breadth tools, flexibility, ease--use provided iGraphMatch package. rest paper organized follows. Section @ref(sec:background) describes theoretical representations implemented GM algorithms, correlated random graph models evaluation metrics. Section @ref(sec:usage) discusses functionality usage R functions package, illustrated synthetic correlated graph pairs. Section @ref(sec:example) presents complex examples real data several functions involved analysis section @ref(sec:conclusion) gives guidelines using different GM algorithms different circumstances concludes paper.","code":""},{"path":"/articles/iGraphMatch.html","id":"sec:background","dir":"Articles","previous_headings":"","what":"Graph matching background","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"section, give background graph matching related problems followed descriptions principal algorithms implemented iGraphMatch. simplicity, state algorithms context matching undirected, unweighted graphs cardinality. algorithms can also directly applied directed weighted graphs. second subsection, discuss techniques matching graphs different number vertices along extensions. conclude section, introduce statistical models correlated networks discuss measures goodness matching. remainder paper use following notation. Let \\(G_1=(V_1,E_1)\\) \\(G_2=(V_2,E_2)\\) denote two graphs \\(n\\) vertices. Let \\(\\) \\(B\\) corresponding binary symmetric adjacency matrices. setting seeded graph matching, suppose without loss generality, first \\(s\\) pairs nodes seeds simplicity. iGraphMatch, much flexible seed specifications possible, illustrated examples usage package section @ref(sec:usage). Accordingly, let \\(\\) \\(B\\) partitioned : \\[\\begin{equation} \\label{eq:seed_blocks} = \\begin{bmatrix} A_{11} & A_{21}^T \\\\ A_{21} & A_{22} \\end{bmatrix}\\text{ } B= \\begin{bmatrix} B_{11} & B_{21}^T \\\\ B_{21} & B_{22} \\end{bmatrix} \\end{equation}\\] \\(A_{11}, B_{11}\\\\{0, 1\\}^{s\\times s}\\) denote seed--seed adjacencies, \\(A_{21}, B_{21}\\\\{0, 1\\}^{(n-s)\\times s}\\) denote nonseed--seed adjacencies \\(A_{22}, B_{22}\\\\{0, 1\\}^{(n-s)\\times (n-s)}\\) denote nonseed--nonseed adjacencies. Let \\(S\\) \\(n\\)--\\(n\\) real-valued matrix similarity scores. Let \\(\\Pi\\) set permutation matrices \\(\\mathcal{D}\\) set doubly stochastic matrices.","code":""},{"path":"/articles/iGraphMatch.html","id":"assignment-problems","dir":"Articles","previous_headings":"Graph matching background","what":"Assignment problems","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"Matching assignment problems core problems combinatorial optimization appear numerous fields (Burkard, Dell’Amico, Martello (2009)). illustrate Eq. \\(\\eqref{eq:ob_func}\\), general version graph matching problem equivalent quadratic assignment problem (QAP). Similarly, QAP related linear assignment problem (LAP) also plays role GM. LAP asks assign \\(n\\) items (eg. workers nodes \\(G_1\\)) \\(n\\) items (eg. tasks nodes \\(G_2\\)) minimum cost. Let \\(C\\) denote \\({n\\times n}\\) cost matrix, \\(C_{ij}\\) denotes cost matching \\(\\) \\(j\\), LAP find \\[\\begin{equation} \\label{eq:LAP} \\begin{aligned} & \\mathop{\\mathrm{argmin}}_{P\\\\Pi} & \\mathrm{trace}(C^TP) \\end{aligned} \\end{equation}\\] LAP solvable \\(O(n^3)\\) time numerous exact approximate methods general (Jonker Volgenant (1988), Kuhn (1955)) special cases, sparse cost matrices (Volgenant (1996)). statement QAP resembles LAP, except cost function expressed quadratic function. Given two \\(n\\text{--}n\\) matrices \\(\\) \\(B\\) can represent flows facilities distance locations respectively, adjacency matrices two unaligned graphs, objective function QAP : \\[\\begin{equation}\\label{eq:qap} \\mathop{\\mathrm{argmin}}_{P\\\\Pi}    \\mathrm{trace}(APBP^T). \\end{equation}\\] problem NP-hard (Finke, Burkard, Rendl (1987)) leading core challenge graph matching approach. illustrated rest section, matching algorithms reduce graph matching problem solving LAP. algorithms, include similarity scores \\(S\\) adding additional term \\(\\mathrm{trace}(S^TP)\\) reduced objective function.","code":""},{"path":"/articles/iGraphMatch.html","id":"subsec:gm","dir":"Articles","previous_headings":"Graph matching background","what":"Graph matching algorithms","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"iGraphMatch package, implement three types prevalent GM algorithms. first group uses relaxations objective function, including convex, concave, indefinite relaxations. second group consists algorithms apply ideas percolation theory, matching information spread initial set matched nodes. last group based spectral embedding vertices.","code":""},{"path":"/articles/iGraphMatch.html","id":"relaxation-based-algorithms","dir":"Articles","previous_headings":"Graph matching background > Graph matching algorithms","what":"Relaxation-based algorithms","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"approaches relax constraint \\(P\\) permutation matrix require \\(P\\) doubly stochastic, optimizing \\(\\mathcal{D}\\), convex hull \\(\\Pi\\). \\(P\\) permutation matrix \\[\\begin{equation} \\label{eq:ob_func}     \\lVert -PBP^T \\rVert_F^2 = \\lVert AP-PB \\rVert_F^2 = \\lVert \\rVert_F^2 + \\lVert B \\rVert_F^2 - 2\\cdot \\mathrm{trace}APBP^T. \\end{equation}\\] However, equalities hold \\(P\\\\mathcal{D}\\), leading different relaxations. second term Eq.\\(\\eqref{eq:ob_func}\\) convex function optimizing \\(P\\\\mathcal{D}\\) gives convex relaxation, gradient \\(P\\) convex relaxed objective function \\(-4 APB + 2A^TAP + 2PBB^T\\). last equality Eq. \\(\\eqref{eq:ob_func}\\) shows minimizing edge disagreements equivalent maximizing number edge agreements, \\(\\mathrm{trace} APBP^T\\), QAP. Optimizing indefinite function \\(\\mathcal{D}\\) gives indefinite relaxation gradient \\(-2APB\\) (V. Lyzinski et al. (2016)). (#tab:relaxation) Summary relaxation methods graph matching problem. Generally, convex relaxation leads solution guaranteed near solution original GM. However, Aflalo, Bronstein, Kimmel (2015a) introduced class “friendly” graphs based spectral properties adjacency matrices characterize applicability convex relaxation. Matching two friendly graphs using convex relaxation guaranteed find exact solution GM problem. Unfortunately, class quite limiting hold statistical models real-world examples. Another relaxation concave relaxation used PATH algorithm (Zaslavskiy, Bach, Vert (2009)). concave relaxation uses Laplacian matrix defined \\(L=D-\\), \\(D\\) diagonal degree matrix diagonal entries \\(D_{ii}=\\sum_{=1}^N A_{ij}\\). Assume \\(L_i\\) \\(D_i\\), \\(=1,2\\), Laplacian matrices degree matrices \\(G_1\\) \\(G_2\\) respectively, can rewrite objective function \\[\\begin{equation} \\label{eq:concave} \\begin{split}     \\lVert -PBP^T\\rVert_F^2 & = \\lVert AP-PB \\rVert_F^2\\\\     & = \\lVert (D_1P-PD_2)-(L_1P-PL_2)\\rVert_F^2\\\\     & = -\\mathrm{trace}(\\Delta P)+\\mathrm{trace}(L_1^2)+\\mathrm{trace}(L_2^2)-2\\mathrm{trace}(L_1^T P L_2 P^T), \\end{split} \\end{equation}\\] matrix \\(\\Delta_{ij}=(D_{2_{jj}}-D_{1_{ii}})^2\\). Dropping terms dependent \\(P\\) equation \\(\\ref{eq:concave}\\), obtain concave function \\(-\\mathrm{trace}(\\Delta P)-2\\mathrm{trace}(L_1^T P L_2 P^T)\\) \\(\\mathcal{D}\\). summary different relaxations provided Table \\(\\ref{tab:relaxation}\\). Relaxing discrete problem continuous problem breaks equivalence original formulation edge disagreement enables employing algorithms based gradient descent.","code":""},{"path":"/articles/iGraphMatch.html","id":"frank-wolfe-methodology","dir":"Articles","previous_headings":"Graph matching background > Graph matching algorithms > Relaxation-based algorithms","what":"Frank Wolfe methodology","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"V. Lyzinski et al. (2016) introduced algorithm relaxed graph matching problem, iteration computable polynomial time, can find local optima relaxations . <span style=“font-variant:small-caps;”>Frank-Wolfe (FW) (Frank Wolfe (1956)) methodology iterative gradient ascent approach composed two steps. first step finds ascent direction maximizes gradient ascent. case ascent direction permutation matrix vertex polytope doubly stochastic matrices. convex, indefinite, concave relaxations, corresponds LAP gradient cost function. second step performs line search along ascent direction optimize relaxed objective function. objectives quadratic, line search simply requires optimizing single-variable quadratic function along line segment. iterative algorithm converges, final step procedure project doubly stochastic matrix back set permutation matrices, also LAP. various relaxed forms can serve objective function \\(f(\\cdot)\\) FW Methodology, cases matrix \\(D^0\\\\mathcal{D}\\) must chosen initialize procedure. convex relaxation, FW methodology guaranteed converge global optimum regardless \\(D^0\\). hand, FW algorithm indefinite relaxation guaranteed find global optimum initialization critical. many instances, optimal solution convex relaxation lies interior \\(\\mathcal{D}\\). can lead inaccurate solutions last projection step. local optima indefinite relaxation often extreme points \\(\\mathcal{D}\\), meaning final projection often nothing. default initialization indefinite problem barycenter matrix, \\(D^0 = \\frac{1}{n}11^T\\), many initialization procedures can used. include randomized initializations, initializations based similarity matrices, initializing indefinite relaxation interior point solution convex relaxation (Aflalo, Bronstein, Kimmel (2015b)). prior information regarding partial correspondence known noisy, rather incorporating information seeds, one can incorporate “soft” seeds used generate initialization (Fang, Sussman, Lyzinski (2018)). prior information available form seeds, seeded graph matching problem (Vince Lyzinski, Fishkind, Priebe (2014)) works objective function \\(\\ref{eq:ob_func}\\) permutation matrix \\(P^{n\\times n}\\) substituted \\(I_s\\oplus P^{(n-s)\\times (n-s)}\\), direct sum \\(s\\times s\\) identity matrix \\((n-s)\\times (n-s)\\) permutation matrix. Employing indefinite relaxed objective function incorporating seeds, formulate problem finding \\[\\begin{align*}     \\hat{P} % &= \\argmin_{P\\\\Pi} \\mathrm{trace} (I_s\\oplus P)B(I_s\\oplus P)^T \\\\     &= \\mathop{\\mathrm{argmax}}_{P\\\\mathcal{D}} 2\\cdot\\mathrm{trace}P^TA_{21}B_{21}^T+\\mathrm{trace}A_{22}PB_{22}P^T \\end{align*}\\] gradient objective function \\[\\begin{equation} \\label{eq:sgm_gradient}   \\nabla f(P)=2\\cdot A_{21}B_{21}^T+2\\cdot A_{22}PB_{22}. \\end{equation}\\] total, uses information seeded nodes nonseeded nodes nonseed--nonseed information. Applying seeded graph matching convex relaxation concave relaxation closely resembles case indefinite relaxation.","code":""},{"path":"/articles/iGraphMatch.html","id":"path-algorithm","dir":"Articles","previous_headings":"Graph matching background > Graph matching algorithms > Relaxation-based algorithms","what":"PATH algorithm","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"Zaslavskiy, Bach, Vert (2009) introduced convex-concave programming approach approximately solve graph matching problem. concave relaxation solution original graph matching problem. PATH algorithm finds local optimum concave relaxation considering convex combinations convex relaxation \\(F_0(P)\\) concave relaxation \\(F_1(P)\\) denoted \\(F_{\\lambda} =(1 - \\lambda) F_0 + \\lambda F_1\\). Starting solution convex relaxation (\\(\\lambda=0\\)) algorithm iteratively performs gradient ascent using FW methodology \\(F_\\lambda\\), increasing \\(\\lambda\\) iteration, \\(\\lambda = 1\\).","code":""},{"path":"/articles/iGraphMatch.html","id":"percolation-based-algorithms","dir":"Articles","previous_headings":"Graph matching background > Graph matching algorithms","what":"Percolation-based algorithms","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"FW methodology, nodes admit correspondence (relaxed) matching correspondence evolves iterations. hand, percolation approaches start set seeds, adding one new match iteration. new matches fixed hence updated future iterations. iteration expands set matched nodes propagating current matching information neighbors. guiding intuition matched neighbors indicator plausible match, intuition analogous gradient ascent approaches . present two algorithms category ExpandWhenStuck algorithm extension Percolation algorithm. distinctions inputs outputs percolation methods compared relaxation methods.","code":""},{"path":"/articles/iGraphMatch.html","id":"percolation-algorithm","dir":"Articles","previous_headings":"Graph matching background > Graph matching algorithms > Percolation-based algorithms","what":"Percolation Algorithm","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"Yartseva Grossglauser (2013) provides simple fast approach solve graph matching problem starting handful seeds propagating rest graphs. iteration, matching information current iteration encoded subpermutation matrix \\(P\\) \\(P_{ij}=1\\) \\(\\) matched \\(j\\), \\(0\\) otherwise. Percolation algorithm searches promising new match among unmatched pairs mark matrix, \\(M=APB\\), gradient indefinite relaxation extended sub-doubly stochastic matrices. similarity scores available, added mark matrix combine topological structure similarity scores. Adopting analogous partitions adjacency matrices equation \\(\\eqref{eq:seed_blocks}\\), let \\(A_{21}, B_{21}\\) denote sub-matrix corresponding potential adjacencies unmatched matched nodes. Since candidates matched pairs permanently removed consideration, need consider \\(M'=A_{21}B_{21}^T\\), sub-matrix \\(M\\) corresponding unmatched nodes graphs. result, Percolation algorithm uses matched--unmatched information generate new matches. Moreover, mark matrix \\(M\\) can also interpreted encoding number matched neighboring pairs pair nodes \\(\\V_1\\), \\(j\\V_2\\). Suppose \\(u, u'\\V_1\\), \\(v,v'\\V_2\\), \\([u,u']\\E_1\\) \\([v,v']\\E_2\\), \\((u',v')\\) neighboring pair \\((u,v)\\). iteration, remain unmatched nodes \\(r\\) matched neighboring pairs, percolation algorithm matches pair nodes highest score \\(M_{uv}\\), adds one mark neighboring pairs \\((u,v)\\). Note algorithm may stop nodes matched, leading return partial match. one tuning parameter Percolation algorithm, threshold \\(r\\) controls tradeoff quantity matches quality matches. small threshold, algorithm larger chance matching wrong pairs. \\(r\\) larger, algorithm might stop matching many pairs (Kazemi, Hamed Hassani, Grossglauser (2015)). Percolation algorithm can generalized matching weighted graphs making adjustment measure matching information neighbors. Since prefer match edges smaller weight differences higher absolute weights, propose adopt following update formula score associated pair nodes \\((,j)\\): \\[M_{ij}=M_{ij} + \\sum_{u\\N()}\\sum_{v\\N(j)}1-\\frac{|w_{iu}-w_{jv}|}{\\max(|w_{iu}|, |w_{jv}|)}.\\] Thus, score contributed neighboring pair \\((,j)\\) number \\([0,1]\\).","code":""},{"path":"/articles/iGraphMatch.html","id":"expandwhenstuck-algorithm","dir":"Articles","previous_headings":"Graph matching background > Graph matching algorithms > Percolation-based algorithms","what":"ExpandWhenStuck Algorithm","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"Kazemi, Hamed Hassani, Grossglauser (2015) extends Percolation algorithm version can operate smaller number seeds. Without enough seeds, unmatched pairs score higher equal threshold \\(r\\), Percolation algorithm stop even still unmatched pairs. ExpandWhenStuck uses pairs nodes least one matched neighboring pair, \\(M_{ij}\\geq 1\\), new seeds restart matching process adding one mark new seeds’ neighboring pairs, without updating matched set. updated mark matrix consists new pairs marks greater equal \\(r\\), percolation algorithm continues, leading larger matched sets.","code":""},{"path":"/articles/iGraphMatch.html","id":"spectral-based-algorithm","dir":"Articles","previous_headings":"Graph matching background > Graph matching algorithms","what":"Spectral-based algorithm","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"Another class graph matching algorithms uses spectral properties adjacency matrices.","code":""},{"path":"/articles/iGraphMatch.html","id":"isorank-algorithm","dir":"Articles","previous_headings":"Graph matching background > Graph matching algorithms > Spectral-based algorithm","what":"IsoRank Algorithm","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"Singh, Xu, Berger (2008) propose IsoRank algorithm uses neighboring topology similarity scores exploits spectral properties solution. IsoRank algorithm also based relaxation-based algorithms encoding topological structure two graphs \\(ADB\\), proportional gradient indefinite relaxation. However, representations term \\(ADB\\) slightly different. \\(\\) \\(B\\) column-wise normalized adjacency matrices \\(D\\) necessarily doubly stochastic matrix yet \\(D_{ij}\\) still indicates promising match \\(\\V_1\\) \\(j\\V_2\\). Similar idea Percolation algorithm, intuition impact pair matched nodes evenly distributed neighbors propagate plausible matches. achieved solving eigenvalue problem \\[\\begin{align}\\label{eq:Iso1}     \\mathrm{vec}(D)=(\\otimes B) \\mathrm{vec}(D), \\end{align}\\] \\(\\mathrm{vec}(D)\\) denotes vectorization matrix \\(D\\), right hand side equivalent \\(ADB\\). combine network-topological structure similarity scores objective function, normalized similarity score \\(E\\) added right hand side Eq. \\(\\ref{eq:Iso1}\\), \\(E=S/\\|S\\|_1\\), \\(|\\cdot|_1\\) denotes L1 norm. Note similarity score available prior information, can also construct doubly stochastic similarity score matrix seeds taking \\(I_{s\\times s}\\oplus \\frac{1}{n-s}11_{(n-s)\\times (n-s)}\\). solve eigenvalue problem \\(\\ref{eq:Iso1}\\), resort power method. Finally, global alignment generated greedy algorithm using algorithms solving linear assignment problem (LAP).","code":""},{"path":"/articles/iGraphMatch.html","id":"umeyama-algorithm","dir":"Articles","previous_headings":"Graph matching background > Graph matching algorithms > Spectral-based algorithm","what":"Umeyama algorithm","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"Umeyama (1988) spectral approach find approximate solutions graph matching problem. Assuming eigendecompositions adjacency matrices \\(\\) \\(B\\) \\(=U_A\\Lambda_AU_A^T\\) \\(B=U_B\\Lambda_BU_B^T\\), let \\(|U_A|\\) \\(|U_B|\\) matrices takes absolute values element \\(U_A\\) \\(U_B\\). modification eigenvector matrices guarantees uniqueness eigenvector selection. global mapping obtained minimizing differences matched rows \\(U_A\\) \\(U_B\\): \\[\\begin{align*}     \\hat{P}=\\mathop{\\mathop{\\mathrm{argmin}}}_{P\\\\Pi}\\lVert |U_A|-P|U_B|\\rVert_F=\\mathop{\\mathop{\\mathrm{argmax}}}_{P\\\\Pi}\\mathrm{trace}(|U_B||U_A|^TP) \\end{align*}\\] Umeyama algorithm can generalized matching directed graphs eigendecomposing Hermitian matrices \\(E_A\\) \\(E_B\\) derived asymmetric adjacency matrices directed graphs. Hermitian matrix adjacency matrix \\(\\) defined \\(E_A=A_S+iA_N\\), \\(A_S=(+^T)/2\\) symmetric matrix, \\(A_N=(-^T)/2\\) skew-symmetric matrix \\(\\) imaginary unit. Similarly, can define Hermitian matrix \\(B\\). Assume eigendecompositions \\(E_A\\) \\(E_B\\) follows: \\[\\begin{align*}     E_A=W_A\\Gamma_AW_A^*, \\quad  E_B=W_B\\Gamma_BW_B^* \\end{align*}\\] aim searching : \\[\\begin{align*}     \\hat{P}=\\mathop{\\mathop{\\mathrm{argmax}}}_{P\\\\Pi}\\mathrm{trace}(|W_B||W_A|^TP) \\end{align*}\\] Note Umeyama algorithm works condition two graphs isomorphic nearly isomorphic.","code":""},{"path":[]},{"path":"/articles/iGraphMatch.html","id":"centering-technique","dir":"Articles","previous_headings":"Graph matching background > Auxiliary graph matching tools","what":"Centering technique","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"Instead encoding non-adjacencies zeros adjacency matrices, centering technique (Sussman et al. (2018)) assigns negative values edges. first approach encoding non-adjacent node-pairs \\(-1\\) centered adjacency matrices \\(\\tilde{}=2A-\\textbf{J}\\) \\(\\tilde{B}=2B-\\textbf{J}\\), \\(\\textbf{J}\\) matrix ones. alternative approach relies modeling assumptions pair graphs correlated share global structure. match \\(\\tilde{} = -\\Lambda_A\\) \\(\\tilde{B} = B-\\Lambda_B\\), \\(\\Lambda\\) \\(n\\text{--}n\\) matrix \\(ij\\)-th entry denoting estimated marginal probability edge. general, \\(\\Lambda\\) unknown methods literature estimate \\(\\Lambda\\). Matching centered graphs changes rewards matching edges, non-edges, penalties mismatches. Adapting centering technique problem hand can used find specific types correspondences. can also combined constructing multilayer networks single layer networks match according multiple criteria (Li Sussman (2019), Fan et al. (2020)). centering technique can applied implemented graph matching algorithm. especially useful padding graphs differing numbers vertices distinguish isolated vertices padded vertices.","code":""},{"path":"/articles/iGraphMatch.html","id":"padding-graphs-of-different-orders","dir":"Articles","previous_headings":"Graph matching background > Auxiliary graph matching tools","what":"Padding graphs of different orders","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"section, considering matching two graphs whose vertex sets cardinality. However, matching graphs different orders commonly seen real-world problems. Suppose \\(\\\\{0,1\\}^{n\\times n}\\) \\(B\\\\{0,1\\}^{n_c\\times n_c}\\) \\(n_c<n\\). One can pad smaller graph extra vertices match order larger graph, \\(\\tilde{B}=B\\oplus \\textbf{0}_{n-n_c}\\) match \\(\\) \\(\\tilde{B}\\). Every implemented graph matching algorithm iGraphMatch package automatically handles input graphs different number vertices using sparse padding minimal memory impact. Since isolated vertices padded vertices share topological structure, can useful center original graphs first pad smaller graph manner. approach serves differentiate isolated vertices padded ones. ’s theoretically verified correlated graph model, centered padding scheme guaranteed find true correspondence nodes \\(G_1\\) induced subgraph \\(G_2\\) mild conditions even \\(|V_1|\\ll|V_2|\\), true alignment guaranteed without centering (Sussman et al. (2018)).","code":""},{"path":"/articles/iGraphMatch.html","id":"exploiting-sparse-and-low-rank-structure","dir":"Articles","previous_headings":"Graph matching background > Auxiliary graph matching tools","what":"Exploiting sparse and low-rank structure","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"Many real-world graphs, especially large graphs, often sparse \\(o(n^2)\\) often \\(\\theta(n)\\) edges. can increase difficulty graph matching problem due fact fewer potential edges match, sparse graphs also come computational advantages. rely igraph Matrix efficient storage structures well efficient implementation various matrix operations. also use LAPMOD algorithm sparse LAP problems (Volgenant (1996)) (see ). Similarly, low-rank structure appears procedures including starting rank-1 barycenter matrix different centering schemes. Since low-rank matrices generally sparse visa-versa implemented splr S4 class, standing sparse plus low-rank matrices. class inherits Matrix class includes slots \\(n\\times n\\) sparse matrix x \\(n\\times d\\) dense matrices b, represent matrices form x + tcrossprod(, b). class implements efficient methods matrix multiplication operations exploit sparse low-rank structure matrices. Specifically, methods often require \\(O(\\|x\\|_0) + O(nd)\\) storage opposed \\(O(n^2)\\) required densely stored matrices, enjoy analogous computational advantages. users can also use matrices explicitly, use automatic within functions init_start center_graph matrices can largely used interchangeably matrices.","code":""},{"path":"/articles/iGraphMatch.html","id":"sssec:lap_methods","dir":"Articles","previous_headings":"Graph matching background > Auxiliary graph matching tools","what":"LAP methods","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"Multiple graph matching methods include solving LAP included multiple methods solving LAPs package. Specifically implement Jonker-Volgenant algorithm (Jonker Volgenant (1988)) dense cost matrices LAPMOD algorithm (Volgenant (1996)) sparse cost matrices. algorithms implemented C provide improved performance. LAPMOD approach typically advantageous number non-zero entries less 50%. also depend clue package solve_LSAP function implements Hungarian algorithm (Papadimitriou Steiglitz (1998)) solving LAP. methods can used independently specific graph matching method using do_lap function.","code":""},{"path":"/articles/iGraphMatch.html","id":"multi-layered-graph-matching","dir":"Articles","previous_headings":"Graph matching background > Auxiliary graph matching tools","what":"Multi-layered graph matching","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"Frequently, networks edges may categorical attributes categories, can construct multilayer graphs (Kivelä et al. (2014)), layer networks contains edges specific categories. matching two multilayer graphs, standard graph matching problem can extended \\(\\sum_{l=1}^{m}\\|^{(l)} - PB^{(l)}P^T\\|_F^2\\) \\(m\\) denotes number categories \\(^{(l)}, B^{(l)}\\) adjacency matrices \\(l\\)th layers graph. Note, assume layers aligned, layer \\(l\\) corresponds edge-types multi-layer networks. igraph object, function split_igraph can used convert single object categorical edge attributes list element containing edges specific attribute value. implemented algorithms can seamlessly match multi-layer graphs, encoded list either igraph objects matrix-like objects. also implemented matrixlist S4 class implements many standard matrix operations algorithms can easily extended work multilayer networks.","code":""},{"path":"/articles/iGraphMatch.html","id":"graph-models","dir":"Articles","previous_headings":"Graph matching background","what":"Correlated random graph models","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"correlated model (V. Lyzinski et al. (2016)) essential theoretical study graph matching algorithms. single graph, edge present graph independently probability \\(p\\). correlated model provides joint distribution pair graphs, graph marginally distributed graph corresponding edge-pairs correlated. sample pair correlated graphs edge probability \\(p\\), Pearson correlation \\(\\rho\\), first sample three independent graphs \\(G_1\\), \\(Z_0\\) \\(Z_1\\) edge probabilities \\(p\\), \\(p(1-\\rho)\\) \\(p+\\rho(1-p)\\) respectively. Let \\(G_2 = (Z_1 \\cap G_1) \\bigcup (Z_0\\cap G_1^c)\\). Yartseva Grossglauser (2013) provide alternative formulation correlated model. First, one samples single random graph \\(G\\) edge probability \\(p'\\). Conditioned \\(G\\), edge \\(G\\) present independently \\(G_1,G_2\\) probability \\(s'\\). two parameterizations related relationship \\(s'=p+\\rho(1-p)\\) \\(p'=p/(p+\\rho(1-p))\\). original parameterization slightly general allows possibility negative correlation. addition homogeneous correlated random graphs, also implement heterogeneous generalizations model. stochastic block model (Holland, Laskey, Leinhardt (1983)) random dot product graphs (RDPG) model (Young Scheinerman (2007)) can regarded extensions model. stochastic block model useful represent community structure graphs dividing graph \\(K\\) groups. node assigned group probability edges determined group memberships vertex pair. RDPG model, vertex assigned latent position \\(\\mathbb{R}^d\\) edge probabilities given inner product latent positions vertex pair. models, can consider correlated graph-pairs marginally arise one models corresponding edge pairs correlated.","code":""},{"path":"/articles/iGraphMatch.html","id":"sec:measure","dir":"Articles","previous_headings":"Graph matching background","what":"Measures for goodness of matching","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"ability assess quality match ground truth unavailable critical usage matching approaches. various topological criteria can applied measure quality matching results. graph level, frequently used structural measures include matching pairs (MP), edge correctness (EC), size largest common connected subgraph (LCCS) (Kuchaiev Przulj (2011)). MP counts number correctly matched pairs nodes, thus can used true alignment available. Global counts common edges (CE) common non-edges (CNE) can defined \\[\\begin{align*}     CE=\\frac{1}{2}\\sum_{,j}1\\{A_{ij}=PBP^T_{ij} =1\\}\\quad CNE=\\frac{1}{2}\\sum_{,j}1\\{A_{ij}=PBP^T_{ij} = 0\\}, \\end{align*}\\] along error counts extra edges (EE) missing edges (), \\[\\begin{align*}     EE=\\frac{1}{2}\\sum_{,j}1\\{A_{ij}=0=1 - PBP^T_{ij}\\}\\quad =\\frac{1}{2}\\sum_{,j}1\\{A_{ij}= 1 = 1 - PBP^T_{ij}\\}, \\end{align*}\\] EC measures percentage correctly aligned edges, fraction CE\\(/|E_1|\\). LCCS denotes largest subset aligned vertices corresponding induced subgraphs graph connected. Matches larger LCCS often preferable many isolated components. Another group criteria measures goodness matching vertex level. Informally, aim testing hypotheses \\[H_0^{(v)}: \\text{vertex } v \\text{ matched correctly } P^*, \\] \\[H_a^{(v)}: \\text{vertex } v \\text{ matched correctly } P^*\\] vertex \\(v\\). goal address permutation matrix found graph matching algorithm significantly different one sampled uniformly distributed permutation matrices (Vince Lyzinski Sussman (2017)). Unfortunately, vertex-level matching criteria received limited attention literature, however, include two test statistics measure fit. row difference statistic L\\(_1\\)-norm difference \\(\\) \\(P^*B{P^*}^T\\), namely \\[\\begin{equation*} T_d(v,P^*):=\\Vert A_{v\\cdot}-(P^*B{P^*}^T)_{v\\cdot}\\Vert_1. \\end{equation*}\\] Intuitively, correctly matched vertex \\(v\\) induce smaller \\(T_d(v,P^*)\\), unweighted graphs corresponds number edge disagreements induced matching \\(v\\). Alternatively, row correlation statistic defined \\[\\begin{equation*} T_c(v,P^*):=1 - corr(A_{v\\cdot},(P^*B{P^*}^T)_{v\\cdot}). \\end{equation*}\\] expect empirical correlation neighborhoods \\(v\\) \\(\\) \\(P^*B{P^*}^T\\) larger correctly matched vertex. employ permutation testing ideas raw statistics normalization across vertices. Let us take row difference statistic example. guiding intuition \\(v\\) correctly matched, number errors induced \\(P^*\\) across neighborhood \\(v\\) \\(\\) \\(B\\) (.e., \\(T_d(v, P^*)\\)) significantly smaller number errors induced randomly chosen permutation \\(P\\) (.e., \\(T_d(v, P)\\)). mind, let \\(\\mathbb{E}_P\\) \\(\\mathrm{Var}_P\\) denote conditional expectation variance raw statistic \\(P\\) uniformly sampled permutation matrices. normalization given \\[\\begin{equation*} T_p(v,P^*):=\\frac{T(v,P^*)-\\mathbb{E}_PT(v,P)}{\\sqrt{Var_PT(v,P)}} \\end{equation*}\\] \\(T(v, P)\\) can either two test statistics introduced earlier. addition measuring match quality, vertex-wise statistics can also serve tool find vertices valid match another network, .e. vertex entity present one network .","code":""},{"path":"/articles/iGraphMatch.html","id":"sec:usage","dir":"Articles","previous_headings":"","what":"R functions and usage","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"R package iGraphMatch offers versatile options graph matching subsequent analysis. describe usage package including sampling random correlated graph pairs, graph matching, evaluating matching results.","code":""},{"path":"/articles/iGraphMatch.html","id":"sampling-correlated-random-graph-pairs","dir":"Articles","previous_headings":"R functions and usage","what":"Sampling correlated random graph pairs","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"first illustrate usage functions sampling correlated random graph pairs. usage graph matching demonstrated graph-pairs sampled using methods. Functions form sample_correlated_*_pair sampling random graph pairs common syntax: argument n specifies number nodes graph, default options sample pair undirected graphs without self-loop whose true alignment identity. permutation argument can used permute vertex labels second graph. model parameters arguments vary according different random graph models typically consist parameters marginal graph distributions correlations corresponding edges. functions return named list two igraph objects. homogeneous correlated graph model, model parameters p, global edge probability, corr, Pearson correlation aligned vertex-pairs. example, sample pair graphs 5 nodes \\(\\mathrm{CorrER}(0.5J, 0.7J)\\) run Since didn’t obscure vertex correspondence assigning value permutation argument, underlying true alignment identity. general heterogeneous correlated graph model, one needs specify edge probability matrix Pearson correlation matrix. sample pair graphs heterogeneous correlated model 5 nodes graph, random edge probabilities Pearson correlations: Since default undirected graphs without self-loops, entries p c along diagonal effectively ignored. stochastic block model requires block--block edge probabilities stored pref.matrix argument block.sizes argument indicates size block, along Pearson correlation parameter corr. Next, sample pair graphs stochastic block model two blocks size 2 nodes 3 nodes respectively, within-group edge probabilities .7 .5, across-group edge probability .001, Pearson correlation equal .5. iGraphMatch package also provides functions sampling pair correlated random graphs junk vertices, .e vertices don’t true correspondence graph specifying number overlapping vertices argument ncore overlapping block sizes argument core.block.sizes. iGraphMatch package offers auxiliary tools centering graphs penalize incorrect matches well, implemented center_graph function syntax: first input either matrix-like igraph object. scheme argument specifies method centering graphs. Options include pair scalars entries adjacency matrix linearly rescaled minimum min(scheme) maximum max(scheme). Note, scheme = \"center\" scheme = c(-1, 1). Another option pass single integer, returned value adjacency matrix minus best rank-scheme approximation. last argument use_splr boolean indicating whether return splrMatrix object. use use_splr = FALSE better display matrices use_splr = TRUE often result improved performance, especially large sparse networks. , center sampled graph cgnp_g1 using different schemes: Users can use centered graphs inputs implemented graph matching algorithms, serve alter rewards penalties common edges, common non-edges, missing edges, extra edges.","code":"sample_correlated_*_pair(n, ***model parameters***,    permutation = 1:n, directed = FALSE, loops = FALSE) library(iGraphMatch) set.seed(1) cgnp_pair <- sample_correlated_gnp_pair(n = 5, corr = 0.7, p = 0.5) (cgnp_g1 <- cgnp_pair$graph1) ## IGRAPH f86cb0c U--- 5 4 -- Erdos-Renyi (gnp) graph ## + attr: name (g/c), type (g/c), loops (g/l), p (g/n) ## + edges from f86cb0c: ## [1] 1--2 2--3 2--5 3--5 cgnp_g1[] ## 5 x 5 sparse Matrix of class \"dgCMatrix\" ##                ## [1,] . 1 . . . ## [2,] 1 . 1 . 1 ## [3,] . 1 . . 1 ## [4,] . . . . . ## [5,] . 1 1 . . cgnp_g2 <- cgnp_pair$graph2 set.seed(123) p <- matrix(runif(5^2, .5, .8),5) c <- matrix(runif(5^2, .5, .8),5) ieg_pair <- sample_correlated_ieg_pair(n = 5, p_mat = p, c_mat = c) pm <- cbind(c(.7, .001), c(.001, .5)) sbm_pair <- sample_correlated_sbm_pair(n = 5, pref.matrix = pm,                                        block.sizes = c(2,3), corr = 0.5) center_graph(A, scheme = c(-1, 1), use_splr = TRUE) center_graph(cgnp_g1, scheme = \"center\", use_splr = FALSE) ## 5 x 5 Matrix of class \"dgeMatrix\" ##      [,1] [,2] [,3] [,4] [,5] ## [1,]   -1    1   -1   -1   -1 ## [2,]    1   -1    1   -1    1 ## [3,]   -1    1   -1   -1    1 ## [4,]   -1   -1   -1   -1   -1 ## [5,]   -1    1    1   -1   -1 center_graph(cgnp_g1, scheme = 2, use_splr = FALSE) ## 5 x 5 Matrix of class \"dgeMatrix\" ##        [,1]   [,2]   [,3] [,4]   [,5] ## [1,]  0.207  0.064 -0.093    0 -0.093 ## [2,]  0.064  0.020 -0.029    0 -0.029 ## [3,] -0.093 -0.029 -0.458    0  0.542 ## [4,]  0.000  0.000  0.000    0  0.000 ## [5,] -0.093 -0.029  0.542    0 -0.458"},{"path":"/articles/iGraphMatch.html","id":"graph-matching-methods","dir":"Articles","previous_headings":"R functions and usage","what":"Graph matching methods","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"graph matching methods share basic syntax: (#tab:gm-alg) Overview arguments different graph matching functions. first two arguments graph matching algorithms represent two networks can matrices, igraph objects, two lists either form case multi-layer matching. seeds argument contains prior information known partial correspondence two graphs. can vector logicals indices seed pairs indices graphs. general, seeds argument takes matrix data frame input two columns indicating indices seeds two graphs respectively. similarity parameter matrix similarity scores two vertex sets, larger scores indicating higher similarity. Notably, one careful different scales graph topological structure vertex similarity information order properly address relative importance part information. method argument specifies graph matching algorithm use, one can choose “indefinite” (default), “convex”, “PATH”, “percolation”, “IsoRank”, “Umeyama”, self-defined graph matching function enables users test algorithms remaining compatible package. method function, take least two networks, seeds similarity scores arguments. Users can also include additional arguments applicable. self-defined graph matching function return object “graphMatch” class matching correspondence, sizes two input graphs, matching details. illustrative example, graph_match_rand defines new graph matching function matches randomly permuting vertex label second graph using random seed rand_seed. apply self-defined GM method matching correlated graphs sampled earlier specified random seed: arguments vary different graph matching algorithms overview given Table \\(\\ref{tab:gm-alg}\\). start argument FW methodology “indefinite” “convex” relaxations takes \\(nns\\text{--}nns\\) matrix initialization method including “bari”, “rds” “convex”. represent initializing iterations specific matrix, barycenter, random doubly stochastic matrix, doubly stochastic solution “convex” method graphs, respectively. Moreover, sometimes access side information partial correspondence uncertainty. still treat prior information hard seeds pass seeds argument “indefinite” “convex” methods, incorrect information can yield unsatisfactory matching results. Instead, provide option soft seeding incorporating noisy partial correspondence initialization start matrix. core function used initializing start matrix versatile options init_start function. Suppose first two pairs nodes hard seeds another pair incorrect seed \\((3,4)\\) soft seeds: generate start matrix incorporating soft seeds initialized barycenter: alternative generate start matrix random doubly stochastic matrix incorporating soft seeds follow can initialize Frank-Wolfe iterations start matrix specifying start parameter. soft seeds, longer need initialize start matrix using init_start first. Instead can directly assign initialization method start argument gm function: use solution convex relaxation initialization indefinite relaxation. Now let’s match sampled pair graphs stochastic block model using Percolation algorithm. Apart common arguments graph matching algorithms, Percolation another argument representing minimum number matched neighbors required matching new qualified vertex pair. adopt default value 2. Also, least one similarity scores seeds required Percolation algorithm kick . Let’s utilize set hard seeds assume available prior information similarity scores. Without enough prior information partial correspondence, Percolation couldn’t find qualifying matches. Suppose addition current pair sampled graphs, sampled correlated homogeneous heterogeneous graphs different layers connectivity set vertices. can match nonseed vertices based topological information three graph layers. consistent, let’s still use Percolation algorithm threshold equal 2 set seeds. amount available prior information, now able match nodes correctly. Finally, give example matching multi-layers graphs using IsoRank algorithm. Unlike algorithm, similarity scores required IsoRank algorithm. Without information, adopt barycenter similarity matrix . Graph matching functions return object class “graphMatch” contains details matching results, including list matching correspondence, call graph matching function dimensions original two graphs. Additionally, “graphMatch” also returns list matching details corresponding specified method. Table \\(\\ref{tab:gm-value}\\) provides overview returned values different graph matching methods. seeds information, one can obtain node mapping non-seeds accordingly (#tab:gm-value) Overview return values different graph matching functions. “graphMatch” class object can also flexibly used matrix. addition returned list matching correspondence, one can obtain corresponding permutation matrix sparse form. Notably, multiplicity applicable “graphMatch” object directly without converting permutation matrix. enables obtaining permuted second graph, \\(PBP^T\\) simply ","code":"gm(A, B, seeds = NULL, similarity = NULL, method = \"indefinite\",    ***algorithm parameters***) graph_match_rand <- function(A, B, seeds = NULL,                               similarity = NULL, rand_seed){   totv1 <- nrow(A[[1]])   totv2 <- nrow(B[[1]])   nv <- max(totv1, totv2)    set.seed(rand_seed)   corr <- data.frame(corr_A = 1:nv,                       corr_B = c(1:nv)[sample(nv)])    graphMatch(     corr = corr,     nnodes = c(totv1, totv2),     detail = list(       rand_seed = rand_seed     )   ) }  match_rand <- gm(cgnp_g1, cgnp_g2,                   method = graph_match_rand, rand_seed = 123) hard_seeds <- 1:5 <= 2 soft_seeds <- data.frame(seed_A = 3, seed_B = 4) as.matrix(start_bari <- init_start(start = \"bari\", nns = 3,       ns = 2, soft_seeds = soft_seeds)) ##      [,1] [,2] [,3] ## [1,]  0.0    1  0.0 ## [2,]  0.5    0  0.5 ## [3,]  0.5    0  0.5 set.seed(1) as.matrix(start_rds <- init_start(start = \"rds\", nns = 3,       ns = 2, soft_seeds = soft_seeds)) ##      [,1] [,2] [,3] ## [1,] 0.00    1 0.00 ## [2,] 0.52    0 0.48 ## [3,] 0.48    0 0.52 match_rds <- gm(cgnp_g1, cgnp_g2, seeds = hard_seeds,                 method = \"indefinite\", start = \"rds\") set.seed(123) match_convex <- gm(cgnp_g1, cgnp_g2, seeds = hard_seeds,                    method = \"indefinite\", start = \"convex\") sbm_g1 <- sbm_pair$graph1 sbm_g2 <- sbm_pair$graph2 match_perco <- gm(sbm_g1, sbm_g1, seeds = hard_seeds,                    method = \"percolation\", r = 2) match_perco ## gm(A = sbm_g1, B = sbm_g1, seeds = hard_seeds, method = \"percolation\",  ##     r = 2) ##  ## Match (5 x 5): ##   corr_A corr_B ## 1      1      1 ## 2      2      2 matrix_lA <- list(sbm_g1, ieg_pair$graph1, cgnp_g1) matrix_lB <- list(sbm_g2, ieg_pair$graph2, cgnp_g2) match_perco_list <- gm(A = matrix_lA, B = matrix_lB, seeds = hard_seeds,                         method = \"percolation\", r = 2) match_perco_list ## gm(A = matrix_lA, B = matrix_lB, seeds = hard_seeds, method = \"percolation\",  ##     r = 2) ##  ## Match (5 x 5): ##   corr_A corr_B ## 1      1      1 ## 2      2      2 ## 3      3      3 ## 4      4      4 ## 5      5      5 set.seed(1) sim <- as.matrix(init_start(start = \"bari\", nns = 5,                              soft_seeds = hard_seeds)) match_IsoRank <- gm(A = matrix_lA, B = matrix_lB,                      seeds = hard_seeds, similarity = sim,                      method = \"IsoRank\", lap_method = \"LAP\") match_convex@corr ##   corr_A corr_B ## 1      1      1 ## 2      2      2 ## 3      3      5 ## 4      4      4 ## 5      5      3 match_convex@call ## gm(A = cgnp_g1, B = cgnp_g2, seeds = hard_seeds, method = \"indefinite\",  ##     start = \"convex\") match_convex@nnodes ## [1] 5 5 match_convex[!match_convex$seeds] ##   corr_A corr_B ## 3      3      5 ## 4      4      4 ## 5      5      3 match_convex[] ## 5 x 5 sparse Matrix of class \"dgCMatrix\" ##                ## [1,] 1 . . . . ## [2,] . 1 . . . ## [3,] . . . . 1 ## [4,] . . . 1 . ## [5,] . . 1 . . match_convex %*% cgnp_g2 ## IGRAPH 1c1fc37 UN-- 5 5 -- Erdos-Renyi (gnp) graph ## + attr: name_1 (g/c), name_2 (g/c), type_1 (g/c), type_2 (g/c), loops_1 ## | (g/l), loops_2 (g/l), p_1 (g/n), p_2 (g/n), name (g/c), type (g/c), ## | loops (g/l), p (g/n), name (v/n) ## + edges from 1c1fc37 (vertex names): ## [1] 5--3 2--5 2--3 1--5 1--2"},{"path":"/articles/iGraphMatch.html","id":"evaluation-of-goodness-of-matching","dir":"Articles","previous_headings":"R functions and usage","what":"Evaluation of goodness of matching","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"Along graph matching methodology, iGraphMatch many capabilities evaluating visualizing matching performance. matching two graphs, function summary can used get summary overall matching result terms commonly used measures including number matches, number correct matches, common edges, missing edges, extra edges objective function value. edge matching information stored data frame named edge_match_info. Note summary outputs number correct matches true correspondence known specifying true_label argument vector indicating true correspondence second graph. Applying summary function matching result match_convex true_label = 1:5, indicating true correspondence identity provides summaries. Applying summary function multi-layer graph matching result returns edge statistics layer. realistic scenarios, true correspondence available. introduced section \\(\\ref{sec:background}\\), user can use vertex level statistics evaluate match performance. best_matches function evaluates vertex-level metric returns sorted data.frame vertex-matches metrics. arguments two networks, specific measure use, number top-ranked vertex-matches output, matching correspondence second graph applicable. example , apply best_matches rank matches true underlying alignment Note, best_matches uses seed information match parameter outputs non-seed matches. Without true correspondence, true_label take default value output data frame contains first three columns. visualize matches smaller graphs, function plot displays edge discrepancies two matched graphs adjacency matrix ball--stick plot, depending input format two graphs. Match visualizations. Grey, blue, red colors indicate common edges, missing edges present first network, extra edges present second network, respectively. plots visualizing matching performance match_convex shown Figure @ref(fig:visualization). Grey edges pixels indicate common edges, red ones indicate edges second graph. present, blue pixels edges represent missing edges exist first graph. corresponding linetypes solid, short dash, long dash.","code":"summary(match_convex, cgnp_g1, cgnp_g2, true_label = 1:5) ## Call: gm(A = cgnp_g1, B = cgnp_g2, seeds = hard_seeds, method = \"indefinite\",  ##     start = \"convex\") ##  ## # Matches: 3 ## # True Matches:  1, # Seeds:  2, # Vertices:  5, 5 ##                    ##   common_edges 4.0 ##  missing_edges 0.0 ##    extra_edges 1.0 ##          fnorm 1.4 summary(match_IsoRank, matrix_lA, matrix_lB) ## Call: gm(A = matrix_lA, B = matrix_lB, seeds = hard_seeds, similarity = sim,  ##     method = \"IsoRank\", lap_method = \"LAP\") ##  ## # Matches: 3, # Seeds:  2, # Vertices:  5, 5 ##          layer   1   2   3 ##   common_edges 2.0 6.0 4.0 ##  missing_edges 0.0 1.0 0.0 ##    extra_edges 1.0 0.0 1.0 ##          fnorm 1.4 1.4 1.4 best_matches(cgnp_g1, cgnp_g2, match = match_convex,               measure = \"row_perm_stat\", num = 3,               true_label = 1:igraph::vcount(cgnp_g1)) ##   A_best B_best measure_value precision ## 1      4      4          -1.4      1.00 ## 2      3      5          -1.2      0.50 ## 3      5      3          -1.2      0.33 plot(cgnp_g1, cgnp_g2, match_convex) plot(cgnp_g1[], cgnp_g2[], match_convex)"},{"path":"/articles/iGraphMatch.html","id":"sec:example","dir":"Articles","previous_headings":"","what":"Examples","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"section, demonstrate graph matching analysis using iGraphMatch via examples real datasets, including communication networks, neuronal networks, transportation networks. Table @ref(tab:dataset-overview) presents brief overviews first two datasets. Note number edges doesn’t consider weights weighted graphs, directed graphs, edge node \\(\\) node \\(j\\) another edge \\(j\\) \\(\\) counted two edges. Tables @ref(tab:edge-summary) @ref(tab:edge-summary-trans) summarize edge correspondence two graphs true alignment including number common edges, missing edges, extra edges two graphs. first Enron email network example, demonstrate usage Frank-Wolfe methodology improve matching performance using centering technique incorporating adaptive seeds. second example using C. Elegans synapses networks, illustrate use soft matching challenging graph matching task using Frank-Wolfe methodology, PATH algorithm IsoRank algorithm. Finally, include example matching two multi-layer graphs similarity scores Britain transportation networks. Overview Enron C. Elegans graphs. Edge summary true alignments Enron C. Elegans graphs. columns indicate number common edges, missing edges \\(G_1\\), extra edges \\(G_2\\). weighted graphs, define pair corresponding edges common edge long positive weights.","code":""},{"path":"/articles/iGraphMatch.html","id":"sec:Enron","dir":"Articles","previous_headings":"Examples","what":"Example: Enron Email Network Data","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"Enron email network data originally made public Federal Energy Commission investigation Enron Corporation (Leskovec et al. (2008)).  node Enron network represents email address least one email sent one address another address, directed edge exists corresponding nodes. iGraphMatch package includes Enron email network data form pair igraph objects derived original data graph represents one week emails 184 email addresses. two networks unweighted directed edge densities around 0.01 graph empirical correlation two graphs 0.85. First, let’s load packages required following analysis:","code":"library(igraph) library(iGraphMatch) library(purrr) library(dplyr)"},{"path":"/articles/iGraphMatch.html","id":"visualization-of-enron-networks","dir":"Articles","previous_headings":"Examples > Example: Enron Email Network Data","what":"Visualization of Enron networks","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"visualize aligned Enron networks using function vertices sorted community detection algorithm (Clauset, Newman, Moore (2004)) degree. detailed interpretations figure @ref(fig:Enron-graph), please refer figure @ref(fig:visualization). Asymmetric adjacency matrices aligned Enron Corporation communication networks. vertices sorted community detection algorithm (Clauset, Newman, Moore (2004)) degree. Note 37 32 total 184 nodes isolated nodes two graphs respectively, indicating corresponding employees haven’t sent received emails employees. adds difficulty matching since ’s impossible distinguish isolated nodes based topological structure alone. first keep largest connected component graph. sizes largest connect components two graphs 146 151, different. reorder two graphs first 145 nodes aligned common graphs.","code":"g <- igraph::as.undirected(Enron[[1]]) com <- igraph::membership(igraph::cluster_fast_greedy(g)) deg <- rowSums(as.matrix(g[])) ord <- order(max(deg)*com+deg) plot(Enron[[1]][][ord,ord], Enron[[2]][][ord,ord]) vid1 <- which(largest_cc(Enron[[1]])$keep) vid2 <- which(largest_cc(Enron[[2]])$keep)  vinsct <- intersect(vid1, vid2)  v1 <- setdiff(vid1, vid2) v2 <- setdiff(vid2, vid1) A <- Enron[[1]][][c(vinsct, v1), c(vinsct, v1)] B <- Enron[[2]][][c(vinsct, v2), c(vinsct, v2)]"},{"path":"/articles/iGraphMatch.html","id":"matching-largest-connected-components-using-fw-algorithm","dir":"Articles","previous_headings":"Examples > Example: Enron Email Network Data","what":"Matching largest connected components using FW Algorithm","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"Let’s assume Enron email communication network second week anonymous, aim finding alignment email addresses first network second one de-anonymize latter. Additionally, want find email addresses active months. Suppose prior information partial alignment available example. match two largest connected components using FW algorithm indefinite relaxation since seeds similarity scores mandatory method. Without prior information, arguments take default values . argument, assign equal likelihood possible matches initializing barycenter. Since two graphs different sizes, function automatically pads smaller graph extra 0’s. , check summary matching performance terms matched nodes, matched edges graph matching objective function. example, can evaluate matching result based statistics matched edges. Without seeds similarity scores, around 72% edges correctly matched.","code":"set.seed(1) match_FW <- gm(A = A, B = B, start = \"bari\", max_iter = 200) head(match_FW) ##   corr_A corr_B ## 1      1     27 ## 2      2      2 ## 3      3     30 ## 4      4      4 ## 5      5      5 ## 6      6      6 summary(match_FW, A, B) ## Call: gm(A = A, B = B, start = \"bari\", max_iter = 200) ##  ## # Matches: 151, # Seeds:  0, # Vertices:  146, 151 ##                    ##   common_edges 353 ##  missing_edges 134 ##    extra_edges 128 ##          fnorm  16"},{"path":"/articles/iGraphMatch.html","id":"centering-the-larger-graph","dir":"Articles","previous_headings":"Examples > Example: Enron Email Network Data","what":"Centering the larger graph","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"can try improve performance centering B assigning -1 non-edges, penalize edges missing B present . summary tables, prefer matching Enron networks application centering scheme, since get matched common edges, well fewer missing edges extra edges.","code":"A_center <- center_graph(A = A, scheme = \"naive\", use_splr = TRUE) B_center <- center_graph(A = B, scheme = \"center\", use_splr = TRUE) set.seed(1) match_FW_center <- gm(A = A_center, B = B_center,                             start = \"bari\", max_iter = 200) summary(match_FW_center, A, B) ## Call: gm(A = A_center, B = B_center, start = \"bari\", max_iter = 200) ##  ## # Matches: 151, # Seeds:  0, # Vertices:  146, 151 ##                    ##   common_edges 396 ##  missing_edges  91 ##    extra_edges  85 ##          fnorm  13"},{"path":"/articles/iGraphMatch.html","id":"matching-with-adaptive-seeds","dir":"Articles","previous_headings":"Examples > Example: Enron Email Network Data","what":"Matching with adaptive seeds","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"Supposing access ground truth, use function measure rank vertex-wise matching performance. shows 6 matches minimize row permutation statistic. Since seeded graph matching enhances graph matching performance substantially (Vince Lyzinski, Fishkind, Priebe (2014)), may useful use best matches seeds improve matching results. , use adaptive seeds, taking \\(ns\\) best matches using seeds second run matching algorithm. table displays edge statistics objective function values different number adaptive seeds used. second column table shows matching precision adaptive seeds based ground truth. Incorporating adaptive seeds repeating FW matching procedure centered graphs improve matching results, compared case without adaptive seeds \\(ns=0\\). first 40 pairs matched nodes ranked function correctly matched, also matching improved . number adaptive seeds increases, precision adaptive seeds decreases. Note treated hard seeds, incorrect matches remain matched set might cause cascade errors. alternative way treat top-ranked matches soft seeds embedded start matrix handle uncertainty. way, adaptive seeds provide prior information also evolve iterations. table shows soft seeding approach always outperforms performs good hard seeding approach regardless number adaptive seeds used.","code":"bm <- best_matches(A = A, B = B, match = match_FW_center,               measure = \"row_perm_stat\") head(bm) ##      A_best B_best measure_value ## V83      65     65         -40.6 ## V75      57     57          -3.4 ## V147    115    115          -3.2 ## V59      43     43          -2.9 ## V64      48     48          -2.3 ## V51      36     36          -1.9 match_w_hard_seeds <- function(ns){   seeds_bm <- head(bm, ns)   precision <- mean(seeds_bm$A_best == seeds_bm$B_best)   match_FW_center_seeds <- gm(A = A_center, B = B_center,                            seeds = seeds_bm, similarity = NULL,                            start = \"bari\", max_iter = 100)   edge_info <- summary(match_FW_center_seeds, A, B)$edge_match_info   cbind(ns, precision, edge_info) } set.seed(12345) map_dfr(seq(from = 0, to = 80, by = 20), match_w_hard_seeds) match_w_soft_seeds <- function(ns){   seeds_bm <- head(bm, ns)   precision <- mean(seeds_bm$A_best == seeds_bm$B_best)   start_soft <- init_start(start = \"bari\",                             nns = max(dim(A)[1], dim(B)[1]),                             soft_seeds = seeds_bm)   match_FW_center_soft_seeds <- gm(A = A_center, B = B_center,                             start = start_soft, max_iter = 100)   edge_info <- summary(match_FW_center_soft_seeds, A, B)$edge_match_info   cbind(ns, precision, edge_info) } set.seed(12345) map_dfr(seq(from = 0, to = 80, by = 20), match_w_soft_seeds)"},{"path":"/articles/iGraphMatch.html","id":"core-vertices-detection","dir":"Articles","previous_headings":"Examples > Example: Enron Email Network Data","what":"Core vertices detection","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"function can also used detect core vertices. Suppose ground truth known first 145 vertices core vertices. mean precision detecting core vertices junk vertices using function displayed figure \\(\\ref{fig:core}\\). lower rank stronger indicator core vertex higher rank stronger indicator junk vertex. Let \\(r^C_i, 1\\le \\le n_c\\) \\(r^J_j, 1\\le j\\le n_j\\) denote ranks associated core vertex junk vertex. figure shows precision identifying core vertices low rank \\(r\\), .e. \\(\\frac{1}{r}\\sum_{= 1}^{n_c}1_{r^C_i\\le r}\\), precision identifying junk vertices high rank \\(r\\), .e. \\(\\frac{1}{r}\\sum_{j = 1}^{n_j}1_{r^J_j\\ge n_c+n_j-r}\\), separated vertical lines. Core detection performance substantially better chance, represented dotted horizontal lines. top 88 core vertices indicating good overall performance core identification. junk identification, junk vertices ranked 63, 62, 61, 49, 15, 10 according lowest score, indicating junk vertices difficult identify. Mean precision identifying core junk vertices Enron networks using row permutation test. vertical lines separate performance identifying core vertices low ranks junk vertices high ranks. horizontal lines indicate performance random classifier.","code":"nc <- length(vinsct) nj <- max(length(v1), length(v2)) core_precision <- 1:nc %>% map_dbl(~mean(bm$A_best[1:.x]<=nc)) junk_precision <- 1:nj %>% map_dbl(~mean(bm$A_best[(nc+.x):(nc+nj)]>nc))"},{"path":"/articles/iGraphMatch.html","id":"sec:CE","dir":"Articles","previous_headings":"Examples","what":"Example: C. Elegans Network Data","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"C. Elegans networks consist chemical synapses network electrical synapses network roundworm, 279 nodes represents neuron edge represents intensity synapse connections two neurons (Chen et al. (2015)). Matching chemical synapses network electrical synapses network essential understanding brain functions. networks quite sparse edge densities 0.03 0.01 graph empirical correlation two graphs 0.1.","code":""},{"path":"/articles/iGraphMatch.html","id":"a-challenging-task","dir":"Articles","previous_headings":"Examples > Example: C. Elegans Network Data","what":"A challenging task","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"simplicity, made networks unweighted undirected experiments, assume ground truth known identity. Edge discrepancies matched graphs true correspondence (left) FW algorithm starting true correspondence (right). Green pixels represents edge chemical graph edge electrical graph. Red pixels represent edge electrical graph. Grey pixels represent edge graphs white represents edge graphs. Matching C. Elegans networks challenging task. Figures @ref(fig:C-Elegans-edge) depict edge discrepancies two networks true alignment matching correspondence using FW algorithm initialized true alignment. alignment found using FW identity 124 279 nodes correctly matched improves upon identity terms number edge discrepancies. true alignment, 116 edge errors 1380 common edges alignment yielded FW initialized true correspondence 267.5 edge errors 1078 common edges. Hence, graph matching object solution true alignment. One can try use objective functions enhance matching result, however investigate . Overall, performance measures poor, results illustrate spectrum challenges graph matching.","code":"C1 <- C.Elegans[[1]][] > 0 C2 <- C.Elegans[[2]][] > 0 plot(C1[], C2[]) match <- gm(C1, C2, start = Matrix::Diagonal(nrow(C1))) plot(C1[], C2[], match) nv <- nrow(C1) id_match <- graphMatch(data.frame(corr_A = 1:nv, corr_B = 1:nv), nv) i_sum <- summary(id_match, C.Elegans[[1]], C.Elegans[[2]]) m_sum <- summary(match, C.Elegans[[1]], C.Elegans[[2]], id_match) i_emi <- i_sum$edge_match_info m_emi <- m_sum$edge_match_info"},{"path":"/articles/iGraphMatch.html","id":"soft-matching-map3","dir":"Articles","previous_headings":"Examples > Example: C. Elegans Network Data","what":"Soft matching: MAP@3","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"Considering matching C. Elegans graphs quite challenging, let’s assume 20 pairs vertices known seeds, chosen random. Accordingly, generate similarity matrix 1’s corresponding seeds, rest barycenter. addition one--one matching, also conduct soft matching, find three promising matches non-seed vertex. achieve goal soft matching finding top 3 largest values row doubly stochastic matrix last iteration Frank Wolfe methodology indefinite relaxation PATH algorithm, well normalized matrix last iteration power method IsoRank algorithm. evaluate matching performance, look matching precision: \\(precision=\\frac{1}{n_m-s}\\sum_{\\V_m\\setminus S}P_{ii}\\), Mean Average Precision @ 3 (MAP@ 3):\\(MAP@3 = \\frac{1}{n_m-s}\\sum_{\\V_m\\setminus S}1_{\\{\\T_i\\}}\\), \\(T_i\\) set 3 promising matches node \\(\\). MAP@ 3 slightly higher precision method. Soft matching provides alternative way matching generating set promising matching candidates.","code":"seeds <- sample(nrow(C1), 20) sim <- init_start(start = \"bari\", nns = nrow(C1), soft_seeds = seeds) set.seed(123) m_FW <- gm(A = C1, B = C2, seeds = seeds,             similarity = sim, method = \"indefinite\",            start = \"bari\", max_iter = 100) m_PATH <- gm(A = C1, B = C2, seeds = seeds,              similarity = NULL, method = \"PATH\",              epsilon = 1, tol = 1e-05) m_Iso <- gm(A = C1, B = C2, seeds = seeds,              similarity = as.matrix(sim), method = \"IsoRank\",              max_iter = 50, lap_method = \"LAP\") match_eval <- function(match){   precision <- mean(match$corr_A == match$corr_B)    order <- apply(match$soft, MARGIN = 1, FUN = order, decreasing = TRUE)   top3 <- t(order[1:3,]) - 1:ncol(order)    MAP3 <- mean(apply(top3, MARGIN = 1, FUN = function(v){0 %in% v}))      round(data.frame(precision, MAP3),4) }  sapply(list(m_FW, m_PATH, m_Iso), match_eval) %>%    knitr::kable(col.names = c(\"Frank Wolfe\", \"PATH\", \"IsoRank\"),                 booktabs = TRUE, digits = 2)"},{"path":"/articles/iGraphMatch.html","id":"sec:Transp","dir":"Articles","previous_headings":"Examples","what":"Example: Britain Transportation Network","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"demonstrate matching multi-layer networks-layers, consider two graphs derived Britain Transportation network (Riccardo Marc (2015)). network reflects transportation connections UK, five layers representing ferry, rail, metro, coach, bus. smaller template graph constructed based random walk starting randomly chosen hub node, node connections layers. template graph 53 nodes 56 connections total induced subgraph original graph. Additionally, based filter methods , authors paper also provided list candidate matches template node, true correspondence guaranteed among candidates. number candidates ranges 3 1059 , average 241 candidates template vertex. Thus, made induced subgraph transportation network candidates, gave us world graph 2075 vertices 8368 connections. Figure \\(\\ref{Fig:trans_net}\\) visualizes transportation connections induced subgraphs, means transportation represented different colors. Note edges template common edges shared two graphs, 40%, 24.1%, 37.5%, 31.7% 25.6% edges world graph template layer. graphs unweighted, directed, self-loops. Tables @ref(tab:edge-summary-trans) displays overview edge summary regarding layer Britain Transportation Network. true correspondence exists template vertex world graph, goal locate template vertex Britain Transportation network matching two multi-layer graphs different number vertices. Overview Britain Transportation Network layers. Correlation calculted using template graph aligned induced subgraph world graph. final three columns indicate number common edges, missing edges, extra edges aligned subgraph world graph. Visualization template graph (left) world graph (right) corresponding vertices, derived Britain Transportation network five layers: ferry, rail, metro, coach, bus. Edges represent transportation transactions color indicates different means transportation different layer network. Based candidates, specify start matrix row-stochastic can used argument graph matching function FW methodology. row node, value either zero inverse number candidates node. ensure template nodes get matched candidates, constructed similarity score matrix taking start matrix \\(\\times 10^5\\), high similarity score assigned template-candidate pairs. match template graph world graph using Percolation algorithm. template graph stored world graph lists 5 matrices dimensions 53 2075 respectively. Since information seeds, assign argument, Percolation algorithm initialize mark matrix using prior information similarity score matrix. function outputs edge statistics objective function values layer separately. improve matching performance, one can replicate analysis first example Enron dataset, using centering scheme adaptive seeds. Finally, one can refer match report compare matching performance pick best one.","code":"tm <- Transportation[[1]] cm <- Transportation[[2]] candidate <- Transportation[[3]] match <- gm(A = tm, B = cm, similarity = similarity,              method = \"percolation\", r = 4) summary(match, tm, cm) ## Call: gm(A = tm, B = cm, similarity = similarity, method = \"percolation\",  ##     r = 4) ##  ## # Matches: 53, # Seeds:  0, # Vertices:  53, 2075 ##          layer    1    2    3    4    5 ##   common_edges 10.0 13.0  9.0 11.0 10.0 ##  missing_edges  0.0  1.0  0.0  2.0  0.0 ##    extra_edges 22.0 36.0 21.0 24.0 35.0 ##          fnorm  4.7  6.1  4.6  5.1  5.9"},{"path":"/articles/iGraphMatch.html","id":"sec:conclusion","dir":"Articles","previous_headings":"","what":"Conclusions","title":"`iGraphMatch`: an R Package for the Analysis of Graph Matching","text":"work, detail methods usage R package iGraphMatch finding assessing alignment vertex sets two edge-correlated graphs. package implements common steps analysis graph matching: seamless matching generalized graphs, evaluation matching performance, visualization. graph matching methodologies, provide versatile options form input graphs specification available prior information. discussion section \\(\\ref{sec:example}\\), demonstrate broad functionality flexibility package analyzing diverse graph matching problems real data step step. package also provides tools simulating correlated graphs can used development enhancement graph matching methods. Methods graph matching still active development. plan include novel methods field continues develop. short term looking introduce suite additional matching methods recently proposed literature. One biggest challenges graph matching evaluating quality match, especially vertex level. received minimal attention previous literature. provide measures goodness matching vertex level demonstrate effectiveness empirically. baseline methods implement permutation testing framework assessing matches can readily extended metrics. primary authors package Vince Lyzinski, Zihuan Qiao, Daniel Sussman. Joshua Agterberg, Lujia Wang, Yixin Kong also provided important contributions. also want thank users, especially Youngser Park, feedback patience continue develop package. work supported part grants DARPA (FA8750-20-2-1001 FA8750-18-0035) MIT Lincoln Labs.","code":""},{"path":[]},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Daniel Sussman. Author, maintainer. Zihuan Qiao. Author. Joshua Agterberg. Contributor. Lujia Wang. Contributor. Vince Lyzinski. Contributor.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Sussman D, Qiao Z (2024). iGraphMatch: Tools Graph Matching. R package version 2.0.4.9000, https://dpmcsuss.github.io/iGraphMatch/, https://github.com/dpmcsuss/iGraphMatch.","code":"@Manual{,   title = {iGraphMatch: Tools for Graph Matching},   author = {Daniel Sussman and Zihuan Qiao},   year = {2024},   note = {R package version 2.0.4.9000, https://dpmcsuss.github.io/iGraphMatch/},   url = {https://github.com/dpmcsuss/iGraphMatch}, }"},{"path":"/index.html","id":"igraphmatch","dir":"","previous_headings":"","what":"Tools for Graph Matching","title":"Tools for Graph Matching","text":"iGraphMatch R package graph matching. package works igraph objects matrix objects. provide adjacency matrices two graphs information might know, choose graph matching method, returns graph matching results. iGraphMatch also provides bunch useful functions might need process graph matching.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Tools for Graph Matching","text":"package still development. dev branch package might stable. can installed via devtools ","code":"# install.packages(\"devtools\") devtools::install_github(\"dpmcsuss/iGraphMatch\") # install.packages(\"devtools\") devtools::install_github(\"dpmcsuss/iGraphMatch\", ref = \"dev\")"},{"path":"/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Tools for Graph Matching","text":"installation, recommend loading igraph first.","code":"library(igraph) library(iGraphMatch)"},{"path":"/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Tools for Graph Matching","text":"Documentation can found via help R https://dpmcsuss.github.io/iGraphMatch/.","code":""},{"path":"/index.html","id":"author-and-contributors","dir":"","previous_headings":"","what":"Author and Contributors","title":"Tools for Graph Matching","text":"primary authors package Vince Lyzinski, Zihuan Qiao, Daniel Sussman. Joshua Agterberg, Lujia Wang, Yixin Kong also provided important contributions. also want thank users, especially Youngser Park, feedback patience continue develop package.","code":""},{"path":"/index.html","id":"support","dir":"","previous_headings":"","what":"Support","title":"Tools for Graph Matching","text":"work supported part grants DARPA (FA8750-20-2-1001 FA8750-18-0035) MIT Lincoln Labs.","code":""},{"path":"/reference/C.Elegans.html","id":null,"dir":"Reference","previous_headings":"","what":"Chemical synapses and electrical synapses networks of roundworm — C.Elegans","title":"Chemical synapses and electrical synapses networks of roundworm — C.Elegans","text":"C.Elegans networks consist chemical synapses network electrical synapses network roundworm, 279 nodes represents neuron edge represents intensity synapses connections two neurons.","code":""},{"path":"/reference/C.Elegans.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chemical synapses and electrical synapses networks of roundworm — C.Elegans","text":"","code":"data(C.Elegans)"},{"path":"/reference/C.Elegans.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Chemical synapses and electrical synapses networks of roundworm — C.Elegans","text":"object class list length 2.","code":""},{"path":"/reference/C.Elegans.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chemical synapses and electrical synapses networks of roundworm — C.Elegans","text":"Two networks weighted directed graphs self-loops. 2194 1031 edges two graphs respectively empirical Pearson's correlation two graphs 0.17. Two networks stored list form igraph objects, first network list chemical synapses network one electrical synapses network.","code":""},{"path":"/reference/C.Elegans.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Chemical synapses and electrical synapses networks of roundworm — C.Elegans","text":"Chen, L., Vogelstein, J. T., Lyzinski, V., & Priebe, C. E. (2016). joint graph inference case study: C. elegans chemical electrical connectomes. Worm, 5(2), e1142041. Sulston, J. E., Schierenberg, E., White, J. G., & Thomson, J.N. (1983). embryonic cell lineage nematode caenorhabditis  elegans. Developmental biology, 100(1):64–119.","code":""},{"path":"/reference/C.Elegans.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chemical synapses and electrical synapses networks of roundworm — C.Elegans","text":"","code":"data(C.Elegans) g1 <- C.Elegans[[1]] g2 <- C.Elegans[[2]] plot(g1, g2)"},{"path":"/reference/Enron.html","id":null,"dir":"Reference","previous_headings":"","what":"Email communication networks of Enron Corporation — Enron","title":"Email communication networks of Enron Corporation — Enron","text":"Enron network data consists email messages 184 employees Enron Corporation graph represents one week emails edge indicates whether email sent one employee .","code":""},{"path":"/reference/Enron.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Email communication networks of Enron Corporation — Enron","text":"","code":"data(Enron)"},{"path":"/reference/Enron.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Email communication networks of Enron Corporation — Enron","text":"object class list length 2.","code":""},{"path":"/reference/Enron.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Email communication networks of Enron Corporation — Enron","text":"Two networks unweighted directed self-loops. 488 482 edges two networks respectively empirical Pearson's correlation two graphs 0.85. Two email communication networks two different weeks stored list form igraph objects.","code":""},{"path":"/reference/Enron.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Email communication networks of Enron Corporation — Enron","text":"Originally released William Cohen CMU. details origins research uses dataset.","code":""},{"path":"/reference/Enron.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Email communication networks of Enron Corporation — Enron","text":"","code":"data(Enron) g1 <- Enron[[1]] g2 <- Enron[[2]] plot(g1, g2)"},{"path":"/reference/Transportation.html","id":null,"dir":"Reference","previous_headings":"","what":"Britain Transportation Network — Transportation","title":"Britain Transportation Network — Transportation","text":"Britain Transportation Network reflects transportation connections UK, five layers representing ferry, rail, metro, coach, bus.","code":""},{"path":"/reference/Transportation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Britain Transportation Network — Transportation","text":"","code":"data(Transportation)"},{"path":"/reference/Transportation.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Britain Transportation Network — Transportation","text":"list length 3, corresponding template graph, world graph, candidate data frame first column indicating template node ID's second column indicating world node ID's. template graph world graph stored lists five adjacency matrices, representing ferry, rail, metro, coach, bus transportation connections respectively.","code":""},{"path":"/reference/Transportation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Britain Transportation Network — Transportation","text":"data consists smaller template graph 53 nodes 56 connections across five layers, larger world graph candidates template graph 2075 nodes 8368 connections, list candidate matches template node, true correspondence guaranteed among candidates. template graph constructed based random walk starting randomly chosen hub node, node connections layers. edges template common edges shared two graphs, 40%, 24.1%, 37.5%, 31.7% 25.6% edges world graph template layer. graphs unweighted, directed, self-loops.","code":""},{"path":"/reference/Transportation.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Britain Transportation Network — Transportation","text":"Gallotti, R., Barthelemy, M. (2015). multilayer temporal network public transport Great Britain. Sci Data 2, 140056 . https://doi.org/10.1038/sdata.2014.56. J. D. Moorman, Q. Chen, T. K. Tu, Z. M. Boyd . L. Bertozzi, (2018). Filtering Methods Subgraph Matching Multiplex Networks. 2018 IEEE International Conference Big Data (Big Data), pp. 3980-3985, doi: 10.1109/BigData.2018.8622566.","code":""},{"path":[]},{"path":"/reference/Transportation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Britain Transportation Network — Transportation","text":"","code":"tm <- Transportation[[1]] cm <- Transportation[[2]] candidate <- Transportation[[3]] tn <- nrow(tm[[1]]) wn <- nrow(cm[[1]]) similarity <- with(candidate, Matrix::sparseMatrix(i = tem, j = wor, x = 1,                             dims = c(tn,wn)))"},{"path":"/reference/as.character.splrMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"splr ","title":"splr ","text":"splr \"Matrix\" character","code":""},{"path":"/reference/as.character.splrMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"splr ","text":"","code":"# S3 method for splrMatrix as.character(x, ...)"},{"path":"/reference/as.character.splrMatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"splr ","text":"x splrMatrix","code":""},{"path":"/reference/as.character.splrMatrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"splr ","text":"character output splr matrix","code":""},{"path":"/reference/best_matches.html","id":null,"dir":"Reference","previous_headings":"","what":"Rank best matches — best_matches","title":"Rank best matches — best_matches","text":"Rank vertex-pairs  order goodness matching metric","code":""},{"path":"/reference/best_matches.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rank best matches — best_matches","text":"","code":"best_matches(A, B, match, measure, num = NULL, true_label = NULL)"},{"path":"/reference/best_matches.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rank best matches — best_matches","text":"matrix, igraph object, list either. See check_graph B matrix, igraph object, list either. See check_graph match graphMatch, eg result call gm measure One \"row_cor\", \"row_diff\", \"row_perm_stat\" function (see details). Measure computing goodness matching. num positive integer NULL. Number pairs best matched vertices needed. NULL indicates matches. true_label true correspondence (available).","code":""},{"path":"/reference/best_matches.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rank best matches — best_matches","text":"best_matches returns data frame indices best   matched vertices \\(G_1\\) named A_best, indices best   matched vertices \\(G_2\\) named B_best values measure   best matches, smaller values indicate better matches   measures. true correspondence available, also returns   precision top n best matches, n <= num. row_cor takes 1 minus row correlation value corresponding vertex. row_diff takes row difference value corresponding vertex. row_perm_stat uses row permutation statistics value.","code":""},{"path":"/reference/best_matches.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rank best matches — best_matches","text":"measure function, take exactly two matrices igraph    objects arguments return vector length equal number nonseed nodes    first object. Smaller values taken indicate better matches.","code":""},{"path":"/reference/best_matches.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rank best matches — best_matches","text":"","code":"cgnp_pair <- sample_correlated_gnp_pair(n = 50, corr =  0.5, p =  0.5) g1 <- cgnp_pair$graph1 g2 <- cgnp_pair$graph2 seeds <- 1:50 <= 10 match <- gm(g1, g2, seeds, method = \"indefinite\")  # Application: select best matched seeds from non seeds as new seeds, and do the # graph matching iteratively to get higher matching accuracy best_matches(A = g1, B = g2, match = match, measure = \"row_perm_stat\", num = 5, true_label = 1:50) #>   A_best B_best measure_value precision #> 1     11     11     -5.601861         1 #> 2     28     28     -5.287778         1 #> 3     19     19     -4.955661         1 #> 4     34     34     -4.650679         1 #> 5     45     45     -4.650547         1"},{"path":"/reference/center_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Center adjacency matrix — center_graph","title":"Center adjacency matrix — center_graph","text":"Center adjacency matrix re-weighting edges according specified scheme","code":""},{"path":"/reference/center_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Center adjacency matrix — center_graph","text":"","code":"center_graph(A, scheme = c(-1, 1), use_splr = TRUE)"},{"path":"/reference/center_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Center adjacency matrix — center_graph","text":"matrix, igraph object. Adjacency matrix. scheme character vector, number pair numbers. Default c(-1, 1). See Details. use_splr boolean indicating whether use splrMatrix object storing centered graph.  Defaults TRUE.","code":""},{"path":"/reference/center_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Center adjacency matrix — center_graph","text":"centered adjacency matrix splrMatrix  useSplr = TRUE, otherwise Matrix object.","code":""},{"path":"/reference/center_graph.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Center adjacency matrix — center_graph","text":"options scheme \"naive\" Returns original Integer: Returns \\(- A_{scheme}\\)    \\(A_{scheme}\\) best rank-scheme approximation    . pair scalars: Returns s * +    minimum returned matrix min(scheme)    maximum max(scheme). \"center\": scheme=c(-1,1)","code":""},{"path":"/reference/center_graph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Center adjacency matrix — center_graph","text":"","code":"A <- sample_correlated_gnp_pair(n = 10, corr = .5, p = .5)$graph1 center_graph(A, scheme = \"naive\") #> 10 x 10 sparse Matrix of class \"dgCMatrix\" #>                           #>  [1,] . 1 . 1 1 . 1 . . . #>  [2,] 1 . . . . . . 1 1 1 #>  [3,] . . . 1 . 1 1 . . 1 #>  [4,] 1 . 1 . . . 1 . 1 . #>  [5,] 1 . . . . . 1 1 . 1 #>  [6,] . . 1 . . . . 1 . . #>  [7,] 1 . 1 1 1 . . 1 . 1 #>  [8,] . 1 . . 1 1 1 . 1 1 #>  [9,] . 1 . 1 . . . 1 . 1 #> [10,] . 1 1 . 1 . 1 1 1 . center_graph(A, scheme = \"center\") #> Sparse part #> 10 x 10 sparse Matrix of class \"dgCMatrix\" #>                           #>  [1,] . 2 . 2 2 . 2 . . . #>  [2,] 2 . . . . . . 2 2 2 #>  [3,] . . . 2 . 2 2 . . 2 #>  [4,] 2 . 2 . . . 2 . 2 . #>  [5,] 2 . . . . . 2 2 . 2 #>  [6,] . . 2 . . . . 2 . . #>  [7,] 2 . 2 2 2 . . 2 . 2 #>  [8,] . 2 . . 2 2 2 . 2 2 #>  [9,] . 2 . 2 . . . 2 . 2 #> [10,] . 2 2 . 2 . 2 2 2 . #> plus left factor #> 10 x 1 Matrix of class \"dgeMatrix\" #>       [,1] #>  [1,]   -1 #>  [2,]   -1 #>  [3,]   -1 #>  [4,]   -1 #>  [5,]   -1 #>  [6,]   -1 #>  [7,]   -1 #>  [8,]   -1 #>  [9,]   -1 #> [10,]   -1 #> times right factor transpose #> 10 x 1 Matrix of class \"dgeMatrix\" #>       [,1] #>  [1,]    1 #>  [2,]    1 #>  [3,]    1 #>  [4,]    1 #>  [5,]    1 #>  [6,]    1 #>  [7,]    1 #>  [8,]    1 #>  [9,]    1 #> [10,]    1 center_graph(A, scheme = 2) #> Sparse part #> 10 x 10 sparse Matrix of class \"dgCMatrix\" #>                           #>  [1,] . 1 . 1 1 . 1 . . . #>  [2,] 1 . . . . . . 1 1 1 #>  [3,] . . . 1 . 1 1 . . 1 #>  [4,] 1 . 1 . . . 1 . 1 . #>  [5,] 1 . . . . . 1 1 . 1 #>  [6,] . . 1 . . . . 1 . . #>  [7,] 1 . 1 1 1 . . 1 . 1 #>  [8,] . 1 . . 1 1 1 . 1 1 #>  [9,] . 1 . 1 . . . 1 . 1 #> [10,] . 1 1 . 1 . 1 1 1 . #> plus left factor #> 10 x 2 Matrix of class \"dgeMatrix\" #>             [,1]       [,2] #>  [1,] -1.2808941  1.1728316 #>  [2,] -1.3769099 -1.0474221 #>  [3,] -1.2282543  0.6177946 #>  [4,] -1.2326134 -0.2959305 #>  [5,] -1.4954198 -0.7238267 #>  [6,] -0.6573596 -0.7250464 #>  [7,] -1.9264880 -0.9306699 #>  [8,] -1.8670987  1.2354805 #>  [9,] -1.3684526 -0.1035349 #> [10,] -1.9671018  0.3725154 #> times right factor transpose #> 10 x 2 Matrix of class \"dgeMatrix\" #>            [,1]        [,2] #>  [1,] 0.2720233  0.45884029 #>  [2,] 0.2924141 -0.40977703 #>  [3,] 0.2608442  0.24169631 #>  [4,] 0.2617699 -0.11577521 #>  [5,] 0.3175821 -0.28317864 #>  [6,] 0.1396034 -0.28365580 #>  [7,] 0.4091279 -0.36410074 #>  [8,] 0.3965154  0.48335005 #>  [9,] 0.2906181 -0.04050538 #> [10,] 0.4177531  0.14573711 center_graph(A, scheme = c(-4, 2)) #> Sparse part #> 10 x 10 sparse Matrix of class \"dgCMatrix\" #>                           #>  [1,] . 6 . 6 6 . 6 . . . #>  [2,] 6 . . . . . . 6 6 6 #>  [3,] . . . 6 . 6 6 . . 6 #>  [4,] 6 . 6 . . . 6 . 6 . #>  [5,] 6 . . . . . 6 6 . 6 #>  [6,] . . 6 . . . . 6 . . #>  [7,] 6 . 6 6 6 . . 6 . 6 #>  [8,] . 6 . . 6 6 6 . 6 6 #>  [9,] . 6 . 6 . . . 6 . 6 #> [10,] . 6 6 . 6 . 6 6 6 . #> plus left factor #> 10 x 1 Matrix of class \"dgeMatrix\" #>       [,1] #>  [1,]   -4 #>  [2,]   -4 #>  [3,]   -4 #>  [4,]   -4 #>  [5,]   -4 #>  [6,]   -4 #>  [7,]   -4 #>  [8,]   -4 #>  [9,]   -4 #> [10,]   -4 #> times right factor transpose #> 10 x 1 Matrix of class \"dgeMatrix\" #>       [,1] #>  [1,]    1 #>  [2,]    1 #>  [3,]    1 #>  [4,]    1 #>  [5,]    1 #>  [6,]    1 #>  [7,]    1 #>  [8,]    1 #>  [9,]    1 #> [10,]    1"},{"path":"/reference/check_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Parameter checking for a graph-pair — check_graph","title":"Parameter checking for a graph-pair — check_graph","text":"Function checks pair graphs passed  matching-related functions satisfies necessary conditions modifies  according specified parameters. check_single_graph  similar checks modifications just one graph list graphs.","code":""},{"path":"/reference/check_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parameter checking for a graph-pair — check_graph","text":"","code":"check_graph(   A,   B,   same_order = TRUE,   square = TRUE,   as_list = TRUE,   as_igraph = FALSE )  check_single_graph(A, square = TRUE, as_list = TRUE, as_igraph = FALSE)"},{"path":"/reference/check_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parameter checking for a graph-pair — check_graph","text":"matrix, igraph object, list either. B matrix, igraph object, list either. same_order Whether returned objects number nodes. graphs start different numbers nodes smaller graph padded isolated vertices. (default = TRUE) square Whether matrices need square. (default = TRUE) Currently non-square matrices supported. as_list Whether return results matrix_list. (default = TRUE) FALSE B length > 1 as_igraph Whether return igraph object. (default=FALSE) allowed original parameters igraph objects. FALSE, converts objects sparse matrices.","code":""},{"path":"/reference/check_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parameter checking for a graph-pair — check_graph","text":"List containing B modified according parameters number   vertices graph totv1 totv2.","code":""},{"path":"/reference/check_graph.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parameter checking for a graph-pair — check_graph","text":"B lists matrices igraph objects, lists  must length. Additionally, within list graphs need  number vertices need true across lists.","code":""},{"path":"/reference/check_seeds.html","id":null,"dir":"Reference","previous_headings":"","what":"Standardize seeds input data type — check_seeds","title":"Standardize seeds input data type — check_seeds","text":"Convert input seeds data data frame type first column indices \\(G_1\\) second column corresponding indices \\(G_2\\)","code":""},{"path":"/reference/check_seeds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Standardize seeds input data type — check_seeds","text":"","code":"check_seeds(seeds, nv, logical = FALSE)"},{"path":"/reference/check_seeds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Standardize seeds input data type — check_seeds","text":"seeds vector integers logicals, matrix data frame. Input form vector integers denotes indices seeds identical graphs. Input form vector logicals indicate location seeds TRUE indices seeds identical graphs. Input form matrix data frame, first column indices \\(G_1\\) second column corresponding indices \\(G_2\\). nv integer. Number total vertices. logical logical. TRUE indicates return seeds vector logicals TRUE indicates corresponding vertex seed. FALSE indicates return data frame.","code":""},{"path":"/reference/check_seeds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Standardize seeds input data type — check_seeds","text":"returns data frame first column corresponding indices \\(G_1\\) second column corresponding indices \\(G_2\\) vector logicals TRUE indicates corresponding vertex seed.","code":""},{"path":"/reference/check_seeds.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Standardize seeds input data type — check_seeds","text":"","code":"#input is a vector of logicals check_seeds(1:10 <= 3, nv = 10) #> $seeds #>   A B #> 1 1 1 #> 2 2 2 #> 3 3 3 #>  #> $nonseeds #>    A  B #> 1  4  4 #> 2  5  5 #> 3  6  6 #> 4  7  7 #> 5  8  8 #> 6  9  9 #> 7 10 10 #>   #input is a vector of integers check_seeds(c(1,4,2,7,3), nv = 10) #> $seeds #>   A B #> 1 1 1 #> 2 4 4 #> 3 2 2 #> 4 7 7 #> 5 3 3 #>  #> $nonseeds #>    A  B #> 1  5  5 #> 2  6  6 #> 3  8  8 #> 4  9  9 #> 5 10 10 #>   #input is a matrix check_seeds(matrix(1:4,2), nv = 10) #> $seeds #>   A B #> 1 1 3 #> 2 2 4 #>  #> $nonseeds #>    A  B #> 1  3  1 #> 2  4  2 #> 3  5  5 #> 4  6  6 #> 5  7  7 #> 6  8  8 #> 7  9  9 #> 8 10 10 #>   #input is a data frame check_seeds(as.data.frame(matrix(1:4,2)), nv = 10) #> $seeds #>   A B #> 1 1 3 #> 2 2 4 #>  #> $nonseeds #>    A  B #> 1  3  1 #> 2  4  2 #> 3  5  5 #> 4  6  6 #> 5  7  7 #> 6  8  8 #> 7  9  9 #> 8 10 10 #>"},{"path":"/reference/check_sim.html","id":null,"dir":"Reference","previous_headings":"","what":"Check the similarity matrix passed to a matching function — check_sim","title":"Check the similarity matrix passed to a matching function — check_sim","text":"Internal function checks similarity matrix satisfies  necessary conditions modifies use graph matching.","code":""},{"path":"/reference/check_sim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check the similarity matrix passed to a matching function — check_sim","text":"","code":"check_sim(sim, seeds, nonseeds, totv1, totv2, for_nonseeds = TRUE)"},{"path":"/reference/check_sim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check the similarity matrix passed to a matching function — check_sim","text":"sim Similarity matrix seeds dataframe seed matches running check_seeds nonseeds dataframe nonseed nodes running check_seeds totv1 total number vertices first graph totv2 total number vertices second graph for_nonseeds Whether similarities non-seed nodes (default = TRUE),  similarities among seed nodes included (FALSE)","code":""},{"path":"/reference/check_sim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check the similarity matrix passed to a matching function — check_sim","text":"Standardized similarity matrix similarities nonseeds across  two graphs, for_nonseeds = TRUE, nodes, for_nonseeds = FALSE","code":""},{"path":"/reference/check_sim.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check the similarity matrix passed to a matching function — check_sim","text":"goal flexible terms dimensions similarity matrix  passed gm. useful graphs different orders case  function accepts matrices dimensions equal orders original graphs  number nonseeds.","code":""},{"path":"/reference/do_lap.html","id":null,"dir":"Reference","previous_headings":"","what":"Linear (sum) assignment problem — do_lap","title":"Linear (sum) assignment problem — do_lap","text":"Compute best bipartite matching using one three methods. n x n score matrix find \\(\\max_{v\\\\Pi_n} \\sum_{=1}^n score_{, v()}\\) \\(\\Pi_n\\) denotes permutations n objects.","code":""},{"path":"/reference/do_lap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Linear (sum) assignment problem — do_lap","text":"","code":"do_lap(score, method = \"clue\")"},{"path":"/reference/do_lap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Linear (sum) assignment problem — do_lap","text":"score matrix pairwise scores method One \"lapjv\", \"lapmod\", \"clue\"","code":""},{"path":"/reference/do_lap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Linear (sum) assignment problem — do_lap","text":"do_lap returns vector indicates  best matching column row.","code":""},{"path":"/reference/do_lap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Linear (sum) assignment problem — do_lap","text":"Solves linear assignment using one three methods.  \"clue\" uses solve_lsap clue package.  \"lapjv\" uses Jonker-Volgenaut approach implemented package.  \"lapmod\" use modification JV exploits sparsity score matrix. Scores need non-negative. \"clue\" scores pre-translated  non-negative preserves LAP solution.","code":""},{"path":"/reference/do_lap.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Linear (sum) assignment problem — do_lap","text":"R. Jonker, . Volgenant (1987). shortest augmenting path algorithm dense sparse linear assignment problems. Computing, pages 325-340. . Volgenant (1996). Linear Semi-Assignment Problems:   Core Oriented Approach. Computer Ops Res., pages 917-932. C. H. Papadimitriou K. Steiglitz (1998). Combinatorial Optimization: Algorithms Complexity. Courier Corporation.","code":""},{"path":"/reference/do_lap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Linear (sum) assignment problem — do_lap","text":"","code":"set.seed(12345) cost <- Matrix::rsparsematrix(10, 10, .5) cbind(  do_lap(cost, \"lapjv\"),  do_lap(cost, \"lapmod\"),  do_lap(cost, \"clue\") ) #>       [,1] [,2] [,3] #>  [1,]    1    1    1 #>  [2,]    7    7    7 #>  [3,]    9    9    9 #>  [4,]    8    8    8 #>  [5,]    3    3    3 #>  [6,]    5    5    5 #>  [7,]    6    6    6 #>  [8,]    4    4    4 #>  [9,]   10   10   10 #> [10,]    2    2    2"},{"path":"/reference/get_perm_mat.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Permutation — get_perm_mat","title":"Get Permutation — get_perm_mat","text":"Get m--n permutation matrix according mapping   correspondence.","code":""},{"path":"/reference/get_perm_mat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Permutation — get_perm_mat","text":"","code":"get_perm_mat(match, dim = NULL, padded = FALSE, seeds = TRUE)"},{"path":"/reference/get_perm_mat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Permutation — get_perm_mat","text":"match Either graphMatch object 2-column matrix data frame. first second columns correspond indices \\(G_1\\)  \\(G_2\\) respectively. dim desired dimensions matrix. Note, square. NULL match graphMatch object dim set dim(match) padded FALSE returns square matrix size larger two graph otherwise dim = dim(match).  ignored match graphMatch object. seeds Whether keep seed vertices (TRUE) match remove (FALSE). Ignored match graphMatch object.","code":""},{"path":"/reference/get_perm_mat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Permutation — get_perm_mat","text":"get_perm_mat returns m--n sparse permutation matrix whose   submatrix permutation matrix parts nodes graphs get   matched case matching graphs different order.","code":""},{"path":"/reference/get_perm_mat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Permutation — get_perm_mat","text":"","code":"# returns a permutation matrix: m=n, all the nodes get matched corr <- data.frame(corr_A = c(1,2,3,4), corr_B = c(1,4,2,3)) get_perm_mat(corr, c(4, 4)) #> 4 x 4 sparse Matrix of class \"dgCMatrix\" #>              #> [1,] 1 . . . #> [2,] . . . 1 #> [3,] . 1 . . #> [4,] . . 1 .  # submatrix is a permutation matrix: parts of graphs get matched get_perm_mat(corr, c(5, 6)) #> 5 x 6 sparse Matrix of class \"dgCMatrix\" #>                  #> [1,] 1 . . . . . #> [2,] . . . 1 . . #> [3,] . 1 . . . . #> [4,] . . 1 . . . #> [5,] . . . . . ."},{"path":"/reference/gm.html","id":null,"dir":"Reference","previous_headings":"","what":"Graph Matching Methods — gm","title":"Graph Matching Methods — gm","text":"gm used match pair given graphs,   specifications adjacency matrices pair graphs, possible   prior knowledge, graph matching method.","code":""},{"path":"/reference/gm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Graph Matching Methods — gm","text":"","code":"gm(A, B, seeds = NULL, similarity = NULL, method = \"indefinite\", ...)"},{"path":"/reference/gm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Graph Matching Methods — gm","text":"matrix, igraph object, list either. B matrix, igraph object, list either. seeds vector integers logicals, matrix data frame. seed pairs indices graphs seeds can vector. , seeds must matrix data frame, first column indices \\(G_1\\) second column corresponding indices \\(G_2\\). similarity matrix. n--n matrix containing vertex similarities. Mandatory \"IsoRank\" method. method Choice graph matching methods. One \"indefinite\", \"convex\", \"PATH\", \"percolation\", \"IsoRank\", \"Umeyama\", user-defined graph matching function. Please check Details Examples sections instructions define function. ... Arguments passed graph matching methods. Please refer Details section information.","code":""},{"path":"/reference/gm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Graph Matching Methods — gm","text":"gm returns object class \"graphMatch\". See graphMatch-class links therein details graphMatch class. Please also refer help page implemented method, .e. \"indefinite\", \"convex\", \"PATH\", \"percolation\", \"IsoRank\", \"Umeyama\" details corresponding returned list.","code":""},{"path":"/reference/gm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Graph Matching Methods — gm","text":"method function, take two matrices   igraph objects, seeds similarity scores arguments minimum.   Additionally, can also take arguments needed. self-defined   function return graphMatch class object matching   correspondence, sizes two input graphs, matching formula,   algorithm hyperparameter details. method argument can also take one implemented algorithms,   including \"indefinite\",   \"convex\", \"PATH\",   \"percolation\", \"IsoRank\",   \"Umeyama\".   case, one can pass additional arguments gm function   according specified method.   detailed list additional arguments one implemented method,   please click corresponding method name help page. graph matching functions include list elements additional details   match. Call names() graphMatch object see   available details. example, PATH, IsoRank, Umeyama, Indefinite,   Convex include soft, matrix found   algorithm prior projection onto set permutation matrices.   Similarly, PATH, Indefinite, Convex return iter, number   iterations, IsoRank (greedy LAP) Percolation return   match_order, order node-pairs added match.","code":""},{"path":"/reference/gm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Graph Matching Methods — gm","text":"","code":"# match G_1 & G_2 with some known node pairs as seeds set.seed(123) cgnp_pair <- sample_correlated_gnp_pair(n = 10, corr =  0.5, p =  0.5) g1 <- cgnp_pair$graph1 g2 <- cgnp_pair$graph2 seeds <- 1:10 <= 4  m_rds <- gm(g1, g2, seeds, method = \"indefinite\", start = \"rds\", max_iter = 20) summary(m_rds, g1, g2, true_label = 1:10) #> Call: gm(A = g1, B = g2, seeds = seeds, method = \"indefinite\", start = \"rds\",  #>     max_iter = 20) #>  #> # Matches: 6 #> # True Matches:  6, # Seeds:  4, # Vertices:  10, 10 #>                          #>   common_edges 16.000000 #>  missing_edges  4.000000 #>    extra_edges  5.000000 #>          fnorm  4.242641   # match two multi-layer graphs set.seed(123) gp_list <- replicate(3, sample_correlated_gnp_pair(20, .3, .5), simplify = FALSE) A <- lapply(gp_list, function(gp)gp[[1]]) B <- lapply(gp_list, function(gp)gp[[2]])  m_perco <- gm(A, B, seeds, method = \"percolation\", ExpandWhenStuck = FALSE) summary(m_perco, A, B) #> Call: gm(A = A, B = B, seeds = seeds, method = \"percolation\", ExpandWhenStuck = FALSE) #>  #> # Matches: 16, # Seeds:  4, # Vertices:  20, 20 #>          layer        1        2        3 #>   common_edges 76.00000 61.00000 57.00000 #>  missing_edges 27.00000 41.00000 29.00000 #>    extra_edges 38.00000 30.00000 37.00000 #>          fnorm 11.40175 11.91638 11.48913  sim <- as.matrix(init_start(start = \"bari\", nns = 20, soft_seeds = 1:5)) m_Iso <- gm(A, B, similarity = sim, method = \"IsoRank\", lap_method = \"greedy\") summary(m_Iso, A, B) #> Call: gm(A = A, B = B, similarity = sim, method = \"IsoRank\", lap_method = \"greedy\") #>  #> # Matches: 20, # Seeds:  0, # Vertices:  20, 20 #>          layer        1        2  3 #>   common_edges 73.00000 56.00000 54 #>  missing_edges 30.00000 46.00000 32 #>    extra_edges 41.00000 35.00000 40 #>          fnorm 11.91638 12.72792 12  # customized graph matching algorithm graph_match_rand <- function(A, B, seeds = NULL, similarity = NULL, rand_seed){   nm <- min(nrow(A), nrow(B))   set.seed(rand_seed)   m <- data.frame(sample(nrow(A), nm), corr_B = sample(nrow(B), nm))   m <- as.graphMatch(m)   m$rand_seed <- rand_seed   m }  m_self <- gm(g1, g2, method = graph_match_rand, rand_seed = 123) summary(m_self, g1, g2) #> Call: gm(A = g1, B = g2, method = graph_match_rand, rand_seed = 123) #>  #> # Matches: 10, # Vertices:  10, 10 #>                          #>   common_edges 10.000000 #>  missing_edges 10.000000 #>    extra_edges 11.000000 #>          fnorm  6.480741"},{"path":"/reference/gm_Umeyama.html","id":null,"dir":"Reference","previous_headings":"","what":"Spectral Graph Matching Methods: Umeyama Algorithm — graph_match_Umeyama","title":"Spectral Graph Matching Methods: Umeyama Algorithm — graph_match_Umeyama","text":"Spectral Graph Matching Methods: Umeyama Algorithm","code":""},{"path":"/reference/gm_Umeyama.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spectral Graph Matching Methods: Umeyama Algorithm — graph_match_Umeyama","text":"","code":"graph_match_Umeyama(A, B, seeds = NULL, similarity = NULL)"},{"path":"/reference/gm_Umeyama.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spectral Graph Matching Methods: Umeyama Algorithm — graph_match_Umeyama","text":"matrix, igraph object, list either. B matrix, igraph object, list either. seeds vector integers logicals, matrix data frame. seed pairs indices graphs seeds can vector. , seeds must  matrix data frame, first column indices \\(G_1\\) second column corresponding indices \\(G_2\\). similarity matrix. n--n matrix containing vertex similarities.","code":""},{"path":"/reference/gm_Umeyama.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spectral Graph Matching Methods: Umeyama Algorithm — graph_match_Umeyama","text":"graph_match_Umeyama returns object class \"graphMatch\" list   containing following components:  corr_A matching correspondence \\(G_1\\) corr_B matching correspondence \\(G_2\\) soft functional similarity score matrix one can extract       one matching candidates lap_method Choice solving LAP seeds vector logicals indicating corresponding vertex seed","code":""},{"path":"/reference/gm_Umeyama.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Spectral Graph Matching Methods: Umeyama Algorithm — graph_match_Umeyama","text":"S. Umeyama (1988), eigendecomposition approach weighted   graph matching problems. IEEE TPAMI. USA, pages 695-703.","code":""},{"path":"/reference/gm_Umeyama.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spectral Graph Matching Methods: Umeyama Algorithm — graph_match_Umeyama","text":"","code":"# match G_1 & G_2 using Umeyama algorithm G <- sample_correlated_gnp_pair(10, .9, .5) g1 <- G$graph1 g2 <- G$graph2 startm <- matrix(0, 10, 10) diag(startm)[1:4] <- 1  GM_Umeyama <- gm(g1, g2, similarity = startm, method = \"Umeyama\") GM_Umeyama #> gm(A = g1, B = g2, similarity = startm, method = \"Umeyama\") #>  #> Match (10 x 10): #>    corr_A corr_B #> 1       1      1 #> 2       2      2 #> 3       3      3 #> 4       4      4 #> 5       5      5 #> 6       6      8 #> 7       7      6 #> 8       8      9 #> 9       9      7 #> 10     10     10 # generate the corresponding permutation matrix GM_Umeyama[] #> 10 x 10 sparse Matrix of class \"dgCMatrix\" #>                           #>  [1,] 1 . . . . . . . . . #>  [2,] . 1 . . . . . . . . #>  [3,] . . 1 . . . . . . . #>  [4,] . . . 1 . . . . . . #>  [5,] . . . . 1 . . . . . #>  [6,] . . . . . . . 1 . . #>  [7,] . . . . . 1 . . . . #>  [8,] . . . . . . . . 1 . #>  [9,] . . . . . . 1 . . . #> [10,] . . . . . . . . . 1  summary(GM_Umeyama, g1, g2) #> Call: gm(A = g1, B = g2, similarity = startm, method = \"Umeyama\") #>  #> # Matches: 10, # Seeds:  0, # Vertices:  10, 10 #>                          #>   common_edges 15.000000 #>  missing_edges  9.000000 #>    extra_edges  8.000000 #>          fnorm  5.830952 # visualize the edge-wise matching performance plot(g1, g2, GM_Umeyama)  plot(g1[], g2[], GM_Umeyama)"},{"path":"/reference/gm_fw.html","id":null,"dir":"Reference","previous_headings":"","what":"Frank-Wolfe Graph Matching Methods — graph_match_convex","title":"Frank-Wolfe Graph Matching Methods — graph_match_convex","text":"Match two given graphs, returns list graph matching   results, including matching correspondence vector \\(G_2\\) respect   \\(G_1\\), doubly stochastic matrix permutation matrix.","code":""},{"path":"/reference/gm_fw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Frank-Wolfe Graph Matching Methods — graph_match_convex","text":"","code":"graph_match_convex(   A,   B,   seeds = NULL,   similarity = NULL,   start = \"bari\",   max_iter = 100,   tol = 1e-05,   lap_method = NULL )  graph_match_indefinite(   A,   B,   seeds = NULL,   similarity = NULL,   start = \"bari\",   max_iter = 20,   lap_method = NULL )  graph_match_PATH(   A,   B,   seeds = NULL,   similarity = NULL,   epsilon = 1,   tol = 1e-05,   max_iter = 20,   lap_method = NULL )"},{"path":"/reference/gm_fw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Frank-Wolfe Graph Matching Methods — graph_match_convex","text":"matrix, igraph object, list either. B matrix, igraph object, list either. seeds vector integers logicals, matrix data frame. seed pairs indices graphs seeds can vector. , seeds must  matrix data frame, first column indices \\(G_1\\) second column corresponding indices \\(G_2\\). similarity matrix. n--n matrix containing vertex similarities. start matrix character. nns--nns matrix character value like \"bari\", \"rds\" \"convex\" initialize starting matrix. max_iter number. Maximum number replacing matches. tol number. Tolerance edge disagreements. lap_method Choice lap method. One \"lapjv\", \"lapmod\", \"clue\". epsilon small number","code":""},{"path":"/reference/gm_fw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Frank-Wolfe Graph Matching Methods — graph_match_convex","text":"graph_match_indefinite, graph_match_convex graph_match_PATH return object class \"graphMatch\" list containing following   components:  corr_A matching correspondence \\(G_1\\) corr_B matching correspondence \\(G_2\\) soft doubly stochastic matrix last iteration one can           extract one matching candidates iter number iterations convergence reaches max_iter max_iter Maximum number replacing matches lap_method Choice solving LAP seeds vector logicals indicating corresponding vertex seed","code":""},{"path":"/reference/gm_fw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Frank-Wolfe Graph Matching Methods — graph_match_convex","text":"Y. Aflalo . Bronstein R. Kimmel (2014), convex relaxation graph isomorphism. Proceedings National Academy Sciences, pages 2942-2947. V. Lyzinski D. E. Fishkind M. Fiori J. T. Vogelstein C. E. Priebe G. Sapiro (2016), Graph Matching: Relax Risk. IEEE TPAMI, pages 60-73. V. Lyzinski D. E. Fishkind C. E. Priebe (2014), Seeded Graph Matching Correlated Erdos-Renyi Graphs.J. Mach. Learn. Res., pages 3513-3540. M. Zaslavskiy, F. Bach J. Vert (2009), Path following algorithm graph matching problem. IEEE Trans Pattern Anal Mach Intell, pages 2227-2242.","code":""},{"path":"/reference/gm_fw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Frank-Wolfe Graph Matching Methods — graph_match_convex","text":"","code":"# \\donttest{ cgnp_pair <- sample_correlated_gnp_pair(n = 10, corr =  0.9, p =  0.5) g1 <- cgnp_pair$graph1 g2 <- cgnp_pair$graph2 # match G_1 & G_2 with no seeds gm(g1, g2, method = \"convex\", max_iter = 10) #> Warning: Frank-Wolfe iterations reach the maximum iteration, convergence may not occur. #> gm(A = g1, B = g2, method = \"convex\", max_iter = 10) #>  #> Match (10 x 10): #>    corr_A corr_B #> 1       1      7 #> 2       2      2 #> 3       3      3 #> 4       4      4 #> 5       5      5 #> 6       6      6 #> 7       7      1 #> 8       8      9 #> 9       9      8 #> 10     10     10 seeds <- 1:10 <= 3 gm(g1, g2, seeds, method = \"convex\", max_iter = 10) #> Warning: Frank-Wolfe iterations reach the maximum iteration, convergence may not occur. #> gm(A = g1, B = g2, seeds = seeds, method = \"convex\", max_iter = 10) #>  #> Match (10 x 10): #>    corr_A corr_B #> 1       1      1 #> 2       2      2 #> 3       3      3 #> 4       4      4 #> 5       5      5 #> 6       6      6 #> 7       7      7 #> 8       8      8 #> 9       9      9 #> 10     10     10 # }    # match G_1 & G_2 with some known node pairs as seeds cgnp_pair <- sample_correlated_gnp_pair(n = 10, corr =  0.3, p =  0.5) g1 <- cgnp_pair$graph1 g2 <- cgnp_pair$graph2 seeds <- 1:10 <= 3 GM_bari <- gm(g1, g2, seeds, method = \"indefinite\", start = \"bari\") GM_bari #> gm(A = g1, B = g2, seeds = seeds, method = \"indefinite\", start = \"bari\") #>  #> Match (10 x 10): #>    corr_A corr_B #> 1       1      1 #> 2       2      2 #> 3       3      3 #> 4       4      4 #> 5       5      7 #> 6       6      6 #> 7       7      8 #> 8       8      5 #> 9       9      9 #> 10     10     10 GM_bari[!GM_bari$seeds] # matching correspondence for non-seeds #>    corr_A corr_B #> 4       4      4 #> 5       5      7 #> 6       6      6 #> 7       7      8 #> 8       8      5 #> 9       9      9 #> 10     10     10  summary(GM_bari, g1, g2, true_label = 1:10) #> Call: gm(A = g1, B = g2, seeds = seeds, method = \"indefinite\", start = \"bari\") #>  #> # Matches: 7 #> # True Matches:  4, # Seeds:  3, # Vertices:  10, 10 #>                         #>   common_edges 16.00000 #>  missing_edges  3.00000 #>    extra_edges 10.00000 #>          fnorm  5.09902  # match G_1 & G_2 with some incorrect seeds hard_seeds <- matrix(c(4,6,5,4),2) seeds <- rbind(as.matrix(check_seeds(seeds, nv = 10)$seeds),hard_seeds) GM_badseed <- gm(g1, g2, seeds, method = \"indefinite\")  GM_badseed[] # get the corresponding permutation matrix #> 10 x 10 sparse Matrix of class \"dgCMatrix\" #>                           #>  [1,] 1 . . . . . . . . . #>  [2,] . 1 . . . . . . . . #>  [3,] . . 1 . . . . . . . #>  [4,] . . . . 1 . . . . . #>  [5,] . . . . . . . . . 1 #>  [6,] . . . 1 . . . . . . #>  [7,] . . . . . . 1 . . . #>  [8,] . . . . . 1 . . . . #>  [9,] . . . . . . . . 1 . #> [10,] . . . . . . . 1 . . GM_badseed %*% g2 # permute the second graph according to match result: PBP^T #> IGRAPH 5856357 UN-- 10 26 -- Erdos-Renyi (gnp) graph #> + attr: name_1 (g/c), name_2 (g/c), type_1 (g/c), type_2 (g/c), loops_1 #> | (g/l), loops_2 (g/l), p_1 (g/n), p_2 (g/n), name (g/c), type (g/c), #> | loops (g/l), p (g/n), name (v/n) #> + edges from 5856357 (vertex names): #>  [1]  8-- 9  7--10  7-- 9  8-- 7  6-- 9  6-- 7 10-- 5  9-- 5  8-- 5  7-- 5 #> [11]  6-- 5  4--10  4-- 9  6-- 4  3-- 9  3-- 8  3-- 6  3-- 5  2--10  2-- 8 #> [21]  2-- 4  2-- 3  1-- 8  1-- 7  1-- 4  1-- 2 GM_badseed$soft # doubly stochastic matrix from the last step of Frank-Wolfe iterations #> 10 x 10 sparse Matrix of class \"dgCMatrix\" #>                           #>  [1,] 1 . . . . . . . . . #>  [2,] . 1 . . . . . . . . #>  [3,] . . 1 . . . . . . . #>  [4,] . . . . 1 . . . . . #>  [5,] . . . . . . . . . 1 #>  [6,] . . . 1 . . . . . . #>  [7,] . . . . . . 1 . . . #>  [8,] . . . . . 1 . . . . #>  [9,] . . . . . . . . 1 . #> [10,] . . . . . . . 1 . . GM_badseed$iter # number of iterations #> [1] 3 GM_badseed$max_iter # preset maximum number of iterations: 20 #> [1] 20  # match two multi-layer graphs gp_list <- replicate(3, sample_correlated_gnp_pair(20, .3, .5), simplify = FALSE) A <- lapply(gp_list, function(gp)gp[[1]]) B <- lapply(gp_list, function(gp)gp[[2]])  match_multi_layer <- gm(A, B, seeds = 1:10, method = \"indefinite\", start = \"bari\", max_iter = 20) summary(match_multi_layer, A, B) #> Call: gm(A = A, B = B, seeds = 1:10, method = \"indefinite\", start = \"bari\",  #>     max_iter = 20) #>  #> # Matches: 10, # Seeds:  10, # Vertices:  20, 20 #>          layer       1        2        3 #>   common_edges 65.0000 60.00000 69.00000 #>  missing_edges 37.0000 30.00000 34.00000 #>    extra_edges 31.0000 30.00000 35.00000 #>          fnorm 11.6619 10.95445 11.74734  # match G_1 & G_2 using PATH algorithm gm(g1, g2, method = \"PATH\") #> Warning: Frank-Wolfe iterations reach the maximum iteration, convergence may not occur. #> gm(A = g1, B = g2, method = \"PATH\") #>  #> Match (10 x 10): #>    corr_A corr_B #> 1       1      4 #> 2       2      1 #> 3       3      9 #> 4       4     10 #> 5       5      5 #> 6       6      3 #> 7       7      6 #> 8       8      2 #> 9       9      8 #> 10     10      7"},{"path":"/reference/gm_isorank.html","id":null,"dir":"Reference","previous_headings":"","what":"Spectral Graph Matching Methods: IsoRank Algorithm — graph_match_IsoRank","title":"Spectral Graph Matching Methods: IsoRank Algorithm — graph_match_IsoRank","text":"Spectral Graph Matching Methods: IsoRank Algorithm","code":""},{"path":"/reference/gm_isorank.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spectral Graph Matching Methods: IsoRank Algorithm — graph_match_IsoRank","text":"","code":"graph_match_IsoRank(   A,   B,   seeds = NULL,   similarity,   max_iter = 50,   lap_method = \"greedy\" )"},{"path":"/reference/gm_isorank.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spectral Graph Matching Methods: IsoRank Algorithm — graph_match_IsoRank","text":"matrix, igraph object, list either. B matrix, igraph object, list either. seeds vector integers logicals, matrix data frame. seed pairs indices graphs seeds can vector. , seeds must  matrix data frame, first column indices \\(G_1\\) second column corresponding indices \\(G_2\\). similarity matrix. n--n matrix containing vertex similarities. max_iter number. Maximum number replacing matches. lap_method Choice method extract mapping score matrix. One \"greedy\" \"LAP\".","code":""},{"path":"/reference/gm_isorank.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spectral Graph Matching Methods: IsoRank Algorithm — graph_match_IsoRank","text":"graph_match_IsoRank returns object class \"graphMatch\" list   containing following components:  corr_A matching correspondence \\(G_1\\) corr_B matching correspondence \\(G_2\\) seeds vector logicals indicating corresponding vertex seed soft functional similarity score matrix obtained power method       one can extract one matching candidates match_order order vertices getting matched lap_method Method extracting node mapping","code":""},{"path":"/reference/gm_isorank.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Spectral Graph Matching Methods: IsoRank Algorithm — graph_match_IsoRank","text":"R. Singh, J. Xu, B. Berger (2008), Global alignment multiple protein interaction networks application functional orthology detection. Proceedings National Academy Science. USA, pages 12763-12768.","code":""},{"path":"/reference/gm_isorank.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spectral Graph Matching Methods: IsoRank Algorithm — graph_match_IsoRank","text":"","code":"cgnp_pair <- sample_correlated_gnp_pair(n = 10, corr =  0.3, p =  0.5) g1 <- cgnp_pair$graph1 g2 <- cgnp_pair$graph2 # match G_1 & G_2 using IsoRank algorithm startm <- as.matrix(init_start(start = \"bari\", nns = 10, soft_seeds = 1:4))  GM_IsoRank <- gm(g1, g2, similarity = startm, method = \"IsoRank\", lap_method = \"greedy\") GM_IsoRank #> gm(A = g1, B = g2, similarity = startm, method = \"IsoRank\", lap_method = \"greedy\") #>  #> Match (10 x 10): #>    corr_A corr_B #> 1       1      1 #> 2       2      2 #> 3       3      3 #> 4       4      4 #> 5       5     10 #> 6       6      6 #> 7       7      7 #> 8       8      5 #> 9       9      9 #> 10     10      8 summary(GM_IsoRank, g1, g2, true_label = 1:10) #> Call: gm(A = g1, B = g2, similarity = startm, method = \"IsoRank\", lap_method = \"greedy\") #>  #> # Matches: 10 #> # True Matches:  7, # Seeds:  0, # Vertices:  10, 10 #>                          #>   common_edges 13.000000 #>  missing_edges  2.000000 #>    extra_edges 10.000000 #>          fnorm  4.898979  GM_IsoRank[] # get the corresponding permutation matrix #> 10 x 10 sparse Matrix of class \"dgCMatrix\" #>                           #>  [1,] 1 . . . . . . . . . #>  [2,] . 1 . . . . . . . . #>  [3,] . . 1 . . . . . . . #>  [4,] . . . 1 . . . . . . #>  [5,] . . . . . . . . . 1 #>  [6,] . . . . . 1 . . . . #>  [7,] . . . . . . 1 . . . #>  [8,] . . . . 1 . . . . . #>  [9,] . . . . . . . . 1 . #> [10,] . . . . . . . 1 . . GM_IsoRank %*% g2 # permute the second graph according to match result: PBP^T #> IGRAPH c324d77 UN-- 10 23 -- Erdos-Renyi (gnp) graph #> + attr: name_1 (g/c), name_2 (g/c), type_1 (g/c), type_2 (g/c), loops_1 #> | (g/l), loops_2 (g/l), p_1 (g/n), p_2 (g/n), name (g/c), type (g/c), #> | loops (g/l), p (g/n), name (v/n) #> + edges from c324d77 (vertex names): #>  [1]  7-- 9  6--10  8-- 6 10-- 5  8-- 5  6-- 5  4--10  4-- 8  4-- 5  3-- 9 #> [11]  3-- 8  3-- 6  3-- 5  2--10  2-- 9  2-- 8  2-- 7  2-- 3  1--10  1-- 9 #> [21]  1-- 6  1-- 4  1-- 2 GM_IsoRank %*% g2[] # output permuted matrix #> 10 x 10 sparse Matrix of class \"dgCMatrix\" #>                           #>  [1,] . 1 . 1 1 1 . . 1 . #>  [2,] 1 . 1 . 1 . 1 . 1 1 #>  [3,] . 1 . . . 1 . 1 1 1 #>  [4,] 1 . . . 1 . . 1 . 1 #>  [5,] 1 1 . 1 . 1 . 1 . . #>  [6,] 1 . 1 . 1 . . 1 . 1 #>  [7,] . 1 . . . . . . 1 . #>  [8,] . . 1 1 1 1 . . . 1 #>  [9,] 1 1 1 . . . 1 . . . #> [10,] . 1 1 1 . 1 . 1 . .  # Visualize the edge-wise matching performance plot(g1, g2, GM_IsoRank)  plot(g1[], g2[], GM_IsoRank)"},{"path":"/reference/gm_perco.html","id":null,"dir":"Reference","previous_headings":"","what":"Percolation Graph Matching Methods — graph_match_percolation","title":"Percolation Graph Matching Methods — graph_match_percolation","text":"Percolation Graph Matching Methods","code":""},{"path":"/reference/gm_perco.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Percolation Graph Matching Methods — graph_match_percolation","text":"","code":"graph_match_percolation(   A,   B,   seeds,   similarity = NULL,   r = 2,   ExpandWhenStuck = FALSE )"},{"path":"/reference/gm_perco.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Percolation Graph Matching Methods — graph_match_percolation","text":"matrix, igraph object, list either. B matrix, igraph object, list either. seeds vector integers logicals, matrix data frame. seed pairs indices graphs seeds can vector. , seeds must  matrix data frame, first column indices \\(G_1\\) second column corresponding indices \\(G_2\\). similarity matrix. n--n matrix containing vertex similarities. r number. Threshold neighboring pair scores. ExpandWhenStuck logical. TRUE expand seed set Percolation algorithm stops matching vertices.","code":""},{"path":"/reference/gm_perco.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Percolation Graph Matching Methods — graph_match_percolation","text":"graph_match_percolation returns object class \"graphMatch\"   list containing following components:  corr_A matching correspondence \\(G_1\\) corr_B matching correspondence \\(G_2\\) match_order order vertices getting matched seeds vector logicals indicating corresponding vertex seed","code":""},{"path":"/reference/gm_perco.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Percolation Graph Matching Methods — graph_match_percolation","text":"L. Yartseva M. Grossglauser (2013), performance   percolation graph matching. COSN, Boston, MA, USA, pages 119–130. E. Kazemi, S. H. Hassani, M. Grossglauser (2015), Growing graph matching handful seeds. Proc. VLDB Endowment, 8(10):1010–1021.","code":""},{"path":"/reference/gm_perco.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Percolation Graph Matching Methods — graph_match_percolation","text":"","code":"# match G_1 & G_2 using percolation graph matching method cgnp_pair <- sample_correlated_gnp_pair(n = 20, corr =  0.5, p =  0.8) g1 <- cgnp_pair$graph1 g2 <- cgnp_pair$graph2 seeds <- 1:10 <= 3 GM_perco <- gm(g1, g2, seeds, method = \"percolation\", r = 2, ExpandWhenStuck = FALSE) GM_perco #> gm(A = g1, B = g2, seeds = seeds, method = \"percolation\", r = 2,  #>     ExpandWhenStuck = FALSE) #>  #> Match (20 x 20): #>    corr_A corr_B #> 1       1      1 #> 2       2      2 #> 3       3      3 #> 4       4      8 #> 5       5     12 #> 6       6     11 #> 7       7     17 #> 8       8      6 #> 9       9     19 #> 10     10     10 #> 11     11     18 #> 12     12      9 #> 13     13      5 #> 14     14     14 #> 15     15     15 #> 16     16     16 #> 17     17      4 #> 18     18      7 #> 19     19     13 #> 20     20     20  # matching accuracy with the true alignment being the identity mean(GM_perco$corr_A == GM_perco$corr_B) #> [1] 0.4 GM_perco$match_order #>  [1]  1  2  3  7 13  6 19  4 18 15  5 11 14  9  8 16 10 17 12 20  summary(GM_perco, g1, g2, true_label = 1:20) #> Call: gm(A = g1, B = g2, seeds = seeds, method = \"percolation\", r = 2,  #>     ExpandWhenStuck = FALSE) #>  #> # Matches: 17 #> # True Matches:  5, # Seeds:  3, # Vertices:  20, 20 #>                           #>   common_edges 132.000000 #>  missing_edges  20.000000 #>    extra_edges  17.000000 #>          fnorm   8.602325 plot(g1[], g2[], GM_perco)   # expand when stuck GM_exp <- gm(g1, g2, seeds, method = \"percolation\", r = 4, ExpandWhenStuck = TRUE) GM_exp #> gm(A = g1, B = g2, seeds = seeds, method = \"percolation\", r = 4,  #>     ExpandWhenStuck = TRUE) #>  #> Match (20 x 20): #>    corr_A corr_B #> 1       1      1 #> 2       2      2 #> 3       3      3 #> 4       4      9 #> 5       5     10 #> 6       6     15 #> 7       7     20 #> 8       8      6 #> 9       9     19 #> 10     10     17 #> 11     11      4 #> 12     12      5 #> 13     13     12 #> 14     14     18 #> 15     15      8 #> 16     16      7 #> 17     17     14 #> 18     18     11 #> 19     19     13 #> 20     20     16"},{"path":"/reference/graphMatch_constructor.html","id":null,"dir":"Reference","previous_headings":"","what":"Graph matching results class — graphMatch-class","title":"Graph matching results class — graphMatch-class","text":"S4 class results graph matching function","code":""},{"path":"/reference/graphMatch_constructor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Graph matching results class — graphMatch-class","text":"","code":"graphMatch(corr, nnodes, call = NULL, detail = list())  as.graphMatch(from)"},{"path":"/reference/graphMatch_constructor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Graph matching results class — graphMatch-class","text":"corr data.frame indicating correspondence two graphs nnodes dimensions original two graphs call call graph matching function detail List detailed information object convert graphMatch object","code":""},{"path":"/reference/graphMatch_constructor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Graph matching results class — graphMatch-class","text":"graphMatch object","code":""},{"path":"/reference/graphMatch_constructor.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Graph matching results class — graphMatch-class","text":"graphMatch objects returned graph matching methods   implemented iGraphMatch package. objects primarily   represent found correspondence two vertex sets.   represented data.frame two columns indicating aligned   vertex-pairs across two graphs.","code":""},{"path":"/reference/graphMatch_constructor.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Graph matching results class — graphMatch-class","text":"corr data.frame indicating correspondence two graphs nnodes original two graphs call call graph matching function","code":""},{"path":[]},{"path":"/reference/graphMatch_constructor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Graph matching results class — graphMatch-class","text":"","code":"# sample a pair of correlated random graphs from G(n,p) set.seed(123) cgnp_pair <- sample_correlated_gnp_pair(n = 10, corr =  0.3, p =  0.5) g1 <- cgnp_pair$graph1 g2 <- cgnp_pair$graph2  # match g1 & g2 using percolation algorithm with some known node pairs as seeds match <- gm(A = g1, B = g2, seeds = 1:3, method = 'indefinite')  # graphMatch object match #> gm(A = g1, B = g2, seeds = 1:3, method = \"indefinite\") #>  #> Match (10 x 10): #>    corr_A corr_B #> 1       1      1 #> 2       2      2 #> 3       3      3 #> 4       4      6 #> 5       5      5 #> 6       6      8 #> 7       7     10 #> 8       8      7 #> 9       9      4 #> 10     10      9  match$corr_A # matching correspondence in the first graph #>  [1]  1  2  3  4  5  6  7  8  9 10 match$corr_B # matching correspondence in the second graph #>  [1]  1  2  3  6  5  8 10  7  4  9 match$seeds # vector of logicals indicating seeded nodes #>  [1]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  as.data.frame(match) #>    corr_A corr_B #> 1       1      1 #> 2       2      2 #> 3       3      3 #> 4       4      6 #> 5       5      5 #> 6       6      8 #> 7       7     10 #> 8       8      7 #> 9       9      4 #> 10     10      9 match[] #> 10 x 10 sparse Matrix of class \"dgCMatrix\" #>                           #>  [1,] 1 . . . . . . . . . #>  [2,] . 1 . . . . . . . . #>  [3,] . . 1 . . . . . . . #>  [4,] . . . . . 1 . . . . #>  [5,] . . . . 1 . . . . . #>  [6,] . . . . . . . 1 . . #>  [7,] . . . . . . . . . 1 #>  [8,] . . . . . . 1 . . . #>  [9,] . . . 1 . . . . . . #> [10,] . . . . . . . . 1 . dim(match) #> [1] 10 10 length(match) #> [1] 10  # matching details unique to the FW methodology with indefinite relaxation match$iter # number of iterations #> [1] 2 match$soft # doubly stochastic matrix from the last iteration, can be used to extract soft matching #> 10 x 10 sparse Matrix of class \"dgCMatrix\" #>                           #>  [1,] 1 . . . . . . . . . #>  [2,] . 1 . . . . . . . . #>  [3,] . . 1 . . . . . . . #>  [4,] . . . . . 1 . . . . #>  [5,] . . . . 1 . . . . . #>  [6,] . . . . . . . 1 . . #>  [7,] . . . . . . . . . 1 #>  [8,] . . . . . . 1 . . . #>  [9,] . . . 1 . . . . . . #> [10,] . . . . . . . . 1 . match$lap_method # method for solving lap #> [1] \"clue\"  # create a graphMatch object from a data.frame or matrix as.graphMatch(data.frame(1:5, 1:5)) #> asMethod(from = object) #>  #> Match (5 x 5): #>   corr_A corr_B #> 1      1      1 #> 2      2      2 #> 3      3      3 #> 4      4      4 #> 5      5      5 as.graphMatch(1:5) #> asMethod(from = object) #>  #> Match (5 x 5): #>   corr_A corr_B #> 1      1      1 #> 2      2      2 #> 3      3      3 #> 4      4      4 #> 5      5      5"},{"path":"/reference/graphMatch_methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for the graphMatch class — as.data.frame,graphMatch-method","title":"Methods for the graphMatch class — as.data.frame,graphMatch-method","text":"methods provide functionality view, inspect,   convert graphMatch objects.","code":""},{"path":"/reference/graphMatch_methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the graphMatch class — as.data.frame,graphMatch-method","text":"","code":"# S4 method for graphMatch as.data.frame(x)  # S4 method for graphMatch show(object)  # S4 method for graphMatch print(x)  # S4 method for graphMatch,missing,missing,missing [(x, i = NULL, j = NULL, drop = NULL)  # S4 method for graphMatch dim(x)  # S4 method for graphMatch length(x)  # S4 method for graphMatch t(x)  # S4 method for graphMatch rev(x)  # S4 method for graphMatch,ANY,ANY,ANY [(x, i = NULL, j = NULL, drop = NULL)  # S4 method for graphMatch str(object)  # S4 method for graphMatch $(x, name)"},{"path":"/reference/graphMatch_methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the graphMatch class — as.data.frame,graphMatch-method","text":"x graphMatch object object graphMatch object row index correspondence data.frame j col index correspondence data.frame drop ignored name name element list","code":""},{"path":"/reference/graphMatch_methods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Methods for the graphMatch class — as.data.frame,graphMatch-method","text":"dim returns vector length two indicating number   vertices original graph. length returns number found   vertex-pair matches. m[,j] index 2 x length data.frame   vertex-pair matches. true ,j unless missing.   case, m[] returns sparse matrix dimension dim(m)  m[][,j] 0 unless m matches node node j. (Note   guaranteed permutation matrix unless dim(m)[1] = dim(m)[2] =   length(m).","code":""},{"path":"/reference/graphMatch_methods.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Methods for the graphMatch class — as.data.frame,graphMatch-method","text":"Methods graphMatch class","code":""},{"path":[]},{"path":"/reference/graphMatch_methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Methods for the graphMatch class — as.data.frame,graphMatch-method","text":"","code":"# sample a pair of correlated random graphs from G(n,p) set.seed(123) cgnp_pair <- sample_correlated_gnp_pair(n = 10, corr =  0.3, p =  0.5) g1 <- cgnp_pair$graph1 g2 <- cgnp_pair$graph2  # match g1 & g2 using FW methodology with indefinite relaxation match <- gm(A = g1, B = g2, seeds = 1:3, method = 'indefinite')  # print graphMatch object match #> gm(A = g1, B = g2, seeds = 1:3, method = \"indefinite\") #>  #> Match (10 x 10): #>    corr_A corr_B #> 1       1      1 #> 2       2      2 #> 3       3      3 #> 4       4      6 #> 5       5      5 #> 6       6      8 #> 7       7     10 #> 8       8      7 #> 9       9      4 #> 10     10      9 print(match) #> gm(A = g1, B = g2, seeds = 1:3, method = \"indefinite\") #>  #> Match (10 x 10): #>    corr_A corr_B #> 1       1      1 #> 2       2      2 #> 3       3      3 #> 4       4      6 #> 5       5      5 #> 6       6      8 #> 7       7     10 #> 8       8      7 #> 9       9      4 #> 10     10      9 show(match) #> gm(A = g1, B = g2, seeds = 1:3, method = \"indefinite\") #>  #> Match (10 x 10): #>    corr_A corr_B #> 1       1      1 #> 2       2      2 #> 3       3      3 #> 4       4      6 #> 5       5      5 #> 6       6      8 #> 7       7     10 #> 8       8      7 #> 9       9      4 #> 10     10      9  # print matching correspondence match$corr_A # matching correspondence in the first graph #>  [1]  1  2  3  4  5  6  7  8  9 10 match$corr_B # matching correspondence in the second graph #>  [1]  1  2  3  6  5  8 10  7  4  9  # get nonseed matching correspondence match[!match$seeds] #>    corr_A corr_B #> 4       4      6 #> 5       5      5 #> 6       6      8 #> 7       7     10 #> 8       8      7 #> 9       9      4 #> 10     10      9  # create graphMatch object from a vector as.graphMatch(sample(10)) #> asMethod(from = object) #>  #> Match (10 x 10): #>    corr_A corr_B #> 1       1      1 #> 2       2      8 #> 3       3      6 #> 4       4      9 #> 5       5      4 #> 6       6     10 #> 7       7      7 #> 8       8      2 #> 9       9      5 #> 10     10      3 # or data.frame as.graphMatch(data.frame(a = 1:10, b = sample(1000, 10))) #> asMethod(from = object) #>  #> Match (10 x 876): #>    corr_A corr_B #> 1       1     20 #> 2       2    872 #> 3       3    195 #> 4       4    861 #> 5       5    164 #> 6       6     52 #> 7       7    876 #> 8       8    534 #> 9       9    177 #> 10     10    554  # get corresponding permutation matrix for the match result match[] # preferred approach #> 10 x 10 sparse Matrix of class \"dgCMatrix\" #>                           #>  [1,] 1 . . . . . . . . . #>  [2,] . 1 . . . . . . . . #>  [3,] . . 1 . . . . . . . #>  [4,] . . . . . 1 . . . . #>  [5,] . . . . 1 . . . . . #>  [6,] . . . . . . . 1 . . #>  [7,] . . . . . . . . . 1 #>  [8,] . . . . . . 1 . . . #>  [9,] . . . 1 . . . . . . #> [10,] . . . . . . . . 1 . # or equivalently get_perm_mat(match) #> 10 x 10 sparse Matrix of class \"dgCMatrix\" #>                           #>  [1,] 1 . . . . . . . . . #>  [2,] . 1 . . . . . . . . #>  [3,] . . 1 . . . . . . . #>  [4,] . . . . . 1 . . . . #>  [5,] . . . . 1 . . . . . #>  [6,] . . . . . . . 1 . . #>  [7,] . . . . . . . . . 1 #>  [8,] . . . . . . 1 . . . #>  [9,] . . . 1 . . . . . . #> [10,] . . . . . . . . 1 .   # sizes of two graphs dim(match) #> [1] 10 10  # number of matched node pairs length(match) #> [1] 10   # reverse the matching correspondence between two graphs t(match) #> gm(A = g1, B = g2, seeds = 1:3, method = \"indefinite\") #>  #> Match (10 x 10): #>    corr_B corr_A #> 1       1      1 #> 2       2      2 #> 3       3      3 #> 4       6      4 #> 5       5      5 #> 6       8      6 #> 7      10      7 #> 8       7      8 #> 9       4      9 #> 10      9     10 rev(match) #>    corr_A corr_B #> 10     10      9 #> 9       9      4 #> 8       8      7 #> 7       7     10 #> 6       6      8 #> 5       5      5 #> 4       4      6 #> 3       3      3 #> 2       2      2 #> 1       1      1"},{"path":"/reference/graphMatch_operators.html","id":null,"dir":"Reference","previous_headings":"","what":"Operator methods for graphMatch objects — %*%,graphMatch,ANY-method","title":"Operator methods for graphMatch objects — %*%,graphMatch,ANY-method","text":"Methods use graphMatch objects operators  igraph matrix-like objects.","code":""},{"path":"/reference/graphMatch_operators.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Operator methods for graphMatch objects — %*%,graphMatch,ANY-method","text":"","code":"# S4 method for graphMatch,ANY %*%(x, y)  # S4 method for ANY,graphMatch %*%(x, y)  # S4 method for graphMatch,Matrix %*%(x, y)  # S4 method for Matrix,graphMatch %*%(x, y)  # S4 method for graphMatch,igraph %*%(x, y)  # S4 method for igraph,graphMatch %*%(x, y)"},{"path":"/reference/graphMatch_operators.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Operator methods for graphMatch objects — %*%,graphMatch,ANY-method","text":"x Either graphMatch object matrix-like object y Either graphMatch object matrix-like object","code":""},{"path":"/reference/graphMatch_operators.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Operator methods for graphMatch objects — %*%,graphMatch,ANY-method","text":"methods return object type  non-graphMatch object. m match g1  g2 (igraph objects), m permuted match g1. Conversely, g1 returns g1 permuted match g2.","code":""},{"path":"/reference/graphMatch_operators.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Operator methods for graphMatch objects — %*%,graphMatch,ANY-method","text":"","code":"set.seed(123) cgnp_pair <- sample_correlated_gnp_pair(n = 10, corr =  0.3, p =  0.5) g1 <- cgnp_pair$graph1 g2 <- cgnp_pair$graph2  # match g1 & g2 using FW methodology with indefinite relaxation match <- gm(A = g1, B = g2, seeds = 1:3, method = 'indefinite')  # permute the second graph according to the match result: P %*% g2 %*% P^T match %*% g2 # return an igraph object #> IGRAPH d1699fb UN-- 10 19 -- Erdos-Renyi (gnp) graph #> + attr: name_1 (g/c), name_2 (g/c), type_1 (g/c), type_2 (g/c), loops_1 #> | (g/l), loops_2 (g/l), p_1 (g/n), p_2 (g/n), name (g/c), type (g/c), #> | loops (g/l), p (g/n), name (v/n) #> + edges from d1699fb (vertex names): #>  [1] 8--10 5-- 6 4--10 9-- 4 4-- 7 5-- 4 3--10 3-- 9 3-- 7 3-- 6 3-- 5 3-- 4 #> [13] 2-- 9 2-- 7 2-- 5 2-- 4 1-- 8 1-- 5 1-- 3 # equivalent to the matrix operation match[] %*% g2[] %*% t(match[]) #> 10 x 10 sparse Matrix of class \"dgCMatrix\" #>                           #>  [1,] . . 1 . 1 1 . . . . #>  [2,] . . . . 1 . . 1 1 1 #>  [3,] 1 . . 1 1 . 1 1 1 1 #>  [4,] . . 1 . 1 . . . . . #>  [5,] 1 1 1 1 . . . . 1 . #>  [6,] 1 . . . . . 1 . . . #>  [7,] . . 1 . . 1 . . 1 . #>  [8,] . 1 1 . . . . . 1 . #>  [9,] . 1 1 . 1 . 1 1 . 1 #> [10,] . 1 1 . . . . . 1 .  match %*% g2[] # return a matrix #> 10 x 10 sparse Matrix of class \"dgCMatrix\" #>                           #>  [1,] . . 1 . 1 1 . . . . #>  [2,] . . . . 1 . . 1 1 1 #>  [3,] 1 . . 1 1 . 1 1 1 1 #>  [4,] . . 1 . 1 . . . . . #>  [5,] 1 1 1 1 . . . . 1 . #>  [6,] 1 . . . . . 1 . . . #>  [7,] . . 1 . . 1 . . 1 . #>  [8,] . 1 1 . . . . . 1 . #>  [9,] . 1 1 . 1 . 1 1 . 1 #> [10,] . 1 1 . . . . . 1 . # equivalent to: P <- match[] P %*% g2[] %*% Matrix::t(P) #> 10 x 10 sparse Matrix of class \"dgCMatrix\" #>                           #>  [1,] . . 1 . 1 1 . . . . #>  [2,] . . . . 1 . . 1 1 1 #>  [3,] 1 . . 1 1 . 1 1 1 1 #>  [4,] . . 1 . 1 . . . . . #>  [5,] 1 1 1 1 . . . . 1 . #>  [6,] 1 . . . . . 1 . . . #>  [7,] . . 1 . . 1 . . 1 . #>  [8,] . 1 1 . . . . . 1 . #>  [9,] . 1 1 . 1 . 1 1 . 1 #> [10,] . 1 1 . . . . . 1 .  # the inverse operations are performed via right multiplication all(g1[] %*% match == t(P) %*% g1[] %*% P) #> [1] TRUE"},{"path":"/reference/graphMatch_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary methods for graphMatch objects — summary,graphMatch-method","title":"Summary methods for graphMatch objects — summary,graphMatch-method","text":"Summary methods graphMatch objects","code":""},{"path":"/reference/graphMatch_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary methods for graphMatch objects — summary,graphMatch-method","text":"","code":"# S4 method for graphMatch summary(object, A = NULL, B = NULL, true_label = NULL, directed = NULL)"},{"path":"/reference/graphMatch_summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary methods for graphMatch objects — summary,graphMatch-method","text":"object graphMatch object igraph matrix-like object B igraph matrix-like object true_label true correspondence (available) directed whether treat graphs directed (TRUE) directed (FALSE) default NULL treat graphs directed either adjacency matrix symmetric.","code":""},{"path":"/reference/graphMatch_summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary methods for graphMatch objects — summary,graphMatch-method","text":"summary returns graph matching formula, summary   graph matching results including number matches, number   correct matches (true correspondence available), common   edges, missing edges, extra edges, common non-edges objective   function value.","code":""},{"path":"/reference/graphMatch_summary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary methods for graphMatch objects — summary,graphMatch-method","text":"","code":"set.seed(123) graphs <- sample_correlated_gnp_pair(20, .9, .3) A <- graphs$graph1 B <- graphs$graph2 match <- gm(A, B, 1:4, method = \"percolation\")  summary(match, A, B) #> Call: gm(A = A, B = B, seeds = 1:4, method = \"percolation\") #>  #> # Matches: 15, # Seeds:  4, # Vertices:  20, 20 #>                   #>   common_edges 55 #>  missing_edges  2 #>    extra_edges  6 #>          fnorm  4 summary(match, A, B, true_label = 1:20) # also output the number of correct matches #> Call: gm(A = A, B = B, seeds = 1:4, method = \"percolation\") #>  #> # Matches: 15 #> # True Matches:  15, # Seeds:  4, # Vertices:  20, 20 #>                   #>   common_edges 55 #>  missing_edges  2 #>    extra_edges  6 #>          fnorm  4"},{"path":"/reference/iGraphMatch-package.html","id":null,"dir":"Reference","previous_headings":"","what":"iGraphMatch: Tools for Graph Matching — iGraphMatch-package","title":"iGraphMatch: Tools for Graph Matching — iGraphMatch-package","text":"Versatile tools data graph matching analysis various forms prior information supports working 'igraph' objects, matrix objects, lists either.","code":""},{"path":[]},{"path":"/reference/iGraphMatch-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"iGraphMatch: Tools for Graph Matching — iGraphMatch-package","text":"Maintainer: Daniel Sussman sussman@bu.edu Authors: Zihuan Qiao zhqiao@bu.edu contributors: Joshua Agterberg [contributor] Lujia Wang [contributor] Vince Lyzinski [contributor]","code":""},{"path":"/reference/init_start.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialization of the start matrix — init_start","title":"Initialization of the start matrix — init_start","text":"Initialize start matrix graph matching iteration.","code":""},{"path":"/reference/init_start.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialization of the start matrix — init_start","text":"","code":"init_start(start, nns, ns = 0, soft_seeds = NULL, seeds = NULL, ...)"},{"path":"/reference/init_start.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initialization of the start matrix — init_start","text":"start matrix, character, function. nns--nns matrix, start method like \"bari\", \"convex\" \"rds\", function  initialize start matrix. function, must least arguments nns, ns, softs_seeds. nns integer. Number non-seeds. ns integer. Number seeds. soft_seeds vector, matrix data frame indicating entries start matrix initialized 1 indicate . See check_seeds. seeds vector, matrix data frame. Indicating hard seeds. used \"convex\" start otherwise ignored. ... Arguments passed start functions. See details Values section.","code":""},{"path":"/reference/init_start.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialization of the start matrix — init_start","text":"init_start returns nns--nns doubly stochastic matrix start matrix graph matching iteration. conduct soft seeding graph matching, returns nns--nns doubly stochastic matrix 1's corresponding soft seeds values places derived different start method.","code":""},{"path":"/reference/init_start.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Initialization of the start matrix — init_start","text":"start character, five options. \"bari\" initializes barycenter. \"rds_perm_bari\" gives random linear combination barycenter   random permutation matrix, (1-) B + P. argument g controls   sampled g * runif(). \"rds\" gives random doubly stochastic matrix. Users can specify   random deviates generator distribution argument, default runif.    random matrix iid entries distribution Sinkhorn algorithm applied   produce output. \"rds_from_sim\" gives random doubly stochastic matrix derived   similarity scores. One needs input similarity score matrix sim   argument method. procedure \"rds\"    Sinkhorn algorithm applied, entries random matrix scaled    sim. \"convex\" returns doubly stochastic matrix last iteration running Frank- Wolfe algorithm convex relaxation initialized barycenter. method, one needs input two graphs B, well seeds applicable.","code":""},{"path":"/reference/init_start.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Initialization of the start matrix — init_start","text":"","code":"ss <- matrix(c(5, 4, 4, 3), nrow = 2) # initialize start matrix without soft seeds init_start(start = \"bari\", nns = 5) #> Sparse part #> 5 x 5 sparse Matrix of class \"dtCMatrix\" #>                #> [1,] . . . . . #> [2,] . . . . . #> [3,] . . . . . #> [4,] . . . . . #> [5,] . . . . . #> plus left factor #> 5 x 1 sparse Matrix of class \"dgCMatrix\" #>        #> [1,] 1 #> [2,] 1 #> [3,] 1 #> [4,] 1 #> [5,] 1 #> times right factor transpose #> 5 x 1 sparse Matrix of class \"dgCMatrix\" #>          #> [1,] 0.2 #> [2,] 0.2 #> [3,] 0.2 #> [4,] 0.2 #> [5,] 0.2 init_start(start = \"rds\", nns = 3) #> 3 x 3 sparse Matrix of class \"dgCMatrix\" #>                                    #> [1,] 0.3998906 0.2908486 0.3092609 #> [2,] 0.4605651 0.2378778 0.3015571 #> [3,] 0.1395443 0.4712736 0.3891820 init_start(start = \"rds_perm_bari\", nns = 5) #> Sparse part #> 5 x 5 sparse Matrix of class \"dgCMatrix\" #>                                                        #> [1,] .         .         0.9526446 .         .         #> [2,] .         0.9526446 .         .         .         #> [3,] .         .         .         .         0.9526446 #> [4,] .         .         .         0.9526446 .         #> [5,] 0.9526446 .         .         .         .         #> plus left factor #> 5 x 1 sparse Matrix of class \"dgCMatrix\" #>                 #> [1,] 0.04735543 #> [2,] 0.04735543 #> [3,] 0.04735543 #> [4,] 0.04735543 #> [5,] 0.04735543 #> times right factor transpose #> 5 x 1 sparse Matrix of class \"dgCMatrix\" #>          #> [1,] 0.2 #> [2,] 0.2 #> [3,] 0.2 #> [4,] 0.2 #> [5,] 0.2 init_start(start = \"rds_from_sim\", nns = 3, sim = matrix(runif(9), 3)) #> 3 x 3 sparse Matrix of class \"dgCMatrix\" #>                                    #> [1,] 0.1258852 0.2815311 0.5925836 #> [2,] 0.4997791 0.2537421 0.2464788 #> [3,] 0.3743356 0.4647268 0.1609376  # initialize start matrix with soft seeds init_start(start = \"bari\", nns = 5, ns = 1, soft_seeds = ss) #> Sparse part #> 5 x 5 sparse Matrix of class \"dgCMatrix\" #>                #> [1,] . . . . . #> [2,] . . . . . #> [3,] . 1 . . . #> [4,] . . 1 . . #> [5,] . . . . . #> plus left factor #> 5 x 1 sparse Matrix of class \"dgCMatrix\" #>        #> [1,] 1 #> [2,] 1 #> [3,] . #> [4,] . #> [5,] 1 #> times right factor transpose #> 5 x 1 sparse Matrix of class \"dgCMatrix\" #>                #> [1,] 0.3333333 #> [2,] .         #> [3,] .         #> [4,] 0.3333333 #> [5,] 0.3333333 init_start(start = \"rds\", nns = 5, soft_seeds = ss) #> 5 x 5 sparse Matrix of class \"dgCMatrix\" #>                                        #> [1,] 0.1270208 0.4325422 . . 0.4404370 #> [2,] 0.3298594 0.3399201 . . 0.3302205 #> [3,] 0.5431198 0.2275377 . . 0.2293425 #> [4,] .         .         1 . .         #> [5,] .         .         . 1 .         init_start(start = \"rds_perm_bari\", nns = 5, soft_seeds = ss) #> Sparse part #> 5 x 5 sparse Matrix of class \"dgCMatrix\" #>                                        #> [1,] .         0.7932242 . . .         #> [2,] 0.7932242 .         . . .         #> [3,] .         .         . . 0.7932242 #> [4,] .         .         1 . .         #> [5,] .         .         . 1 .         #> plus left factor #> 5 x 1 sparse Matrix of class \"dgCMatrix\" #>                #> [1,] 0.2067758 #> [2,] 0.2067758 #> [3,] 0.2067758 #> [4,] .         #> [5,] .         #> times right factor transpose #> 5 x 1 sparse Matrix of class \"dgCMatrix\" #>                #> [1,] 0.3333333 #> [2,] 0.3333333 #> [3,] .         #> [4,] .         #> [5,] 0.3333333  # \\donttest{ # initialize start matrix for convex graph matching cgnp_pair <- sample_correlated_gnp_pair(n = 10, corr =  0.3, p =  0.5) g1 <- cgnp_pair$graph1 g2 <- cgnp_pair$graph2 seeds <- 1:10 <= 2 init_start(start = \"convex\", nns = 8, A = g1, B = g2, seeds = seeds) #> Warning: Frank-Wolfe iterations reach the maximum iteration, convergence may not occur. #> Sparse part #> 6 x 6 sparse Matrix of class \"dgCMatrix\" #>                                                                      #> [1,] 0.09676176 0.14379966 0.1523425 .          0.04883263 0.1026742 #> [2,] 0.24396338 0.20208258 .         0.05848686 0.05944940 0.1239487 #> [3,] 0.02235561 .          0.2780643 0.20823372 0.16801942 0.1476918 #> [4,] 0.11436329 0.14354374 0.1819128 0.07153240 .          0.1498274 #> [5,] 0.25969662 0.20979364 .         .          0.03174602 .         #> [6,] 0.07125127 0.02996218 0.1409496 .          0.39055273 0.2331440 #> plus left factor #> 6 x 1 sparse Matrix of class \"dgCMatrix\" #>                #> [1,] 0.1341402 #> [2,] 0.1341402 #> [3,] 0.1341402 #> [4,] 0.1341402 #> [5,] 0.1341402 #> [6,] 0.1341402 #> times right factor transpose #> 6 x 1 sparse Matrix of class \"dgCMatrix\" #>            #> [1,] 0.125 #> [2,] 0.125 #> [3,] 0.125 #> [4,] 0.125 #> [5,] 0.125 #> [6,] 0.125  # FW graph matching with incorrect seeds to start at convex start init_start(start = \"convex\", nns = 8, ns = 2, soft_seeds = ss, A = g1, B = g2, seeds = seeds) #> Warning: Frank-Wolfe iterations reach the maximum iteration, convergence may not occur. #> Sparse part #> 8 x 8 sparse Matrix of class \"dgCMatrix\" #>                                                                        #> [1,] 0.12198830 0.14607249 0.157678442 .          0.06429481 0.1127375 #> [2,] 0.23341457 0.23870508 0.020445592 0.07607659 0.07214470 0.1492380 #> [3,] 0.01891587 0.06202455 0.289295704 0.21472901 0.17454290 0.1572702 #> [4,] 0.12727185 0.16159995 0.176300298 0.08684848 .          0.1567839 #> [5,] 0.28696622 0.19860325 0.005618549 0.02201080 0.04880273 .         #> [6,] 0.10988048 0.03792362 0.149641871 .          0.39729826 0.2432312 #> [7,] 0.06295282 .          0.087544417 0.09073721 0.18089206 0.1187147 #> [8,] 0.03860990 0.15507107 0.051450576 0.44757335 .          .         #>                            #> [1,] 0.28661104 0.04859287 #> [2,] .          0.20997548 #> [3,] 0.02735853 0.05586327 #> [4,] 0.06314945 0.16602157 #> [5,] .          0.37597390 #> [6,] .          .          #> [7,] 0.39713423 .          #> [8,] 0.16372220 0.08154836 #> plus left factor #> 8 x 1 sparse Matrix of class \"dgCMatrix\" #>                 #> [1,] 0.06202455 #> [2,] .          #> [3,] .          #> [4,] 0.06202455 #> [5,] 0.06202455 #> [6,] 0.06202455 #> [7,] 0.06202455 #> [8,] 0.06202455 #> times right factor transpose #> 8 x 1 sparse Matrix of class \"dgCMatrix\" #>                #> [1,] .         #> [2,] .         #> [3,] 0.1666667 #> [4,] 0.1666667 #> [5,] 0.1666667 #> [6,] 0.1666667 #> [7,] 0.1666667 #> [8,] 0.1666667 # }"},{"path":"/reference/innerproduct.html","id":null,"dir":"Reference","previous_headings":"","what":"Matrix inner products — innerproduct","title":"Matrix inner products — innerproduct","text":"Matrix inner products","code":""},{"path":"/reference/innerproduct.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matrix inner products — innerproduct","text":"","code":"innerproduct(x, y)  # S4 method for splrMatrix,splrMatrix innerproduct(x, y)  # S4 method for splrMatrix,Matrix innerproduct(x, y)  # S4 method for Matrix,splrMatrix innerproduct(x, y)  # S4 method for matrix_list,matrix_list innerproduct(x, y)"},{"path":"/reference/innerproduct.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matrix inner products — innerproduct","text":"x matrix like object y matrix like object","code":""},{"path":"/reference/innerproduct.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matrix inner products — innerproduct","text":"inner product <x, y> = sum elements ,j x_ij * y_ij.","code":""},{"path":"/reference/innerproduct.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Matrix inner products — innerproduct","text":"matrix_list object, sums layers/list-elements well.","code":""},{"path":"/reference/lapjv.html","id":null,"dir":"Reference","previous_headings":"","what":"Solves a linear assignment problem using the Jonker-Vogenant algorithm or LAPMOD variant — lapjv","title":"Solves a linear assignment problem using the Jonker-Vogenant algorithm or LAPMOD variant — lapjv","text":"Find matching rows columns minimizes maximizes cost. See do_lap usage.","code":""},{"path":"/reference/lapjv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Solves a linear assignment problem using the Jonker-Vogenant algorithm or LAPMOD variant — lapjv","text":"","code":"lapjv(cost, maximize = FALSE)  lapmod(cost, maximize = FALSE)"},{"path":"/reference/lapjv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solves a linear assignment problem using the Jonker-Vogenant algorithm or LAPMOD variant — lapjv","text":"cost lapjv, object can coerced matrix. lapmod, sparseMatrix. maximize FALSE (default) costs minimized TRUE costs maximized","code":""},{"path":"/reference/lapjv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Solves a linear assignment problem using the Jonker-Vogenant algorithm or LAPMOD variant — lapjv","text":"assignment rows columns vector.","code":""},{"path":"/reference/lapjv.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Solves a linear assignment problem using the Jonker-Vogenant algorithm or LAPMOD variant — lapjv","text":"C++ code method modified code  python lapjv package. cost matrix padded single row column large entries  helps avoid stability issues algorithms.","code":""},{"path":"/reference/lapjv.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Solves a linear assignment problem using the Jonker-Vogenant algorithm or LAPMOD variant — lapjv","text":"R. Jonker, . Volgenant (1987). shortest augmenting path algorithm dense sparse linear assignment problems. Computing, pages 325-340. . Volgenant (1996). Linear Semi-Assignment Problems:   Core Oriented Approach. Computer Ops Res., pages 917-932.","code":""},{"path":"/reference/largest_common_cc.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the largest common connected subgraph (LCCS) of two graphs — largest_common_cc","title":"Find the largest common connected subgraph (LCCS) of two graphs — largest_common_cc","text":"Find largest common connected subgraphs two matched graphs, induced connected subgraph graphs many vertices possible. largest_cc function returns largest connected subgraph single graph.","code":""},{"path":"/reference/largest_common_cc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find the largest common connected subgraph (LCCS) of two graphs — largest_common_cc","text":"","code":"largest_common_cc(A, B, min_degree = 1)  largest_cc(A)"},{"path":"/reference/largest_common_cc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find the largest common connected subgraph (LCCS) of two graphs — largest_common_cc","text":"matrix igraph object. See check_graph. Must single-layer. B matrix igraph object. See check_graph. Must single-layer. min_degree number. Defines level connectedness obtained largest common connected subgraph. induced subgraph graph minimum vertex-degree least min_degree.","code":""},{"path":"/reference/largest_common_cc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find the largest common connected subgraph (LCCS) of two graphs — largest_common_cc","text":"largest_common_cc returns common largest connected subgraphs two aligned graphs igraph object form logical vector indicating vertices original graphs remain induced subgraph.","code":""},{"path":"/reference/largest_common_cc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find the largest common connected subgraph (LCCS) of two graphs — largest_common_cc","text":"","code":"cgnp_pair <- sample_correlated_gnp_pair(n = 10, corr =  0.7, p =  0.2) g1 <- cgnp_pair$graph1 g2 <- cgnp_pair$graph2 # put no constraint on the minimum degree of the common largest conncect subgraph lccs1 <- largest_common_cc(g1, g2, min_degree = 1) # induced subgraph lccs1$g1 #> IGRAPH 89913ae D--- 5 8 --  #> + edges from 89913ae: #> [1] 1->4 2->3 2->4 3->2 4->1 4->2 4->5 5->4 lccs1$g2 #> IGRAPH d1be59c D--- 5 8 --  #> + edges from d1be59c: #> [1] 1->4 2->3 2->4 3->2 4->1 4->2 4->5 5->4 # label of vertices of the induced subgraph in the original graph igraph::V(g1)[lccs1$keep] #> + 5/10 vertices, from 061f97a: #> [1] 1 2 6 8 9  # obtain a common largest connect subgraph with each vertex having a minimum degree of 3 lccs3 <- largest_common_cc(g1, g2, min_degree = 3)  g <- igraph::sample_gnp(100, .01) lcc <- largest_cc(g) # induced subgraph lcc$g #> IGRAPH 6326eef D--- 7 12 --  #> + edges from 6326eef: #>  [1] 1->4 2->4 2->5 3->7 4->1 4->2 4->6 4->7 5->2 6->4 7->3 7->4 # label of vertices of the induced subgraph in the original graph igraph::V(g)[lcc$keep] #> + 7/100 vertices, from 671be26: #> [1] 18 28 38 39 42 49 91"},{"path":"/reference/matrix_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Lists of Matrices — matrix_list-class","title":"Lists of Matrices — matrix_list-class","text":"Basically list matrix components  dimension. Mostly internal igraphmatch use. can various things like arithmetic indexing, done component-wise.","code":""},{"path":"/reference/matrix_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lists of Matrices — matrix_list-class","text":"","code":"matrix_list(ml)  # S4 method for matrix_list,matrix_list %*%(x, y)  # S4 method for matrix_list t(x)  # S4 method for matrix_list dim(x)  # S4 method for matrix_list,ANY,ANY,ANY [(x, i = 1:nrow(x[[1]]), j = 1:ncol(x[[1]]), drop = FALSE)  # S4 method for matrix_list,ANY,missing,ANY [(x, i, drop = FALSE)  # S4 method for matrix_list,missing,ANY,ANY [(x, j, drop = FALSE)  # S4 method for matrix_list,missing,missing,ANY [(x, drop = FALSE)  # S4 method for matrix_list,ANY %*%(x, y)  # S4 method for ANY,matrix_list %*%(x, y)  # S4 method for matrix_list,Matrix %*%(x, y)  # S4 method for Matrix,matrix_list %*%(x, y)  # S4 method for matrix_list,logical sum(x, na.rm = FALSE)  # S4 method for matrix_list,ANY ^(e1, e2)  # S4 method for matrix_list,matrix_list -(e1, e2)  # S4 method for matrix_list,matrix_list +(e1, e2)  # S4 method for matrix_list,matrix_list *(e1, e2)  # S4 method for matrix_list,matrix_list /(e1, e2)  # S4 method for matrix_list,ANY -(e1, e2)  # S4 method for matrix_list,ANY +(e1, e2)  # S4 method for matrix_list,ANY *(e1, e2)  # S4 method for matrix_list,ANY /(e1, e2)  # S4 method for ANY,matrix_list -(e1, e2)  # S4 method for ANY,matrix_list +(e1, e2)  # S4 method for ANY,matrix_list *(e1, e2)  # S4 method for ANY,matrix_list /(e1, e2)  # S4 method for matrix_list,missing -(e1, e2)  # S4 method for matrix_list names(x) <- value"},{"path":"/reference/matrix_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lists of Matrices — matrix_list-class","text":"ml list matrices x Matrix y Matrix Matrix j Matrix drop Matrix na.rm Matrix e1 Matrix e2 Matrix","code":""},{"path":"/reference/pad.html","id":null,"dir":"Reference","previous_headings":"","what":"Pad a matrix object with extra rows/columns of 0s. — pad","title":"Pad a matrix object with extra rows/columns of 0s. — pad","text":"Attempts made make padding efficient employing sparse graphs","code":""},{"path":"/reference/pad.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pad a matrix object with extra rows/columns of 0s. — pad","text":"","code":"pad(m, nr, nc = nr)"},{"path":"/reference/pad.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pad a matrix object with extra rows/columns of 0s. — pad","text":"m matrix nr number rows add nc number columns add. (default = nr)","code":""},{"path":"/reference/pad.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pad a matrix object with extra rows/columns of 0s. — pad","text":"m padded nr rows nc columns zeros.","code":""},{"path":"/reference/plot_graphMatch.html","id":null,"dir":"Reference","previous_headings":"","what":"Plotting methods for visualizing matches — plot,igraph,igraph-method","title":"Plotting methods for visualizing matches — plot,igraph,igraph-method","text":"Two functions provided, match_plot_igraph makes ball stick plot igraph objects match_plot_matrix shows adjacency matrix plot.","code":""},{"path":"/reference/plot_graphMatch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plotting methods for visualizing matches — plot,igraph,igraph-method","text":"","code":"# S4 method for igraph,igraph plot(x, y, match = NULL, color = TRUE, linetype = TRUE, ...)  # S4 method for Matrix,Matrix plot(x, y, match = NULL, col.regions = NULL, at = NULL, colorkey = NULL, ...)"},{"path":"/reference/plot_graphMatch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plotting methods for visualizing matches — plot,igraph,igraph-method","text":"x First graph, either igraph object Matrix y second graph, either igraph object Matrix match result match call. Requires element corr data.frame names corr_A, corr_B. color Whether color edges according graph(s) . linetype Whether set edge line types according graph(s) . ... additional parameters passed either igraph plot function Matrix image function. col.regions NULL default colors, otherwise see image-methods NULL default values (ensures zero grey), otherwise see image-methods colorkey NULL default colorkey, otherwise see image-methods","code":""},{"path":"/reference/plot_graphMatch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plotting methods for visualizing matches — plot,igraph,igraph-method","text":"functions return values invisibly. match_plot_igraph returns union  matched graphs igraph object additional  edge attributes edge_match, color, lty.  match_plot_matrix returns difference  matched graphs.","code":""},{"path":"/reference/plot_graphMatch.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plotting methods for visualizing matches — plot,igraph,igraph-method","text":"Grey edges/pixels indicate common edges, blue indicates edges graph red represents edges graph B. corresponding linetypes solid, long dash, short dash. plots can recreated output code plot(g)  g <- match_plot_igraph(...)  col <- colorRampPalette(c(\"#AA4444\", \"#888888\", \"#44AA44\")) image(m, col.regions = col(256))  m <- match_plot_match(...). plots returns matched vertices.","code":""},{"path":"/reference/plot_graphMatch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plotting methods for visualizing matches — plot,igraph,igraph-method","text":"","code":"set.seed(123) graphs <- sample_correlated_gnp_pair(20, .9, .3) A <- graphs$graph1 B <- graphs$graph2 res <- gm(A, B, 1:4, method = \"percolation\")  plot(A, B, res)  plot(A[], B[], res)"},{"path":"/reference/sample_gnp.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample correlated G(n,p) random graphs — sample_correlated_gnp_pair","title":"Sample correlated G(n,p) random graphs — sample_correlated_gnp_pair","text":"Sample pair correlated G(n,p) random graphs correlation two graphs corr edge probability p.","code":""},{"path":"/reference/sample_gnp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample correlated G(n,p) random graphs — sample_correlated_gnp_pair","text":"","code":"sample_correlated_gnp_pair(n, corr, p, ncore = n, permutation = 1:n, ...)"},{"path":"/reference/sample_gnp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample correlated G(n,p) random graphs — sample_correlated_gnp_pair","text":"n integer. Number total vertices sampled graphs. corr number. target Pearson correlation adjacency matrices generated graphs. must  [0,1] interval. p number. Edge probability two vertices. must open [0,1] interval. ncore integer. Number core vertices. permutation numeric vector permute second graph. ... Passed sample_gnp.","code":""},{"path":"/reference/sample_gnp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample correlated G(n,p) random graphs — sample_correlated_gnp_pair","text":"sample_correlated_gnp_pair returns list two igraph object, named graph1 graph2, whose adjacency matrix entries correlated corr. sample two graphs junk vertices, first ncore vertices core vertices rest junk vertices.","code":""},{"path":"/reference/sample_gnp.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Sample correlated G(n,p) random graphs — sample_correlated_gnp_pair","text":"V. Lyzinski D. E. Fishkind C. E. Priebe (2014), Seeded Graph Matching Correlated Erdos-Renyi Graphs.J. Mach. Learn. Res., pages 3513-3540.","code":""},{"path":[]},{"path":"/reference/sample_gnp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample correlated G(n,p) random graphs — sample_correlated_gnp_pair","text":"","code":"sample_correlated_gnp_pair(n=50, corr=0.3, p=0.5, ncore=40) #> $graph1 #> IGRAPH 64fcc81 U--- 50 607 --  #> + attr: name_1 (g/c), name_2 (g/c), loops_1 (g/l), loops_2 (g/l), type #> | (g/c), p (g/n) #> + edges from 64fcc81: #>  [1] 49--50 46--50 46--48 46--47 45--50 45--49 45--48 45--46 44--50 44--49 #> [11] 44--47 44--46 43--50 43--49 43--48 43--47 43--45 43--44 42--50 42--49 #> [21] 42--48 42--46 42--44 42--43 41--50 41--45 41--42 40--49 40--47 40--43 #> [31] 40--42 39--50 39--48 39--44 39--43 38--50 38--48 38--46 38--45 38--43 #> [41] 38--41 38--40 37--50 37--49 37--48 37--47 37--45 37--39 37--38 36--48 #> [51] 36--47 36--41 36--40 36--39 36--38 36--37 35--50 35--49 35--47 35--45 #> [61] 35--44 35--41 35--40 35--36 34--49 34--47 34--46 34--45 34--43 34--42 #> + ... omitted several edges #>  #> $graph2 #> IGRAPH 7a079e9 U--- 50 614 --  #> + attr: name_1 (g/c), name_2 (g/c), loops_1 (g/l), loops_2 (g/l), #> | type_1 (g/c), type_2 (g/c), p_1 (g/n), p_2 (g/n), type (g/c), p (g/n) #> + edges from 7a079e9: #>  [1] 48--50 48--49 46--50 45--50 45--49 45--47 45--46 44--47 44--46 44--45 #> [11] 43--49 43--48 43--47 43--46 43--45 42--50 42--46 41--49 41--46 41--45 #> [21] 41--44 41--42 40--50 40--47 40--45 40--44 40--43 40--42 39--50 39--48 #> [31] 39--47 39--46 39--45 39--43 39--42 39--41 38--50 38--49 38--47 38--46 #> [41] 38--44 38--40 37--50 37--41 37--40 37--39 36--50 36--48 36--47 36--46 #> [51] 36--44 36--42 36--40 36--38 36--37 35--50 35--48 35--42 35--41 35--40 #> [61] 35--39 34--48 34--47 34--46 34--43 34--41 34--38 34--35 33--49 33--48 #> + ... omitted several edges #>  sample_correlated_gnp_pair(n=5, corr=0.3, p=0.5, permutation=c(1,3,2,4,5)) #> $graph1 #> IGRAPH 3fbe5c5 U--- 5 6 -- Erdos-Renyi (gnp) graph #> + attr: name (g/c), type (g/c), loops (g/l), p (g/n) #> + edges from 3fbe5c5: #> [1] 1--2 1--3 2--3 2--4 2--5 4--5 #>  #> $graph2 #> IGRAPH 807f784 U--- 5 6 -- Erdos-Renyi (gnp) graph #> + attr: name_1 (g/c), name_2 (g/c), type_1 (g/c), type_2 (g/c), loops_1 #> | (g/l), loops_2 (g/l), p_1 (g/n), p_2 (g/n), name (g/c), type (g/c), #> | loops (g/l), p (g/n) #> + edges from 807f784: #> [1] 4--5 3--5 3--4 2--3 1--2 1--3 #>"},{"path":"/reference/sample_ieg.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample graphs from edge probability matrix and correlation matrix — sample_correlated_ieg_pair","title":"Sample graphs from edge probability matrix and correlation matrix — sample_correlated_ieg_pair","text":"Sample pair graphs specified edge probability   correlation pair vertices.","code":""},{"path":"/reference/sample_ieg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample graphs from edge probability matrix and correlation matrix — sample_correlated_ieg_pair","text":"","code":"sample_correlated_ieg_pair(   n,   p_mat,   c_mat,   ncore = n,   directed = FALSE,   loops = FALSE,   permutation = 1:n )  sample_correlated_rdpg_pair(X, corr, ncore = nrow(X), ...)"},{"path":"/reference/sample_ieg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample graphs from edge probability matrix and correlation matrix — sample_correlated_ieg_pair","text":"n integer. Number total vertices sampled graphs. p_mat n--n matrix. Edge probability matrix, entry open (0,1) interval. c_mat n--n matrix. target Pearson correlation matrix, entry open (0,1) interval. ncore integer. Number core vertices. directed Logical scalar, whether generate directed graphs. loops Logical scalar, whether self-loops allowed graph. permutation numeric vector,permute second graph. X matrix. Dot products matrix, entry must open (0,1) interval. corr number. target Pearson correlation adjacency matrices generated graphs. must open (0,1) interval. ... Passed sample_correlated_ieg_pair.","code":""},{"path":"/reference/sample_ieg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample graphs from edge probability matrix and correlation matrix — sample_correlated_ieg_pair","text":"sample_correlated_ieg_pair returns two igraph objects named  graph1 graph2. sample two graphs junk vertices,   first ncore vertices core vertices rest junk   vertices. sample_correlated_rdpg_pair returns two igraph objects named graph1 graph2 sampled random dot product graphs model. sample two graphs junk vertices, first ncore vertices core vertices rest junk vertices.","code":""},{"path":"/reference/sample_ieg.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Sample graphs from edge probability matrix and correlation matrix — sample_correlated_ieg_pair","text":"S. Young E. Scheinerman (2007), Random Dot Product   Graph Models Social Networks. Proceedings 5th International   Conference Algorithms Models Web-graph, pages 138-149. F. Fang D. Sussman V. Lyzinski (2018), Tractable   Graph Matching via Soft Seeding. https://arxiv.org/abs/1807.09299.","code":""},{"path":[]},{"path":"/reference/sample_ieg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample graphs from edge probability matrix and correlation matrix — sample_correlated_ieg_pair","text":"","code":"n <- 50 p_mat <- matrix(runif(n^2),n) c_mat <- matrix(runif(n^2),n) sample_correlated_ieg_pair(n,p_mat,c_mat,ncore=40) #> $graph1 #> IGRAPH 141a3d2 U--- 50 594 --  #> + edges from 141a3d2: #>   [1] 1-- 5 1-- 6 1-- 8 1-- 9 1--10 1--11 1--18 1--21 1--22 1--23 1--24 1--27 #>  [13] 1--29 1--30 1--32 1--35 1--36 1--37 1--38 1--39 1--40 1--41 1--47 1--48 #>  [25] 2-- 3 2-- 4 2-- 7 2-- 9 2--10 2--13 2--14 2--15 2--20 2--21 2--22 2--29 #>  [37] 2--30 2--33 2--34 2--36 2--37 2--39 2--40 2--43 2--45 2--46 3-- 5 3-- 8 #>  [49] 3--12 3--14 3--16 3--18 3--20 3--23 3--24 3--27 3--28 3--32 3--36 3--37 #>  [61] 3--45 3--46 3--49 4-- 5 4-- 7 4-- 8 4--10 4--12 4--13 4--15 4--18 4--20 #>  [73] 4--21 4--25 4--27 4--29 4--35 4--38 4--42 4--43 4--44 4--45 4--47 4--48 #>  [85] 4--49 4--50 5-- 6 5-- 7 5-- 8 5-- 9 5--10 5--11 5--14 5--15 5--16 5--17 #>  [97] 5--19 5--20 5--23 5--24 5--25 5--27 5--28 5--35 5--36 5--37 5--39 5--40 #> + ... omitted several edges #>  #> $graph2 #> IGRAPH fc13d79 U--- 50 607 --  #> + edges from fc13d79: #>   [1] 1-- 5 1-- 8 1--10 1--11 1--18 1--21 1--22 1--23 1--24 1--27 1--28 1--29 #>  [13] 1--32 1--35 1--37 1--39 1--40 1--41 1--44 1--47 1--48 2-- 4 2-- 9 2--13 #>  [25] 2--14 2--15 2--18 2--20 2--21 2--22 2--29 2--33 2--34 2--36 2--37 2--38 #>  [37] 2--39 2--40 2--45 2--46 2--48 3-- 5 3-- 6 3-- 8 3--12 3--13 3--14 3--16 #>  [49] 3--18 3--19 3--23 3--24 3--26 3--27 3--28 3--30 3--32 3--36 3--37 3--44 #>  [61] 3--45 3--46 3--48 3--49 4-- 7 4-- 8 4--10 4--11 4--12 4--15 4--18 4--19 #>  [73] 4--20 4--21 4--25 4--27 4--29 4--35 4--38 4--40 4--42 4--43 4--44 4--45 #>  [85] 4--47 4--48 4--49 5-- 6 5-- 8 5-- 9 5--11 5--12 5--14 5--15 5--16 5--17 #>  [97] 5--18 5--20 5--24 5--25 5--27 5--28 5--29 5--34 5--35 5--36 5--37 5--39 #> + ... omitted several edges #>   ## sample a pair of igraph objects from random dot ## product graphs model with dimension 3 and scale 8 n <- 50 xdim <- 3 scale <- 8 X <- matrix(rgamma(n*(xdim+1),scale,1),n,xdim+1) X <- X/rowSums(X) X <- X[,1:xdim] sample_correlated_rdpg_pair(X,corr=0.5,ncore=40) #> $graph1 #> IGRAPH 7019dc2 U--- 50 216 --  #> + edges from 7019dc2: #>  [1]  1-- 8  2--14  2--24  2--35  2--38  2--41  2--47  2--48  2--49  3-- 7 #> [11]  3--10  3--13  3--14  3--15  3--17  3--23  3--26  3--27  3--36  3--38 #> [21]  3--43  3--44  3--46  3--50  4-- 5  4-- 8  4--11  4--25  4--30  4--37 #> [31]  5-- 8  5--13  5--23  5--26  5--34  6-- 9  6--10  6--42  6--44  7--13 #> [41]  7--18  7--21  7--23  7--26  7--31  7--33  7--36  7--43  8--10  8--13 #> [51]  8--19  8--21  8--22  8--32  8--36  8--49  9--13  9--17  9--20  9--22 #> [61]  9--40 10--16 10--18 10--19 10--20 10--22 10--25 10--34 10--35 11--22 #> [71] 11--40 11--43 12--14 12--15 12--20 12--26 12--30 12--37 12--43 13--17 #> [81] 13--27 13--28 13--34 13--35 13--37 13--39 13--40 13--41 13--42 13--43 #> + ... omitted several edges #>  #> $graph2 #> IGRAPH 92792df U--- 50 210 --  #> + edges from 92792df: #>  [1]  1-- 8  1--21  1--25  1--28  1--46  2--36  2--37  2--38  2--43  3-- 9 #> [11]  3--12  3--15  3--17  3--23  3--26  3--27  3--31  3--36  3--38  4-- 8 #> [21]  4--18  4--25  4--30  5-- 8  5--18  5--26  5--27  5--30  5--32  5--34 #> [31]  5--40  5--46  5--49  6-- 9  6--10  6--20  6--29  6--34  7--13  7--23 #> [41]  7--26  7--28  7--31  7--39  7--42  7--44  8-- 9  8--10  8--13  8--19 #> [51]  8--21  8--22  8--24  8--32  8--36  8--40  8--47  8--49  9--12  9--13 #> [61]  9--17  9--22  9--27  9--28  9--34  9--40 10--16 10--19 10--20 10--22 #> [71] 10--25 10--26 10--27 10--32 10--35 10--41 11--41 12--18 12--20 12--26 #> [81] 12--28 12--30 12--34 12--44 13--17 13--25 13--27 13--34 13--40 13--44 #> + ... omitted several edges #>"},{"path":"/reference/sample_sbm.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample graphs pair from stochastic block model — sample_correlated_sbm_pair","title":"Sample graphs pair from stochastic block model — sample_correlated_sbm_pair","text":"Sample pair random graphs stochastic block model   correlation two graphs corr edge probability   p.","code":""},{"path":"/reference/sample_sbm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample graphs pair from stochastic block model — sample_correlated_sbm_pair","text":"","code":"sample_correlated_sbm_pair(   n,   pref.matrix,   block.sizes,   corr,   core.block.sizes = NULL,   permutation = 1:n,   ... )"},{"path":"/reference/sample_sbm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample graphs pair from stochastic block model — sample_correlated_sbm_pair","text":"n integer. Number vertices graph. pref.matrix matrix giving Bernoulli rates. K--K matrix, k number groups. probability creating edge vertices groups j given element ,j. undirected graphs, matrix must symmetric. block.sizes numeric vector. Give number vertices group. sum vector must match number vertices. corr number. target Pearson correlation adjacency matrices generated graphs. must open (0,1) interval. core.block.sizes numeric vector. Give number core vertices group. Entries smaller block.sizes vector length block.sizes. permutation numeric vector, permute second graph. ... Passed sample_sbm.","code":""},{"path":"/reference/sample_sbm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample graphs pair from stochastic block model — sample_correlated_sbm_pair","text":"Returns list two igraph object, named graph1  graph2. sample two graphs junk vertices,   corresponding block first core.block.sizes vertices core   vertices rest junk vertices.","code":""},{"path":"/reference/sample_sbm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Sample graphs pair from stochastic block model — sample_correlated_sbm_pair","text":"P. Holland K. Laskey S. Leinhardt (1983),   Stochastic Blockmodels: First Steps. Social Networks, pages 109-137. F. Fang D. Sussman V. Lyzinski (2018), Tractable   Graph Matching via Soft Seeding. https://arxiv.org/abs/1807.09299.","code":""},{"path":[]},{"path":"/reference/sample_sbm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample graphs pair from stochastic block model — sample_correlated_sbm_pair","text":"","code":"pm <- cbind( c(.1, .001), c(.001, .05) ) sample_correlated_sbm_pair(n=1000, pref.matrix=pm, block.sizes=c(300,700), corr=0.5) #> $graph1 #> IGRAPH 4e065cc U--- 1000 17089 -- Stochastic block model #> + attr: name (g/c), loops (g/l) #> + edges from 4e065cc: #>  [1]  4-- 6  2-- 7  9--10 10--11  5--12  6--12  7--12  7--13 11--13  3--14 #> [11]  6--16 12--16 10--17 12--17 15--18  6--19  7--19 10--19  2--21 10--21 #> [21] 14--21 19--21 20--21  9--22 15--22  7--23  9--23 12--23 16--24 18--24 #> [31] 15--25 20--25  9--26 15--27 18--27 21--27 24--27 26--27  6--28  8--28 #> [41] 14--28  1--29  6--29 11--29 26--29 27--29 28--29  1--30 11--30 12--30 #> [51] 29--30 10--31  1--32  9--32 25--33 23--34 31--34 12--35  1--36 11--36 #> [61] 24--36  1--37  3--37  6--37 13--37 23--37 24--37 29--37 13--38 16--38 #> [71] 32--38  8--39 12--39 23--39 24--39 36--39  2--40  6--40 35--40 10--41 #> + ... omitted several edges #>  #> $graph2 #> IGRAPH 1574d4f U--- 1000 16833 -- Stochastic block model #> + attr: name_1 (g/c), name_2 (g/c), loops_1 (g/l), loops_2 (g/l), name #> | (g/c), loops (g/l) #> + edges from 1574d4f: #>  [1] 984-- 989 984-- 987 983-- 984 979-- 999 979-- 996 979-- 991 979-- 986 #>  [8] 978--1000 978-- 998 978-- 980 975-- 991 974-- 981 973-- 997 972-- 985 #> [15] 971-- 994 971-- 990 971-- 981 971-- 978 970-- 992 970-- 978 970-- 972 #> [22] 969-- 971 967-- 992 966-- 992 966-- 989 965-- 999 965-- 988 965-- 987 #> [29] 964-- 993 964-- 976 963-- 987 962-- 987 962-- 966 961-- 999 961-- 998 #> [36] 961-- 977 961-- 974 961-- 971 959-- 975 959-- 962 958-- 990 958-- 985 #> [43] 957--1000 957-- 989 957-- 987 957-- 986 957-- 978 957-- 973 956-- 993 #> + ... omitted several edges #>  sample_correlated_sbm_pair(n=1000, pref.matrix=pm, block.sizes=c(300,700), corr=0.5, core.block.sizes=c(200,500)) #> $graph1 #> IGRAPH 320cc19 U--- 1000 16836 -- Stochastic block model #> + attr: name (g/c), loops (g/l) #> + edges from 320cc19: #>  [1]  1-- 2  1-- 6  4-- 8  2-- 9  3-- 9  8--10  9--12  2--13 12--14 12--15 #> [11]  2--16  3--16  5--16 13--16  7--17  8--17 11--17 12--17 14--17  1--18 #> [21] 16--19 18--19 10--20 11--20 17--20  3--21  2--23 11--23 15--23 21--23 #> [31] 11--24 15--24 17--24 20--24 15--25 19--25 23--25  6--26 14--26 26--27 #> [41]  3--28  5--28 15--28 20--28 25--28  9--30 13--30 21--30 10--31 26--31 #> [51] 29--31  9--32 27--32  5--33 18--33 20--33 21--33 21--34 30--34 12--35 #> [61] 20--35 30--35  4--36  5--36 11--36 14--36 24--36 28--36 30--36  8--37 #> [71] 13--37 18--37 24--37 25--37 28--37 12--38 16--38 18--38 25--38 30--38 #> + ... omitted several edges #>  #> $graph2 #> IGRAPH 8d5952b U--- 1000 17004 -- Stochastic block model #> + attr: name_1 (g/c), name_2 (g/c), loops_1 (g/l), loops_2 (g/l), name #> | (g/c), loops (g/l) #> + edges from 8d5952b: #>  [1] 999--1000 988-- 994 985-- 996 985-- 990 985-- 989 984-- 996 983-- 998 #>  [8] 981-- 986 980-- 993 978-- 989 977-- 985 976-- 996 976-- 992 976-- 988 #> [15] 976-- 977 975-- 995 975-- 979 974-- 995 974-- 984 974-- 981 974-- 978 #> [22] 973-- 986 973-- 977 973-- 974 972-- 997 972-- 996 971-- 999 971-- 975 #> [29] 971-- 973 970-- 995 970-- 986 970-- 985 970-- 972 969-- 998 969-- 983 #> [36] 969-- 973 967-- 997 967-- 994 967-- 993 967-- 986 967-- 982 967-- 972 #> [43] 963-- 995 963-- 992 963-- 990 963-- 972 962-- 984 961-- 996 961-- 994 #> + ... omitted several edges #>"},{"path":"/reference/split_igraph.html","id":null,"dir":"Reference","previous_headings":"","what":"Split an igraph object into aligned graphs by attribute — split_igraph","title":"Split an igraph object into aligned graphs by attribute — split_igraph","text":"Given igraph object edge attribute, function finds unique values edge attribute graph returns list igraph objects vertex set element list graph containing edges specified attributed.","code":""},{"path":"/reference/split_igraph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Split an igraph object into aligned graphs by attribute — split_igraph","text":"","code":"split_igraph(g, e_attr, strip_vertex_attr = FALSE)"},{"path":"/reference/split_igraph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Split an igraph object into aligned graphs by attribute — split_igraph","text":"g igraph object e_attr name edge attribute g strip_vertex_attr Whether remove vertex attribute new graphs","code":""},{"path":"/reference/split_igraph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Split an igraph object into aligned graphs by attribute — split_igraph","text":"named list igraph objects names corresponding values  edge attributes.","code":""},{"path":"/reference/split_igraph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Split an igraph object into aligned graphs by attribute — split_igraph","text":"","code":"g <- igraph::sample_gnm(20, 60) igraph::E(g)$color <-   sample(c(\"red\", \"green\"), 60, replace = TRUE) split_igraph(g, \"color\") #> $green #> IGRAPH 16e01af U--- 20 29 -- Erdos-Renyi (gnm) graph #> + attr: name (g/c), type (g/c), loops (g/l), m (g/n), color (e/c) #> + edges from 16e01af: #>  [1]  2-- 5  4-- 5  4-- 6  4-- 7  3-- 9  5-- 9  8--10  4--11  9--12 11--12 #> [11]  1--13  2--13 12--13  9--14 13--14  3--15  5--15  9--15 11--15 13--15 #> [21]  1--16  6--16  8--16 10--16  2--17  4--18  5--18 15--18 19--20 #>  #> $red #> IGRAPH 7c1fd08 U--- 20 31 -- Erdos-Renyi (gnm) graph #> + attr: name (g/c), type (g/c), loops (g/l), m (g/n), color (e/c) #> + edges from 7c1fd08: #>  [1]  1-- 3  2-- 4  3-- 5  1-- 7  3-- 7  6-- 8  4-- 9  7-- 9  4--10  5--11 #> [11]  8--11  3--12  6--12  8--13  4--14 10--14  2--15  4--15  5--16 12--16 #> [21]  6--17 12--17  1--19  5--19  6--19  9--19 13--19 15--19 11--20 15--20 #> [31] 18--20 #>"},{"path":"/reference/splrMatrix_method.html","id":null,"dir":"Reference","previous_headings":"","what":"","title":"","text":"Methods splrMatrix class. behave like Matrix methods though things like output show decomposition. Use .matrix see computed dense matrix.","code":""},{"path":"/reference/splrMatrix_method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"","text":"","code":"# S4 method for splrMatrix show(object)  # S4 method for splrMatrix print(x)  # S4 method for splrMatrix,splrMatrix %*%(x, y)  # S4 method for splrMatrix,matrix_list %*%(x, y)  # S4 method for matrix_list,splrMatrix %*%(x, y)  # S4 method for Matrix,splrMatrix %*%(x, y)  # S4 method for matrix,splrMatrix %*%(x, y)  # S4 method for numeric,splrMatrix %*%(x, y)  # S4 method for numLike,splrMatrix %*%(x, y)  # S4 method for ANY,splrMatrix %*%(x, y)  # S4 method for splrMatrix dim(x)  # S4 method for splrMatrix length(x)  # S4 method for splrMatrix,Matrix %*%(x, y)  # S4 method for splrMatrix,matrix %*%(x, y)  # S4 method for splrMatrix,numeric %*%(x, y)  # S4 method for splrMatrix,numLike %*%(x, y)  # S4 method for splrMatrix,ANY %*%(x, y)  # S4 method for splrMatrix,splrMatrix *(e1, e2)  # S4 method for Matrix,splrMatrix *(e1, e2)  # S4 method for splrMatrix,ddiMatrix *(e1, e2)  # S4 method for ddiMatrix,splrMatrix *(e1, e2)  # S4 method for matrix,splrMatrix *(e1, e2)  # S4 method for numeric,splrMatrix *(e1, e2)  # S4 method for ANY,splrMatrix *(e1, e2)  # S4 method for splrMatrix,matrix *(e1, e2)  # S4 method for splrMatrix,Matrix *(e1, e2)  # S4 method for splrMatrix,numeric *(e1, e2)  # S4 method for splrMatrix,ANY *(e1, e2)  # S4 method for splrMatrix,matrix /(e1, e2)  # S4 method for splrMatrix,Matrix /(e1, e2)  # S4 method for splrMatrix,ANY /(e1, e2)  # S4 method for splrMatrix,splrMatrix +(e1, e2)  # S4 method for splrMatrix,splrMatrix -(e1, e2)  # S4 method for splrMatrix,Matrix +(e1, e2)  # S4 method for splrMatrix,numeric +(e1, e2)  # S4 method for splrMatrix,ANY +(e1, e2)  # S4 method for splrMatrix,missing -(e1, e2 = NULL)  # S4 method for splrMatrix,Matrix -(e1, e2)  # S4 method for splrMatrix,ddiMatrix -(e1, e2)  # S4 method for splrMatrix,numeric -(e1, e2)  # S4 method for splrMatrix,ANY -(e1, e2)  # S4 method for Matrix,splrMatrix +(e1, e2)  # S4 method for numeric,splrMatrix +(e1, e2)  # S4 method for ANY,splrMatrix +(e1, e2)  # S4 method for Matrix,splrMatrix -(e1, e2)  # S4 method for numeric,splrMatrix -(e1, e2)  # S4 method for ANY,splrMatrix -(e1, e2)  # S4 method for splrMatrix,character norm(x, type, ...)  # S4 method for splrMatrix rowSums(x, na.rm = FALSE, dims = 1, ...)  # S4 method for splrMatrix colSums(x, na.rm = FALSE, dims = 1, ...)  # S4 method for splrMatrix rowMeans(x, na.rm = FALSE, dims = 1, ...)  # S4 method for splrMatrix colMeans(x, na.rm = FALSE, dims = 1, ...)  # S4 method for splrMatrix,ANY sum(x, ..., na.rm = FALSE)  # S4 method for splrMatrix mean(x, ...)  # S4 method for splrMatrix,missing,missing,missing [(x, i = NULL, j = NULL, drop = NULL)  # S4 method for splrMatrix,numeric,numeric,logical [(x, i, j, ..., drop = TRUE)  # S4 method for splrMatrix,missing,numeric,logical [(x, i, j, ..., drop = TRUE)  # S4 method for splrMatrix,missing,numeric,missing [(x, i, j, ..., drop = TRUE)  # S4 method for splrMatrix,missing,logical,logical [(x, i, j, ..., drop = TRUE)  # S4 method for splrMatrix,missing,logical,missing [(x, i, j, ..., drop = TRUE)  # S4 method for splrMatrix,numeric,missing,logical [(x, i, j, ..., drop = TRUE)  # S4 method for splrMatrix,numeric,missing,missing [(x, i, j, ..., drop = TRUE)  # S4 method for splrMatrix,logical,missing,logical [(x, i, j, ..., drop = TRUE)  # S4 method for splrMatrix,logical,missing,missing [(x, i, j, ..., drop = TRUE)  # S4 method for splrMatrix,numeric,ANY,logical [(x, i, j, ..., drop = TRUE)  # S4 method for splrMatrix,numeric,logical,logical [(x, i, j, ..., drop = TRUE)  # S4 method for splrMatrix,numeric,ANY,missing [(x, i, j, ..., drop = FALSE)  # S4 method for splrMatrix,logical,ANY,ANY [(x, i, j, ..., drop = TRUE)  # S4 method for splrMatrix,logical,ANY,missing [(x, i, j, ..., drop = TRUE)  # S4 method for splrMatrix,logical,numeric,missing [(x, i, j, ..., drop = TRUE)  # S4 method for splrMatrix,logical,numeric,logical [(x, i, j, ..., drop = TRUE)  # S4 method for splrMatrix,missing,missing,missing [(x, i = NULL, j = NULL, drop = NULL)  # S4 method for splrMatrix,matrix,missing,missing [(x, i, j, ..., drop = TRUE)  # S4 method for splrMatrix,numeric,numeric,ANY [(x, i, j, ...) <- value  # S4 method for splrMatrix,numeric,missing,ANY [(x, i, j, ...) <- value  # S4 method for splrMatrix,missing,numeric,ANY [(x, i, j, ...) <- value  # S4 method for Matrix,ANY,ANY,splrMatrix [(x, i, j, ...) <- value  # S4 method for splrMatrix dim(x)  # S4 method for splrMatrix str(object)  # S4 method for splrMatrix t(x)  # S4 method for splrMatrix diag(x)"},{"path":"/reference/splrMatrix_method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"","text":"object \"Matrix\" x \"Matrix\" y \"Matrix\" e1 \"Matrix\" e2 \"Matrix\" type \"Matrix\" ... \"Matrix\" na.rm \"Matrix\" dims \"Matrix\" \"Matrix\" j \"Matrix\" drop \"Matrix\" value \"Matrix\"","code":""},{"path":"/reference/splrMatrix_method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"","text":"Results matrix operations splrMatrix objects.  Attempts made returned object stored efficiently,  either splrMatrix sparse Matrix.","code":""},{"path":"/reference/splr_constructor.html","id":null,"dir":"Reference","previous_headings":"","what":"Sparse Plus Low-Rank Matrices — splrMatrix-class","title":"Sparse Plus Low-Rank Matrices — splrMatrix-class","text":"\"S4\" class efficient computation sparse plus low-rank matrices. Stores sparse plus low-rank matrices (e.g. matrix factorization centering graphs) form x + %*% t(b) faster computation.","code":""},{"path":"/reference/splr_constructor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sparse Plus Low-Rank Matrices — splrMatrix-class","text":"","code":"splr(x, a = NULL, b = NULL, rank = NULL, dimnames = list(NULL, NULL), ...)  # S4 method for Matrix,Matrix,Matrix splr(x, a = NULL, b = NULL, rank = NULL, dimnames = list(NULL, NULL), ...)"},{"path":"/reference/splr_constructor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sparse Plus Low-Rank Matrices — splrMatrix-class","text":"x \"Matrix\" \"Matrix\" b \"Matrix\" rank rank matrix factorized. dimnames optional - list names matrix ... \"Matrix\"","code":""},{"path":"/reference/splr_constructor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sparse Plus Low-Rank Matrices — splrMatrix-class","text":"splrMatrix object splrMatrix object","code":""},{"path":"/reference/splr_constructor.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Sparse Plus Low-Rank Matrices — splrMatrix-class","text":"x sparse matrix low-rank factor matrix b optional. low-rank factor %*% t(b). b provided, factorized using irlba provided factorize = TRUE","code":""},{"path":[]},{"path":"/reference/splr_sparse_plus_constant.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a constant to a splrMatrix object — splr_sparse_plus_constant","title":"Add a constant to a splrMatrix object — splr_sparse_plus_constant","text":"Add constant splrMatrix object","code":""},{"path":"/reference/splr_sparse_plus_constant.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a constant to a splrMatrix object — splr_sparse_plus_constant","text":"","code":"splr_sparse_plus_constant(x, a)"},{"path":"/reference/splr_sparse_plus_constant.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a constant to a splrMatrix object — splr_sparse_plus_constant","text":"x sparse Matrix object scalar","code":""},{"path":"/reference/splr_sparse_plus_constant.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a constant to a splrMatrix object — splr_sparse_plus_constant","text":"new splrMatrix object x + ","code":""},{"path":"/reference/splr_to_sparse.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert splr ","title":"Convert splr ","text":"Convert splr \"Matrix\" Sparse","code":""},{"path":"/reference/splr_to_sparse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert splr ","text":"","code":"splr_to_sparse(data)"},{"path":"/reference/splr_to_sparse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert splr ","text":"data splrMatrix","code":""},{"path":"/reference/splr_to_sparse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert splr ","text":"sparse Matrix equal x + See Matrix.","code":""},{"path":"/news/index.html","id":"igraphmatch-205","dir":"Changelog","previous_headings":"","what":"iGraphMatch 2.0.5","title":"iGraphMatch 2.0.5","text":"changes igraph 2.0.x avoid warnings due use deprecated functions. Changes address https://github.com/dpmcsuss/iGraphMatch/issues/67. init_start functions start = 'rds_perm_bari' start  = 'rds_from_sim_start' now work correctly. Updates documentation value returned gm better explain list elements components graphMatch class.","code":""},{"path":"/news/index.html","id":"igraphmatch-204","dir":"Changelog","previous_headings":"","what":"iGraphMatch 2.0.4","title":"iGraphMatch 2.0.4","text":"CRAN release: 2024-02-13 Use igraph::upgrade_graph Enron C.Elegans data. Explicitly cast nnodes integer identity_match function.","code":""},{"path":"/news/index.html","id":"igraphmatch-203","dir":"Changelog","previous_headings":"","what":"iGraphMatch 2.0.3","title":"iGraphMatch 2.0.3","text":"CRAN release: 2023-10-26 Updates changes Matrix version 1.6-2","code":""},{"path":"/news/index.html","id":"igraphmatch-202","dir":"Changelog","previous_headings":"","what":"iGraphMatch 2.0.2","title":"iGraphMatch 2.0.2","text":"CRAN release: 2023-06-17 Updates changes Matrix version 1.5-5+","code":""},{"path":"/news/index.html","id":"igraphmatch-201","dir":"Changelog","previous_headings":"","what":"iGraphMatch 2.0.1","title":"iGraphMatch 2.0.1","text":"CRAN release: 2022-09-13 Updates changes Matrix package","code":""},{"path":"/news/index.html","id":"igraphmatch-200","dir":"Changelog","previous_headings":"","what":"iGraphMatch 2.0.0","title":"iGraphMatch 2.0.0","text":"CRAN release: 2021-11-10","code":""},{"path":"/news/index.html","id":"breaking-changes-2-0-0","dir":"Changelog","previous_headings":"","what":"Breaking Changes","title":"iGraphMatch 2.0.0","text":"graph_match_ functions consolidated one function called gm takes method argument indicating methods use. break pretty much code instituted improve flexibility extensibility going forward. returned values functions relatively consistent older values except ’ll lot functionality graphMatch class. get_perm now called get_perm_mat flexible, taking graph match object. Removed match_report, edge_match_info, match_plot_igraph, match_plot_matrix, matched_adjs. Instead use methods associated graphMatch class summary, plot, %*% etc. sample_correlated_rdpg now sample_correlated_rdpg_pair. lapjv lapmod functions now accessed solely do_lap. start functions removed can accessed init_start. row_cor, row_diff, row_perm_stat removed now accessed best_matches. sample_*_with_junk functions removed. Instead use normal sample_* functions ncore parameter. gm_expand_when_stuck removed can accessed specifying ExpandWhenStuck = TRUE calling gm method = \"percolation\".","code":""},{"path":"/news/index.html","id":"list-of-all-removed-functions-2-0-0","dir":"Changelog","previous_headings":"Breaking Changes","what":"List of all removed functions","title":"iGraphMatch 2.0.0","text":"bari_start, edge_match_info, get_perm, gm_indefinite, graph_match_ExpandWhenStuck, graph_match_FW, graph_match_IsoRank, graph_match_PATH, graph_match_Umeyama, graph_match_convex, graph_match_percolation, lapjv, lapmod, match_plot_igraph, match_plot_matrix, match_report, matched_adjs, rds_from_sim_start, rds_perm_bari_start, rds_sinkhorn_start, row_cor, row_diff, row_perm_stat, rperm, sample_correlated_gnp_pair_w_junk,sample_correlated_sbm_pair_w_junk,","code":""},{"path":"/news/index.html","id":"new-features-2-0-0","dir":"Changelog","previous_headings":"","what":"New features","title":"iGraphMatch 2.0.0","text":"Implemented graphMatch class inspecting using matches. .graphMatch can convert data.frames matrices graphMatch class. method argument gm can also take function can leverage graph_match class error checking gm. best_matches compute precision k given true labels.","code":""},{"path":"/news/index.html","id":"minor-improvements-and-fixes-2-0-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and fixes","title":"iGraphMatch 2.0.0","text":"Lots small fixes. Convenience function largest_cc finding largest connected component. Improved documentation check_graph function now exported prepare graphs outside gm functions. matrix_lists can now named lists.","code":""},{"path":"/news/index.html","id":"igraphmatch-101","dir":"Changelog","previous_headings":"","what":"iGraphMatch 1.0.1","title":"iGraphMatch 1.0.1","text":"CRAN release: 2021-01-27 Added NEWS.md file track changes package. Fixed errors Solaris.","code":""}]
