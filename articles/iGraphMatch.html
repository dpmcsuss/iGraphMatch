<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="iGraphMatch">
<title>`iGraphMatch`: an R Package for the Analysis of Graph Matching • iGraphMatch</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js" integrity="sha512-7O5pXpc0oCRrxk8RUfDYFgn0nO1t+jLuIOQdOMRp4APB7uZ4vSjspzp5y6YDtDs4VzUSTbWzBFZ/LKJhnyFOKw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="`iGraphMatch`: an R Package for the Analysis of Graph Matching">
<meta property="og:description" content="iGraphMatch">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-light" data-bs-theme="light"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">iGraphMatch</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">2.0.5</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="active nav-item">
  <a class="nav-link" href="../articles/iGraphMatch.html">Get started</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="../news/index.html">Changelog</a>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/dpmcsuss/iGraphMatch/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="" class="logo" alt=""><h1>`iGraphMatch`: an R Package for the Analysis of Graph Matching</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/dpmcsuss/iGraphMatch/blob/HEAD/vignettes/iGraphMatch.Rmd" class="external-link"><code>vignettes/iGraphMatch.Rmd</code></a></small>
      <div class="d-none name"><code>iGraphMatch.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="abstract">Abstract<a class="anchor" aria-label="anchor" href="#abstract"></a>
</h2>
<p><code>iGraphMatch</code> is an R package developed for matching the
corresponding vertices between two edge-correlated graphs. The package
covers three categories of prevalent graph matching algorithms including
relaxation-based, percolation-based, and spectral-based, which are
applicable to matching graphs under the most general settings: weighted
directed graphs of different order and graphs of multiple layers with
auxiliary graph matching techniques. We provide versatile options to
incorporate prior information in the form of seeds with or without noise
and similarity scores. We also implement an S4 class that overloads
popular operations for matrices in R for efficient computation of sparse
plus low-rank matrices, which is a common structure we can decompose the
matrices into in the process of matching graphs. In addition,
<code>iGraphMatch</code> provides functions to summarize the graph
matching results in terms of several evaluation measures and visualize
the matching performance. Finally, the package also enables the users to
sample correlated random graph pairs from classic random graph models to
generate data for simulations. This paper illustrates the practical
applications of the package to the analysis of graph matching by
detailed examples using real data from social networks and
bioinformatics.</p>
</div>
<div class="section level2">
<h2 id="sec:intro">Introduction<a class="anchor" aria-label="anchor" href="#sec:intro"></a>
</h2>
<p>The graph matching (GM) problem seeks to find an alignment between
the vertex sets of graphs that best preserves common structure across
graphs. This is often posed as minimizing edge disagreements of two
graphs over all alignments. Formally, given <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, two adjacency matrices corresponding
to two graphs <span class="math inline">\(G_1=(V_1, E_1)\)</span> and
<span class="math inline">\(G_2=(V_2, E_2)\)</span>, the goal is to find
<span class="math display">\[\begin{align*}
    \mathop{\mathrm{argmin}}_{P\in\Pi}\lVert A-PBP^T \rVert_F^2
\end{align*}\]</span> where <span class="math inline">\(\Pi\)</span> is
the set of all permutation matrices. GM has wide applications in diverse
fields, such as pattern recognition (<span class="citation">Berg, Berg,
and Malik (2005)</span>, <span class="citation">Caelli and Kosinov
(2004)</span>, <span class="citation">Conte et al. (2004)</span>),
machine learning (<span class="citation">Liu and Qiao (2012)</span>,
<span class="citation">Cour, Srinivasan, and Shi (2007)</span>),
bioinformatics (<span class="citation">Nabieva et al. (2005)</span>,
<span class="citation">Ito et al. (2001)</span>), neuroscience (<span class="citation">Chen et al. (2015)</span>), social network analysis
(<span class="citation">Narayanan and Shmatikov (2009)</span>), and
knowledge graph queries (<span class="citation">Hu et al.
(2018)</span>). More generally, the problem of discovering some true
latent alignment between two networks can often be posed as variations
on the above problem by adjusting the objective function for the
setting.</p>
<p>The well-known graph isomorphism problem is a special case of GM
problem when there exists a bijection between the nodes of two graphs
which exactly preserves the edge structure. In terms of computational
complexity, GM is equivalent to the NP-hard quadratic assignment
problem, which is considered a very challenging problem where few
theoretical guarantees exist, even in special cases (<span class="citation">Finke, Burkard, and Rendl (1987)</span>). For certain
problems where the graphs are nearly isomorphic, polynomial-time
algorithms do exist (<span class="citation">Aflalo, Bronstein, and
Kimmel (2015a)</span>, <span class="citation">Umeyama (1988)</span>) but
these methods frequently break down for more challenging instances.</p>
<p>This paper presents the detailed functionality of the
<code>iGraphMatch</code> R package which serves as a practical tool for
the use of prevalent graph matching methodologies. These algorithms
utilize either the spectral embedding of vertices (<span class="citation">Umeyama (1988)</span>), or relaxations of the objective
function (<span class="citation">Zaslavskiy, Bach, and Vert
(2009)</span>, <span class="citation">V. Lyzinski et al. (2016)</span>),
or apply ideas from percolation theory (<span class="citation">Yartseva
and Grossglauser (2013)</span>, <span class="citation">Kazemi, Hamed
Hassani, and Grossglauser (2015)</span>). The <code>iGraphMatch</code>
package provides versatile options of working with graphs in the form of
matrices, igraph objects or lists of either, and matching graphs under a
generalized setting: weighted, directed, graphs of a different order,
and multilayer graphs.</p>
<p>In addition, the <code>iGraphMatch</code> package incorporates prior
information: seeds and similarities for all the implemented algorithms.
Seeds, or anchors, refer to partial knowledge of the alignment of two
graphs. In practice, seeds can be users with the same name and location
across different social networks or pairs of genes with the same DNA
sequences. Some algorithms like the percolation algorithm (<span class="citation">Yartseva and Grossglauser (2013)</span>, <span class="citation">Kazemi, Hamed Hassani, and Grossglauser (2015)</span>)
which matches two graphs by propagating matching information to
neighboring pairs require seeds to kick off. All algorithms improve
substantially by incorporating seeds and can achieve accurate matching
in polynomial time (<span class="citation">Vince Lyzinski, Fishkind, and
Priebe (2014)</span>). Similarity scores are another commonly used prior
which measures the similarity between pairs of nodes across the graphs.
In the bioinformatics area, BLAST similarity score is an example of
similarity scores that plays an important role in aligning two PPI
networks (<span class="citation">Singh, Xu, and Berger (2008)</span>).
Similarity scores are usually generated from nodal covariates that are
observed in both networks (<span class="citation">Kelley et al.
(2004)</span>, <span class="citation">Belongie, Malik, and Puzicha
(2002)</span>).</p>
<p>While under many scenarios the availability of exact partial matches,
or hard seeding, is not realistic and expensive, the package also
enables utilizing noisy prior information. Similarity scores incorporate
uncertainty by assigning the pair of nodes with higher similarity scores
a bigger chance to match. Seeds with uncertainty and even error can
still be handled by self-correcting graph matching algorithms like the
<span class="smallcaps">Frank-Wolfe</span> algorithm initialized at the
noisy partial matching, called soft seeding. <span class="citation">Fang, Sussman, and Lyzinski (2018)</span> showed that
the <span class="smallcaps">Frank-Wolfe</span> algorithm with soft
seeding scheme converges quickly to the true alignment under the
correlated Erds-R'enyi model with high probability. Thus, the original
intractable problem is reduced to be solvable in polynomial time.</p>
<p>Although there exist some open source software and packages
containing graph matching functionality, <code>iGraphMatch</code>
package provides a centralized repository for common graph matching
methodologies with flexibility, tools for developing graph matching
problem methodology, as well as metrics for evaluating and tools for
visualizing matching performance. Among the alternative GM packages, the
most relevant ones include the <code>igraph</code> (<span class="citation">Csardi and Nepusz (2006)</span>) package which focuses
on descriptive network analysis and graph visualization based on igraph
objects and provides a single graph matching algorithm, the
<code>GraphM</code> (<span class="citation">Zaslavskiy, Bach, and Vert
(2009)</span>) package which implements several GM algorithms proposed
between 1999 and 2009 in C, and the <code>Corbi</code> (<span class="citation">Huang, Wu, and Zhang (2013)</span>) R package which is
particularly designed for studies in bioinformatics and
<code>SpecMatch</code> (<span class="citation">Mateus et al.
(2008)</span>) which only involves implementations of spectral embedding
based GM algorithms and written in C/C++. None of these packages provide
the breadth of tools, flexibility, and ease-of-use provided by the
<code>iGraphMatch</code> package.</p>
<p>The rest of this paper is organized as follows. Section
@ref(sec:background) describes the theoretical representations of the
implemented GM algorithms, correlated random graph models and evaluation
metrics. Section @ref(sec:usage) discusses the functionality and usage
of R functions in the package, illustrated on the synthetic correlated
graph pairs. Section @ref(sec:example) presents more complex examples on
real data with several functions involved in the analysis and section
@ref(sec:conclusion) gives guidelines on using different GM algorithms
under different circumstances and concludes the paper.</p>
</div>
<div class="section level2">
<h2 id="sec:background">Graph matching background<a class="anchor" aria-label="anchor" href="#sec:background"></a>
</h2>
<p>In this section, we give background on graph matching and related
problems followed by descriptions of the principal algorithms
implemented in <code>iGraphMatch</code>. For simplicity, we state all
the algorithms in the context of matching undirected, unweighted graphs
with the same cardinality. All algorithms can also be directly applied
to directed and weighted graphs. In the second subsection, we discuss
the techniques for matching graphs with a different number of vertices
along with other extensions. To conclude the section, we introduce the
statistical models for correlated networks and discuss measures for the
goodness of matching.</p>
<p>For the remainder of this paper we use the following notation. Let
<span class="math inline">\(G_1=(V_1,E_1)\)</span> and <span class="math inline">\(G_2=(V_2,E_2)\)</span> denote two graphs with
<span class="math inline">\(n\)</span> vertices. Let <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> be their corresponding binary symmetric
adjacency matrices. In the setting of seeded graph matching, suppose
without loss of generality, the first <span class="math inline">\(s\)</span> pairs of nodes are seeds for
simplicity. In <code>iGraphMatch</code>, much more flexible seed
specifications are possible, which will be illustrated in examples for
usage of the package in section @ref(sec:usage). Accordingly, let <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> be partitioned as: <span class="math display">\[\begin{equation} \label{eq:seed_blocks}
A=
\begin{bmatrix}
A_{11} &amp; A_{21}^T \\
A_{21} &amp; A_{22}
\end{bmatrix}\text{ and }
B=
\begin{bmatrix}
B_{11} &amp; B_{21}^T \\
B_{21} &amp; B_{22}
\end{bmatrix}
\end{equation}\]</span> where <span class="math inline">\(A_{11},
B_{11}\in\{0, 1\}^{s\times s}\)</span> denote seed-to-seed adjacencies,
<span class="math inline">\(A_{21}, B_{21}\in\{0, 1\}^{(n-s)\times
s}\)</span> denote nonseed-to-seed adjacencies and <span class="math inline">\(A_{22}, B_{22}\in\{0, 1\}^{(n-s)\times
(n-s)}\)</span> denote nonseed-to-nonseed adjacencies. Let <span class="math inline">\(S\)</span> be an <span class="math inline">\(n\)</span>-by-<span class="math inline">\(n\)</span> real-valued matrix of similarity
scores. Let <span class="math inline">\(\Pi\)</span> be the set of all
permutation matrices and <span class="math inline">\(\mathcal{D}\)</span> be the set of all doubly
stochastic matrices.</p>
<div class="section level4">
<h4 id="assignment-problems">Assignment problems<a class="anchor" aria-label="anchor" href="#assignment-problems"></a>
</h4>
<p>Matching or assignment problems are core problems in combinatorial
optimization and appear in numerous fields (<span class="citation">Burkard, Dell’Amico, and Martello (2009)</span>). As we
illustrate in Eq. <span class="math inline">\(\eqref{eq:ob_func}\)</span>, a general version of
the graph matching problem is equivalent to the quadratic assignment
problem (QAP). Similarly, QAP is related to the linear assignment
problem (LAP) which also plays a role in GM. The LAP asks how to assign
<span class="math inline">\(n\)</span> items (eg. workers or nodes in
<span class="math inline">\(G_1\)</span>) to <span class="math inline">\(n\)</span> other items (eg. tasks or nodes in
<span class="math inline">\(G_2\)</span>) with minimum cost. Let <span class="math inline">\(C\)</span> denote an <span class="math inline">\({n\times n}\)</span> cost matrix, where <span class="math inline">\(C_{ij}\)</span> denotes the cost of matching <span class="math inline">\(i\)</span> to <span class="math inline">\(j\)</span>, then the LAP is to find <span class="math display">\[\begin{equation} \label{eq:LAP}
\begin{aligned}
&amp; \mathop{\mathrm{argmin}}_{P\in \Pi}
&amp; \mathrm{trace}(C^TP)
\end{aligned}
\end{equation}\]</span> LAP is solvable in <span class="math inline">\(O(n^3)\)</span> time and there are numerous exact
and approximate methods for both general (<span class="citation">Jonker
and Volgenant (1988)</span>, <span class="citation">Kuhn (1955)</span>)
and special cases, such as sparse cost matrices (<span class="citation">Volgenant (1996)</span>).</p>
<p>The statement of QAP resembles LAP, except that the cost function is
expressed as a quadratic function. Given two <span class="math inline">\(n\text{-by-}n\)</span> matrices <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> which can represent flows between
facilities and the distance between locations respectively, or the
adjacency matrices of two unaligned graphs, the objective function for
QAP is: <span class="math display">\[\begin{equation}\label{eq:qap}
\mathop{\mathrm{argmin}}_{P\in \Pi}    \mathrm{trace}(APBP^T).
\end{equation}\]</span> This problem is NP-hard (<span class="citation">Finke, Burkard, and Rendl (1987)</span>) leading to a
core challenge for any graph matching approach.</p>
<p>As will be illustrated in the rest of the section, some matching
algorithms reduce the graph matching problem to solving a LAP. For these
algorithms, we include similarity scores <span class="math inline">\(S\)</span> by adding an additional term <span class="math inline">\(\mathrm{trace}(S^TP)\)</span> to the reduced
objective function.</p>
</div>
<div class="section level3">
<h3 id="subsec:gm">Graph matching algorithms<a class="anchor" aria-label="anchor" href="#subsec:gm"></a>
</h3>
<p>In the <code>iGraphMatch</code> package, we implement three types of
prevalent GM algorithms. The first group uses relaxations of the
objective function, including convex, concave, and indefinite
relaxations. The second group consists of algorithms that apply ideas
from percolation theory, where matching information is spread from an
initial set of matched nodes. The last group is based on the spectral
embedding of vertices.</p>
<div class="section level4">
<h4 id="relaxation-based-algorithms">Relaxation-based algorithms<a class="anchor" aria-label="anchor" href="#relaxation-based-algorithms"></a>
</h4>
<p>These approaches relax the constraint that <span class="math inline">\(P\)</span> is a permutation matrix to require only
that <span class="math inline">\(P\)</span> is doubly stochastic,
optimizing over <span class="math inline">\(\mathcal{D}\)</span>, the
convex hull of <span class="math inline">\(\Pi\)</span>. When <span class="math inline">\(P\)</span> is a permutation matrix <span class="math display">\[\begin{equation}
\label{eq:ob_func}
    \lVert A-PBP^T \rVert_F^2 = \lVert AP-PB \rVert_F^2 = \lVert A
\rVert_F^2 + \lVert B \rVert_F^2 - 2\cdot \mathrm{trace}APBP^T.
\end{equation}\]</span> However, these equalities do not hold for all
<span class="math inline">\(P\in \mathcal{D}\)</span>, leading to
different relaxations.</p>
<p>The second term of Eq.<span class="math inline">\(\eqref{eq:ob_func}\)</span> is a convex function
and optimizing it over <span class="math inline">\(P\in\mathcal{D}\)</span> gives the convex
relaxation, where the gradient at <span class="math inline">\(P\)</span>
to the convex relaxed objective function is <span class="math inline">\(-4 APB + 2A^TAP + 2PBB^T\)</span>. The last
equality in Eq. <span class="math inline">\(\eqref{eq:ob_func}\)</span>
shows that minimizing edge disagreements is equivalent to maximizing the
number of edge agreements, <span class="math inline">\(\mathrm{trace}
APBP^T\)</span>, a QAP. Optimizing the indefinite function over <span class="math inline">\(\mathcal{D}\)</span> gives the indefinite
relaxation with gradient <span class="math inline">\(-2APB\)</span>
(<span class="citation">V. Lyzinski et al. (2016)</span>).</p>
<table style="width:100%;" class="table">
<caption>(#tab:relaxation) Summary of relaxation methods for graph
matching problem.</caption>
<colgroup>
<col width="12%">
<col width="19%">
<col width="16%">
<col width="14%">
<col width="19%">
<col width="17%">
</colgroup>
<thead><tr class="header">
<th>Relaxation</th>
<th>Objective Function</th>
<th>Domain</th>
<th>GM Algorithm</th>
<th>Optimization Guarantee</th>
<th>Optimum Form</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>None</td>
<td><span class="math inline">\(\lVert A-PBP^T \rVert_F^2\)</span></td>
<td><span class="math inline">\(\Pi\)</span></td>
<td>NA</td>
<td></td>
<td><span class="math inline">\(\Pi\)</span></td>
</tr>
<tr class="even">
<td>Indefinite</td>
<td><span class="math inline">\(\mathrm{tr}ADBD^T\)</span></td>
<td><span class="math inline">\(\mathcal{D}\)</span></td>
<td><span class="smallcaps">FW</span></td>
<td>Local</td>
<td>
<span class="math inline">\(\mathcal{D}\)</span> (often <span class="math inline">\(\Pi\)</span>)</td>
</tr>
<tr class="odd">
<td>Convex</td>
<td><span class="math inline">\(\lVert AD-DB \rVert_F^2\)</span></td>
<td><span class="math inline">\(\mathcal{D}\)</span></td>
<td><span class="smallcaps">FW, PATH</span></td>
<td>Global</td>
<td><span class="math inline">\(\mathcal{D}\)</span></td>
</tr>
<tr class="even">
<td>Concave</td>
<td><span class="math inline">\(-\mathrm{tr}(\Delta
D)-2\mathrm{tr}(L_1^T D L_2 D^T)\)</span></td>
<td><span class="math inline">\(\mathcal{D}\)</span></td>
<td><span class="smallcaps">PATH</span></td>
<td>Local</td>
<td><span class="math inline">\(\Pi\)</span></td>
</tr>
</tbody>
</table>
<p>Generally, the convex relaxation leads to a solution that is not
guaranteed to be near the solution to the original GM. However, <span class="citation">Aflalo, Bronstein, and Kimmel (2015a)</span> introduced
the class of “friendly” graphs based on the spectral properties of the
adjacency matrices to characterize the applicability of the convex
relaxation. Matching two friendly graphs by using the convex relaxation
is guaranteed to find the exact solution to the GM problem.
Unfortunately, this class is quite limiting and does not hold for most
statistical models or real-world examples.</p>
<p>Another relaxation is the concave relaxation used in the PATH
algorithm (<span class="citation">Zaslavskiy, Bach, and Vert
(2009)</span>). The concave relaxation uses the Laplacian matrix defined
as <span class="math inline">\(L=D-A\)</span>, where <span class="math inline">\(D\)</span> is the diagonal degree matrix with
diagonal entries <span class="math inline">\(D_{ii}=\sum_{i=1}^N
A_{ij}\)</span>. Assume <span class="math inline">\(L_i\)</span> and
<span class="math inline">\(D_i\)</span>, <span class="math inline">\(i=1,2\)</span>, are the Laplacian matrices and
degree matrices for <span class="math inline">\(G_1\)</span> and <span class="math inline">\(G_2\)</span> respectively, then we can rewrite the
objective function as <span class="math display">\[\begin{equation}
\label{eq:concave}
\begin{split}
    \lVert A-PBP^T\rVert_F^2 &amp; = \lVert AP-PB \rVert_F^2\\
    &amp; = \lVert (D_1P-PD_2)-(L_1P-PL_2)\rVert_F^2\\
    &amp; = -\mathrm{trace}(\Delta
P)+\mathrm{trace}(L_1^2)+\mathrm{trace}(L_2^2)-2\mathrm{trace}(L_1^T P
L_2 P^T),
\end{split}
\end{equation}\]</span> where the matrix <span class="math inline">\(\Delta_{ij}=(D_{2_{jj}}-D_{1_{ii}})^2\)</span>.
Dropping the terms not dependent on <span class="math inline">\(P\)</span> in equation <span class="math inline">\(\ref{eq:concave}\)</span>, we obtain the concave
function <span class="math inline">\(-\mathrm{trace}(\Delta
P)-2\mathrm{trace}(L_1^T P L_2 P^T)\)</span> on <span class="math inline">\(\mathcal{D}\)</span>.</p>
<p>A summary of the different relaxations is provided in Table <span class="math inline">\(\ref{tab:relaxation}\)</span>. Relaxing the
discrete problem to a continuous problem breaks the equivalence to the
original formulation of the edge disagreement and enables employing
algorithms based on gradient descent.</p>
<div class="section level5">
<h5 id="frank-wolfe-methodology">
<span class="smallcaps">Frank Wolfe</span> methodology<a class="anchor" aria-label="anchor" href="#frank-wolfe-methodology"></a>
</h5>
<p><span class="citation">V. Lyzinski et al. (2016)</span> introduced an
algorithm for the relaxed graph matching problem, with each iteration
computable in polynomial time, that can find local optima for the
relaxations above. The &lt;span
style=“font-variant:small-caps;”&gt;Frank-Wolfe (FW) (<span class="citation">Frank and Wolfe (1956)</span>) methodology is an
iterative gradient ascent approach composed of two steps. The first step
finds an ascent direction that maximizes the gradient ascent. In this
case the ascent direction is a permutation matrix which is a vertex of
the polytope of doubly stochastic matrices. For the convex, indefinite,
and concave relaxations, this corresponds to a LAP with the gradient as
the cost function. The second step performs a line search along the
ascent direction to optimize the relaxed objective function. As the
objectives are all quadratic, this line search is simply requires
optimizing a single-variable quadratic function along a line segment.
After the iterative algorithm converges, the final step of the procedure
is to project the doubly stochastic matrix back to the set of
permutation matrices, which is also a LAP.</p>
<p>The various relaxed forms can all serve as the objective function
<span class="math inline">\(f(\cdot)\)</span> in the <span class="smallcaps">FW</span> Methodology, but in all cases a matrix <span class="math inline">\(D^0\in \mathcal{D}\)</span> must be chosen to
initialize the procedure. For the convex relaxation, the <span class="smallcaps">FW</span> methodology is guaranteed to converge to the
global optimum regardless of the <span class="math inline">\(D^0\)</span>. On the other hand, the <span class="smallcaps">FW</span> algorithm for the indefinite relaxation is
not guaranteed to find a global optimum so the initialization is
critical.</p>
<p>In many instances, the optimal solution to the convex relaxation lies
in the interior of <span class="math inline">\(\mathcal{D}\)</span>.
This can lead to inaccurate solutions after the last projection step.
The local optima for the indefinite relaxation are often at extreme
points of <span class="math inline">\(\mathcal{D}\)</span>, meaning the
final projection often does nothing.</p>
<p>The default initialization for the indefinite problem is at the
barycenter matrix, <span class="math inline">\(D^0 =
\frac{1}{n}11^T\)</span>, but many other initialization procedures can
be used. These include randomized initializations, initializations based
on similarity matrices, and initializing the indefinite relaxation at
the interior point solution of the convex relaxation (<span class="citation">Aflalo, Bronstein, and Kimmel (2015b)</span>). When
prior information regarding a partial correspondence is known to be
noisy, rather than incorporating this information as seeds, one can
incorporate it as “soft” seeds which are used to generate the
initialization (<span class="citation">Fang, Sussman, and Lyzinski
(2018)</span>).</p>
<p>When prior information is available in the form of seeds, the seeded
graph matching problem (<span class="citation">Vince Lyzinski, Fishkind,
and Priebe (2014)</span>) works on the objective function <span class="math inline">\(\ref{eq:ob_func}\)</span> with the permutation
matrix <span class="math inline">\(P^{n\times n}\)</span> substituted by
<span class="math inline">\(I_s\oplus P^{(n-s)\times (n-s)}\)</span>,
the direct sum of an <span class="math inline">\(s\times s\)</span>
identity matrix and an <span class="math inline">\((n-s)\times
(n-s)\)</span> permutation matrix.</p>
<p>Employing the indefinite relaxed objective function incorporating
seeds, we formulate the problem as finding <span class="math display">\[\begin{align*}
    \hat{P} % &amp;= \argmin_{P\in \Pi} \mathrm{trace} A(I_s\oplus
P)B(I_s\oplus P)^T \\
    &amp;= \mathop{\mathrm{argmax}}_{P\in\mathcal{D}}
2\cdot\mathrm{trace}P^TA_{21}B_{21}^T+\mathrm{trace}A_{22}PB_{22}P^T
\end{align*}\]</span> where the gradient to the objective function is
<span class="math display">\[\begin{equation} \label{eq:sgm_gradient}
  \nabla f(P)=2\cdot A_{21}B_{21}^T+2\cdot A_{22}PB_{22}.
\end{equation}\]</span></p>
<p>In total, this uses the information between seeded nodes and
nonseeded nodes and the nonseed-to-nonseed information. Applying seeded
graph matching to the convex relaxation and concave relaxation closely
resembles the case of indefinite relaxation.</p>
</div>
<div class="section level5">
<h5 id="path-algorithm">
<span class="smallcaps">PATH</span> algorithm<a class="anchor" aria-label="anchor" href="#path-algorithm"></a>
</h5>
<p><span class="citation">Zaslavskiy, Bach, and Vert (2009)</span>
introduced a convex-concave programming approach to approximately solve
the graph matching problem. The concave relaxation has the same solution
as the original graph matching problem. The <span class="smallcaps">PATH</span> algorithm finds a local optimum to the
concave relaxation by considering convex combinations of the convex
relaxation <span class="math inline">\(F_0(P)\)</span> and the concave
relaxation <span class="math inline">\(F_1(P)\)</span> denoted by <span class="math inline">\(F_{\lambda} =(1 - \lambda) F_0 + \lambda
F_1\)</span>. Starting from the solution to the convex relaxation (<span class="math inline">\(\lambda=0\)</span>) the algorithm iteratively
performs gradient ascent using the FW methodology at <span class="math inline">\(F_\lambda\)</span>, increasing <span class="math inline">\(\lambda\)</span> after each iteration, until <span class="math inline">\(\lambda = 1\)</span>.</p>
</div>
</div>
<div class="section level4">
<h4 id="percolation-based-algorithms">Percolation-based algorithms<a class="anchor" aria-label="anchor" href="#percolation-based-algorithms"></a>
</h4>
<p>Under the <span class="smallcaps">FW</span> methodology, all the
nodes admit a correspondence but the (relaxed) matching correspondence
evolves through iterations. On the other hand, percolation approaches
start with a set of seeds, adding one new match at each iteration. The
new matches are fixed and hence not updated in future iterations.</p>
<p>Each iteration expands the set of matched nodes by propagating the
current matching information to neighbors. The guiding intuition is that
more matched neighbors are an indicator of a more plausible match, an
intuition analogous to the gradient ascent approaches above. We will
present two algorithms in this category where the <span class="smallcaps">ExpandWhenStuck</span> algorithm is an extension to
the <span class="smallcaps">Percolation</span> algorithm.</p>
<p>There are some distinctions about the inputs and outputs of
percolation methods compared to the above relaxation methods.</p>
<div class="section level5">
<h5 id="percolation-algorithm">
<span class="smallcaps">Percolation</span> Algorithm<a class="anchor" aria-label="anchor" href="#percolation-algorithm"></a>
</h5>
<p><span class="citation">Yartseva and Grossglauser (2013)</span>
provides a simple and fast approach to solve the graph matching problem
by starting with a handful of seeds and propagating to the rest of the
graphs. At each iteration, the matching information up to the current
iteration is encoded in a subpermutation matrix <span class="math inline">\(P\)</span> where <span class="math inline">\(P_{ij}=1\)</span> if <span class="math inline">\(i\)</span> is matched to <span class="math inline">\(j\)</span>, and <span class="math inline">\(0\)</span> otherwise.</p>
<p>The <span class="smallcaps">Percolation</span> algorithm searches for
the most promising new match among the unmatched pairs through the mark
matrix, <span class="math inline">\(M=APB\)</span>, which is the
gradient of the indefinite relaxation when extended to sub-doubly
stochastic matrices. When similarity scores are available, they are
added to the mark matrix to combine topological structure and similarity
scores.</p>
<p>Adopting analogous partitions on the adjacency matrices as in
equation <span class="math inline">\(\eqref{eq:seed_blocks}\)</span>, we
let <span class="math inline">\(A_{21}, B_{21}\)</span> denote
sub-matrix corresponding to potential adjacencies between unmatched and
matched nodes. Since all the candidates of matched pairs are permanently
removed from consideration, we need only consider <span class="math inline">\(M'=A_{21}B_{21}^T\)</span>, the sub-matrix of
<span class="math inline">\(M\)</span> corresponding to the unmatched
nodes in both graphs. As a result, the <span class="smallcaps">Percolation</span> algorithm only uses
matched-to-unmatched information to generate new matches.</p>
<p>Moreover, the mark matrix <span class="math inline">\(M\)</span> can
also be interpreted as encoding the number of matched neighboring pairs
for each pair of nodes <span class="math inline">\(i\in V_1\)</span>,
<span class="math inline">\(j\in V_2\)</span>. Suppose <span class="math inline">\(u, u'\in V_1\)</span>, <span class="math inline">\(v,v'\in V_2\)</span>, <span class="math inline">\([u,u']\in E_1\)</span> and <span class="math inline">\([v,v']\in E_2\)</span>, then <span class="math inline">\((u',v')\)</span> is a neighboring pair of
<span class="math inline">\((u,v)\)</span>. In each iteration, while
there remain unmatched nodes with more than <span class="math inline">\(r\)</span> matched neighboring pairs, the
percolation algorithm matches the pair of nodes with the highest score
<span class="math inline">\(M_{uv}\)</span>,<br>
and adds one mark to all the neighboring pairs of <span class="math inline">\((u,v)\)</span>. Note that the algorithm may stop
before all nodes are matched, leading to the return of a partial
match.</p>
<p>There is only one tuning parameter in the <span class="smallcaps">Percolation</span> algorithm, the threshold <span class="math inline">\(r\)</span> which controls a tradeoff between
quantity of matches and quality of matches. With a small threshold, the
algorithm has a larger chance of matching wrong pairs. If <span class="math inline">\(r\)</span> is larger, then the algorithm might
stop before matching many pairs (<span class="citation">Kazemi, Hamed
Hassani, and Grossglauser (2015)</span>).</p>
<p>The <span class="smallcaps">Percolation</span> algorithm can be
generalized to matching weighted graphs by making an adjustment to how
we measure the matching information from the neighbors. Since we prefer
to match edges with smaller weight differences and higher absolute
weights, we propose to adopt the following update formula for the score
associated with each pair of nodes <span class="math inline">\((i,j)\)</span>: <span class="math display">\[M_{ij}=M_{ij} + \sum_{u\in N(i)}\sum_{v\in
N(j)}1-\frac{|w_{iu}-w_{jv}|}{\max(|w_{iu}|, |w_{jv}|)}.\]</span> Thus,
the score contributed by each neighboring pair of <span class="math inline">\((i,j)\)</span> is a number in <span class="math inline">\([0,1]\)</span>.</p>
</div>
<div class="section level5">
<h5 id="expandwhenstuck-algorithm">
<span class="smallcaps">ExpandWhenStuck</span> Algorithm<a class="anchor" aria-label="anchor" href="#expandwhenstuck-algorithm"></a>
</h5>
<p><span class="citation">Kazemi, Hamed Hassani, and Grossglauser
(2015)</span> extends the <span class="smallcaps">Percolation</span>
algorithm to a version that can operate with a smaller number of seeds.
Without enough seeds, when there are no more unmatched pairs with a
score higher or equal to the threshold <span class="math inline">\(r\)</span>, the <span class="smallcaps">Percolation</span> algorithm would stop even if there
are still unmatched pairs. <span class="smallcaps">ExpandWhenStuck</span> uses all pairs of nodes with at
least one matched neighboring pair, <span class="math inline">\(M_{ij}\geq 1\)</span>, as new seeds to restart the
matching process by adding one mark to all of the new seeds’ neighboring
pairs, without updating the matched set. If the updated mark matrix
consists of new pairs with marks greater or equal to <span class="math inline">\(r\)</span>, then the percolation algorithm
continues, leading to larger matched sets.</p>
</div>
</div>
<div class="section level4">
<h4 id="spectral-based-algorithm">Spectral-based algorithm<a class="anchor" aria-label="anchor" href="#spectral-based-algorithm"></a>
</h4>
<p>Another class of graph matching algorithms uses the spectral
properties of adjacency matrices.</p>
<div class="section level5">
<h5 id="isorank-algorithm">
<span class="smallcaps">IsoRank</span> Algorithm<a class="anchor" aria-label="anchor" href="#isorank-algorithm"></a>
</h5>
<p><span class="citation">Singh, Xu, and Berger (2008)</span> propose
the <span class="smallcaps">IsoRank</span> algorithm that uses
neighboring topology and similarity scores and exploits spectral
properties of the solution. The <span class="smallcaps">IsoRank</span>
algorithm is also based on the relaxation-based algorithms by encoding
the topological structure of two graphs in <span class="math inline">\(ADB\)</span>, which is again proportional to the
gradient of the indefinite relaxation. However, the representations of
each term of <span class="math inline">\(ADB\)</span> are slightly
different. <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are the column-wise normalized
adjacency matrices and <span class="math inline">\(D\)</span> is not
necessarily a doubly stochastic matrix yet <span class="math inline">\(D_{ij}\)</span> still indicates how promising it
is to match <span class="math inline">\(i\in V_1\)</span> to <span class="math inline">\(j\in V_2\)</span>.</p>
<p>Similar to the idea of <span class="smallcaps">Percolation</span>
algorithm, the intuition is that the impact of a pair of matched nodes
is evenly distributed to all of their neighbors to propagate plausible
matches. This is achieved by solving the eigenvalue problem <span class="math display">\[\begin{align}\label{eq:Iso1}
    \mathrm{vec}(D)=(A\otimes B) \mathrm{vec}(D),
\end{align}\]</span> where <span class="math inline">\(\mathrm{vec}(D)\)</span> denotes the vectorization
of matrix <span class="math inline">\(D\)</span>, and the right hand
side is equivalent to <span class="math inline">\(ADB\)</span>.</p>
<p>To combine network-topological structure and similarity scores in the
objective function, the normalized similarity score <span class="math inline">\(E\)</span> is added to the right hand side of Eq.
<span class="math inline">\(\ref{eq:Iso1}\)</span>, where <span class="math inline">\(E=S/\|S\|_1\)</span>, and <span class="math inline">\(|\cdot|_1\)</span> denotes the L1 norm.</p>
<p>Note that when similarity score is not available as prior
information, we can also construct a doubly stochastic similarity score
matrix from seeds by taking <span class="math inline">\(I_{s\times
s}\oplus \frac{1}{n-s}11_{(n-s)\times (n-s)}\)</span>. To solve the
eigenvalue problem <span class="math inline">\(\ref{eq:Iso1}\)</span>,
we resort to the power method. Finally, the global alignment is
generated by a greedy algorithm or using the algorithms for solving the
linear assignment problem (LAP).</p>
</div>
<div class="section level5">
<h5 id="umeyama-algorithm">
<span class="smallcaps">Umeyama</span> algorithm<a class="anchor" aria-label="anchor" href="#umeyama-algorithm"></a>
</h5>
<p><span class="citation">Umeyama (1988)</span> is a spectral approach
to find approximate solutions to the graph matching problem. Assuming
eigendecompositions of adjacency matrices <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> as <span class="math inline">\(A=U_A\Lambda_AU_A^T\)</span> and <span class="math inline">\(B=U_B\Lambda_BU_B^T\)</span>, let <span class="math inline">\(|U_A|\)</span> and <span class="math inline">\(|U_B|\)</span> be matrices which takes absolute
values of each element of <span class="math inline">\(U_A\)</span> and
<span class="math inline">\(U_B\)</span>. Such modification to the
eigenvector matrices guarantees the uniqueness of eigenvector selection.
The global mapping is obtained by minimizing the differences between
matched rows of <span class="math inline">\(U_A\)</span> and <span class="math inline">\(U_B\)</span>: <span class="math display">\[\begin{align*}
    \hat{P}=\mathop{\mathop{\mathrm{argmin}}}_{P\in\Pi}\lVert
|U_A|-P|U_B|\rVert_F=\mathop{\mathop{\mathrm{argmax}}}_{P\in\Pi}\mathrm{trace}(|U_B||U_A|^TP)
\end{align*}\]</span></p>
<p>The <span class="smallcaps">Umeyama</span> algorithm can be
generalized to matching directed graphs by eigendecomposing the
Hermitian matrices <span class="math inline">\(E_A\)</span> and <span class="math inline">\(E_B\)</span> derived from the asymmetric adjacency
matrices of the directed graphs. The Hermitian matrix for the adjacency
matrix <span class="math inline">\(A\)</span> is defined as <span class="math inline">\(E_A=A_S+iA_N\)</span>, where <span class="math inline">\(A_S=(A+A^T)/2\)</span> is a symmetric matrix,
<span class="math inline">\(A_N=(A-A^T)/2\)</span> is a skew-symmetric
matrix and <span class="math inline">\(i\)</span> is the imaginary unit.
Similarly, we can define the Hermitian matrix for <span class="math inline">\(B\)</span>. Assume the eigendecompositions of
<span class="math inline">\(E_A\)</span> and <span class="math inline">\(E_B\)</span> as follows: <span class="math display">\[\begin{align*}
    E_A=W_A\Gamma_AW_A^*, \quad  E_B=W_B\Gamma_BW_B^*
\end{align*}\]</span> and we aim at searching for: <span class="math display">\[\begin{align*}
    \hat{P}=\mathop{\mathop{\mathrm{argmax}}}_{P\in\Pi}\mathrm{trace}(|W_B||W_A|^TP)
\end{align*}\]</span> Note that the <span class="smallcaps">Umeyama</span> algorithm works on the condition that
two graphs are isomorphic or nearly isomorphic.</p>
</div>
</div>
</div>
<div class="section level3">
<h3 id="auxiliary-graph-matching-tools">Auxiliary graph matching tools<a class="anchor" aria-label="anchor" href="#auxiliary-graph-matching-tools"></a>
</h3>
<div class="section level4">
<h4 id="centering-technique">Centering technique<a class="anchor" aria-label="anchor" href="#centering-technique"></a>
</h4>
<p>Instead of encoding the non-adjacencies by zeros in the adjacency
matrices, the centering technique (<span class="citation">Sussman et al.
(2018)</span>) assigns negative values to such edges. The first approach
is encoding non-adjacent node-pairs as <span class="math inline">\(-1\)</span> with centered adjacency matrices <span class="math inline">\(\tilde{A}=2A-\textbf{J}\)</span> and <span class="math inline">\(\tilde{B}=2B-\textbf{J}\)</span>, where <span class="math inline">\(\textbf{J}\)</span> is a matrix of all ones. An
alternative approach relies on modeling assumptions where the pair of
graphs are correlated but do not share a global structure. We match
<span class="math inline">\(\tilde{A} = A-\Lambda_A\)</span> and <span class="math inline">\(\tilde{B} = B-\Lambda_B\)</span>, where <span class="math inline">\(\Lambda\)</span> is an <span class="math inline">\(n\text{-by-}n\)</span> matrix with <span class="math inline">\(ij\)</span>-th entry denoting an estimated
marginal probability of an edge. In general, <span class="math inline">\(\Lambda\)</span> is unknown but there are methods
in the literature to estimate <span class="math inline">\(\Lambda\)</span>.</p>
<p>Matching centered graphs changes the rewards for matching edges,
non-edges, and the penalties for mismatches. Adapting the centering
technique for the problem at hand can be used to find specific types of
correspondences. This can also be combined with constructing multilayer
networks out of single layer networks to match according to multiple
criteria (<span class="citation">Li and Sussman (2019)</span>, <span class="citation">Fan et al. (2020)</span>). The centering technique can
be applied to any of the implemented graph matching algorithm. It is
especially useful when padding graphs with differing numbers of vertices
to distinguish isolated vertices from padded vertices.</p>
</div>
<div class="section level4">
<h4 id="padding-graphs-of-different-orders">Padding graphs of different orders<a class="anchor" aria-label="anchor" href="#padding-graphs-of-different-orders"></a>
</h4>
<p>Until this section, we have been considering matching two graphs
whose vertex sets are of the same cardinality. However, matching graphs
with different orders are commonly seen in real-world problems.</p>
<p>Suppose <span class="math inline">\(A\in\{0,1\}^{n\times n}\)</span>
and <span class="math inline">\(B\in\{0,1\}^{n_c\times n_c}\)</span>
with <span class="math inline">\(n_c&lt;n\)</span>. One can then pad the
smaller graph with extra vertices to match the order of the larger
graph, <span class="math inline">\(\tilde{B}=B\oplus
\textbf{0}_{n-n_c}\)</span> and match <span class="math inline">\(A\)</span> and <span class="math inline">\(\tilde{B}\)</span>. Every implemented graph
matching algorithm in the <code>iGraphMatch</code> package automatically
handles input graphs with a different number of vertices using sparse
padding with minimal memory impact.</p>
<p>Since the isolated vertices and the padded vertices share the same
topological structure, it can be useful to center the original graphs
first then pad the smaller graph in the same manner. This approach
serves to differentiate between isolated vertices the padded ones. It’s
theoretically verified that in the correlated graph model, the centered
padding scheme is guaranteed to find the true correspondence between the
nodes of <span class="math inline">\(G_1\)</span> and the induced
subgraph of <span class="math inline">\(G_2\)</span> under mild
conditions even if <span class="math inline">\(|V_1|\ll|V_2|\)</span>,
but the true alignment is not guaranteed without centering (<span class="citation">Sussman et al. (2018)</span>).</p>
</div>
<div class="section level4">
<h4 id="exploiting-sparse-and-low-rank-structure">Exploiting sparse and low-rank structure<a class="anchor" aria-label="anchor" href="#exploiting-sparse-and-low-rank-structure"></a>
</h4>
<p>Many real-world graphs, especially large graphs, are often very
sparse with <span class="math inline">\(o(n^2)\)</span> and often <span class="math inline">\(\theta(n)\)</span> edges. This can increase the
difficulty of the graph matching problem due to the fact that there are
fewer potential edges to match, but sparse graphs also come with
computational advantages. We rely on <code>igraph</code> and
<code>Matrix</code> for efficient storage of these structures as well as
the efficient implementation of various matrix operations. We also use
the LAPMOD algorithm for sparse LAP problems (<span class="citation">Volgenant (1996)</span>) (see below).</p>
<p>Similarly, a low-rank structure appears in some of the procedures
including starting at the rank-1 barycenter matrix and the different
centering schemes. Since low-rank matrices are generally not sparse and
visa-versa we implemented the <code>splr</code> S4 class, standing for
sparse plus low-rank matrices. This class inherits from the
<code>Matrix</code> class and includes slots for an <span class="math inline">\(n\times n\)</span> sparse matrix <code>x</code>
and <span class="math inline">\(n\times d\)</span> dense matrices
<code>a</code> and <code>b</code>, to represent matrices of the form
<code>x + tcrossprod(a, b)</code>. This class implements efficient
methods for matrix multiplication and other operations that exploit the
sparse and low-rank structure of the matrices. Specifically, these
methods often require only <span class="math inline">\(O(\|x\|_0) +
O(nd)\)</span> storage as opposed to <span class="math inline">\(O(n^2)\)</span> required for densely stored
matrices, and enjoy analogous computational advantages. While users can
also use these matrices explicitly, most use of them is automatic within
functions such as <code>init_start</code> and <code>center_graph</code>
and the matrices can largely be used interchangeably with other
matrices.</p>
</div>
<div class="section level4">
<h4 id="sssec:lap_methods">LAP methods<a class="anchor" aria-label="anchor" href="#sssec:lap_methods"></a>
</h4>
<p>Multiple graph matching methods include solving an LAP and so we have
included multiple methods for solving LAPs into the package.
Specifically we implement the Jonker-Volgenant algorithm (<span class="citation">Jonker and Volgenant (1988)</span>) for dense cost
matrices and the LAPMOD algorithm (<span class="citation">Volgenant
(1996)</span>) for sparse cost matrices. Both algorithms are implemented
in C to provide improved performance. The LAPMOD approach is typically
advantageous when the number of non-zero entries is less than 50%. We
also depend on the <code>clue</code> package for the
<code>solve_LSAP</code> function which implements the Hungarian
algorithm (<span class="citation">Papadimitriou and Steiglitz
(1998)</span>) for solving an LAP. Each of these methods can be used
independently of a specific graph matching method using the
<code>do_lap</code> function.</p>
</div>
<div class="section level4">
<h4 id="multi-layered-graph-matching">Multi-layered graph matching<a class="anchor" aria-label="anchor" href="#multi-layered-graph-matching"></a>
</h4>
<p>Frequently, networks edges may have categorical attributes and from
these categories, we can construct multilayer graphs (<span class="citation">Kivelä et al. (2014)</span>), where each layer in the
networks contains edges from specific categories. For matching two
multilayer graphs, the standard graph matching problem can be extended
as <span class="math inline">\(\sum_{l=1}^{m}\|A^{(l)} -
PB^{(l)}P^T\|_F^2\)</span> where <span class="math inline">\(m\)</span>
denotes the number of categories and <span class="math inline">\(A^{(l)}, B^{(l)}\)</span> are the adjacency
matrices for the <span class="math inline">\(l\)</span>th layers in each
graph. Note, we assume that the layers are aligned, so that layer <span class="math inline">\(l\)</span> corresponds to the same edge-types in
both multi-layer networks.</p>
<p>For an <code>igraph</code> object, the function
<code>split_igraph</code> can be used to convert a single object with
categorical edge attributes into a list with each element only
containing the edges with a specific attribute value. The implemented
algorithms can seamlessly match multi-layer graphs, which are encoded as
a list of either <code>igraph</code> objects or <code>matrix</code>-like
objects. We also implemented a <code>matrixlist</code> S4 class that
implements many standard matrix operations so that algorithms can be
easily extended to work with multilayer networks.</p>
</div>
</div>
<div class="section level3">
<h3 id="graph-models">Correlated random graph models<a class="anchor" aria-label="anchor" href="#graph-models"></a>
</h3>
<p>The correlated model (<span class="citation">V. Lyzinski et al.
(2016)</span>) is essential in the theoretical study of graph matching
algorithms. In a single graph, each edge is present in the graph
independently with probability <span class="math inline">\(p\)</span>.
The correlated model provides a joint distribution for a pair of graphs,
where each graph is marginally distributed as an graph and corresponding
edge-pairs are correlated.</p>
<p>To sample a pair of correlated graphs with edge probability <span class="math inline">\(p\)</span>, and Pearson correlation <span class="math inline">\(\rho\)</span>, we first sample three independent
graphs <span class="math inline">\(G_1\)</span>, <span class="math inline">\(Z_0\)</span> and <span class="math inline">\(Z_1\)</span> with edge probabilities <span class="math inline">\(p\)</span>, <span class="math inline">\(p(1-\rho)\)</span> and <span class="math inline">\(p+\rho(1-p)\)</span> respectively. Let <span class="math inline">\(G_2 = (Z_1 \cap G_1) \bigcup (Z_0\cap
G_1^c)\)</span>.</p>
<p><span class="citation">Yartseva and Grossglauser (2013)</span>
provide an alternative formulation for the correlated model. First, one
samples a single random graph <span class="math inline">\(G\)</span>
with edge probability <span class="math inline">\(p'\)</span>.
Conditioned on <span class="math inline">\(G\)</span>, each edge in
<span class="math inline">\(G\)</span> is present independently in <span class="math inline">\(G_1,G_2\)</span> with probability <span class="math inline">\(s'\)</span>. These two parameterizations are
related to each other by the relationship <span class="math inline">\(s'=p+\rho(1-p)\)</span> and <span class="math inline">\(p'=p/(p+\rho(1-p))\)</span>. The original
parameterization is slightly more general because it allows for the
possibility of negative correlation.</p>
<p>In addition to homogeneous correlated random graphs, we also
implement heterogeneous generalizations of this model. The stochastic
block model (<span class="citation">Holland, Laskey, and Leinhardt
(1983)</span>) and the random dot product graphs (RDPG) model (<span class="citation">Young and Scheinerman (2007)</span>) can both be
regarded as extensions of the model. The stochastic block model is
useful to represent the community structure of graphs by dividing the
graph into <span class="math inline">\(K\)</span> groups. Each node is
assigned to a group and the probability of edges is determined by the
group memberships of the vertex pair. For the RDPG model, each vertex is
assigned a latent position in <span class="math inline">\(\mathbb{R}^d\)</span> and edge probabilities are
given by the inner product between the latent positions of the vertex
pair.</p>
<p>For both of these models, we can consider correlated graph-pairs
where marginally they arise from one of these models and again
corresponding edge pairs are correlated.</p>
</div>
<div class="section level3">
<h3 id="sec:measure">Measures for goodness of matching<a class="anchor" aria-label="anchor" href="#sec:measure"></a>
</h3>
<p>The ability to assess the quality of the match when ground truth is
unavailable is critical for the usage of the matching approaches. There
are various topological criteria that can be applied to measure the
quality of matching results. At the graph level, the most frequently
used structural measures include matching pairs (MP), edge correctness
(EC), and the size of the largest common connected subgraph (LCCS)
(<span class="citation">Kuchaiev and Przulj (2011)</span>). MP counts
the number of correctly matched pairs of nodes, thus can only be used
when the true alignment is available. Global counts of common edges (CE)
and common non-edges (CNE) can be defined as <span class="math display">\[\begin{align*}
    CE=\frac{1}{2}\sum_{i,j}1\{A_{ij}=PBP^T_{ij} =1\}\quad
CNE=\frac{1}{2}\sum_{i,j}1\{A_{ij}=PBP^T_{ij} = 0\},
\end{align*}\]</span> along with error counts such extra edges (EE) and
missing edges (ME), <span class="math display">\[\begin{align*}
    EE=\frac{1}{2}\sum_{i,j}1\{A_{ij}=0=1 - PBP^T_{ij}\}\quad
ME=\frac{1}{2}\sum_{i,j}1\{A_{ij}= 1 = 1 - PBP^T_{ij}\},
\end{align*}\]</span></p>
<p>EC measures the percentage of correctly aligned edges, that is the
fraction CE<span class="math inline">\(/|E_1|\)</span>. The LCCS denotes
the largest subset of aligned vertices such that the corresponding
induced subgraphs of each graph are connected. Matches with a larger
LCCS are often preferable to those with many isolated components.</p>
<p>Another group of criteria measures the goodness of matching at the
vertex level. Informally, we aim at testing the hypotheses <span class="math display">\[H_0^{(v)}: \text{the vertex } v \text{ is not
matched correctly by } P^*, \]</span> <span class="math display">\[H_a^{(v)}: \text{the vertex } v \text{ is matched
correctly by } P^*\]</span> for each vertex <span class="math inline">\(v\)</span>.</p>
<p>The goal is to address if the permutation matrix found by graph
matching algorithm is significantly different from the one sampled from
uniformly distributed permutation matrices (<span class="citation">Vince
Lyzinski and Sussman (2017)</span>). Unfortunately, vertex-level
matching criteria have only received limited attention in the
literature, however, we include two test statistics to measure fit. The
row difference statistic is the L<span class="math inline">\(_1\)</span>-norm of the difference between <span class="math inline">\(A\)</span> and <span class="math inline">\(P^*B{P^*}^T\)</span>, namely <span class="math display">\[\begin{equation*}
T_d(v,P^*):=\Vert A_{v\cdot}-(P^*B{P^*}^T)_{v\cdot}\Vert_1.
\end{equation*}\]</span> Intuitively, a correctly matched vertex <span class="math inline">\(v\)</span> should induce a smaller <span class="math inline">\(T_d(v,P^*)\)</span>, which for unweighted graphs
corresponds to the number of edge disagreements induced by matching
<span class="math inline">\(v\)</span>. Alternatively, the row
correlation statistic is defined as <span class="math display">\[\begin{equation*}
T_c(v,P^*):=1 - corr(A_{v\cdot},(P^*B{P^*}^T)_{v\cdot}).
\end{equation*}\]</span> We expect the empirical correlation between the
neighborhoods of <span class="math inline">\(v\)</span> in <span class="math inline">\(A\)</span> and <span class="math inline">\(P^*B{P^*}^T\)</span> to be larger for a correctly
matched vertex.</p>
<p>We employ permutation testing ideas to the raw statistics as a
normalization across vertices. Let us take the row difference statistic
for example. The guiding intuition is that if <span class="math inline">\(v\)</span> is correctly matched, the number of
errors induced by <span class="math inline">\(P^*\)</span> across the
neighborhood of <span class="math inline">\(v\)</span> in <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> (i.e., <span class="math inline">\(T_d(v, P^*)\)</span>) should be significantly
smaller than the number of errors induced by a randomly chosen
permutation <span class="math inline">\(P\)</span> (i.e., <span class="math inline">\(T_d(v, P)\)</span>).</p>
<p>With this in mind, let <span class="math inline">\(\mathbb{E}_P\)</span> and <span class="math inline">\(\mathrm{Var}_P\)</span> denote the conditional
expectation and variance of the raw statistic with <span class="math inline">\(P\)</span> uniformly sampled over all permutation
matrices. The normalization is then given by <span class="math display">\[\begin{equation*}
T_p(v,P^*):=\frac{T(v,P^*)-\mathbb{E}_PT(v,P)}{\sqrt{Var_PT(v,P)}}
\end{equation*}\]</span> where <span class="math inline">\(T(v,
P)\)</span> can be either of the two test statistics we introduced
earlier.</p>
<p>In addition to measuring match quality, these vertex-wise statistics
can also serve as a tool to find which vertices have no valid match in
another network, i.e. the vertex entity is present in one network but
not the other.</p>
</div>
</div>
<div class="section level2">
<h2 id="sec:usage">R functions and usage<a class="anchor" aria-label="anchor" href="#sec:usage"></a>
</h2>
<p>The R package <code>iGraphMatch</code> offers versatile options for
graph matching and subsequent analysis. Here we describe the usage of
the package including sampling random correlated graph pairs, graph
matching, and evaluating matching results.</p>
<div class="section level3">
<h3 id="sampling-correlated-random-graph-pairs">Sampling correlated random graph pairs<a class="anchor" aria-label="anchor" href="#sampling-correlated-random-graph-pairs"></a>
</h3>
<p>We first illustrate the usage of functions for sampling correlated
random graph pairs. The usage of graph matching will be demonstrated on
the graph-pairs sampled using these methods.</p>
<p>Functions of the form <code>sample_correlated_*_pair</code> for
sampling random graph pairs have the common syntax:</p>
<pre><code>sample_correlated_*_pair(n, ***model parameters***, 
  permutation = 1:n, directed = FALSE, loops = FALSE)</code></pre>
<p>The argument <code>n</code> specifies the number of nodes in each
graph, and the default options are to sample a pair of undirected graphs
without self-loop whose true alignment is the identity. The
<code>permutation</code> argument can be used to permute the vertex
labels of the second graph. The <code>model parameters</code> arguments
vary according to different random graph models and typically consist of
parameters for marginal graph distributions and for correlations between
the corresponding edges. The functions each return a named list of two
<code>igraph</code> objects.</p>
<p>For the homogeneous correlated graph model, the model parameters are
<code>p</code>, the global edge probability, and <code>corr</code>, the
Pearson correlation between aligned vertex-pairs. For example, to sample
a pair of graphs with 5 nodes from <span class="math inline">\(\mathrm{CorrER}(0.5J, 0.7J)\)</span> we run</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/dpmcsuss/iGraphMatch" class="external-link">iGraphMatch</a></span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span>
<span><span class="va">cgnp_pair</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sample_gnp.html">sample_correlated_gnp_pair</a></span><span class="op">(</span>n <span class="op">=</span> <span class="fl">5</span>, corr <span class="op">=</span> <span class="fl">0.7</span>, p <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span>
<span><span class="op">(</span><span class="va">cgnp_g1</span> <span class="op">&lt;-</span> <span class="va">cgnp_pair</span><span class="op">$</span><span class="va">graph1</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## IGRAPH 791051c U--- 5 4 -- Erdos-Renyi (gnp) graph</span></span>
<span><span class="co">## + attr: name (g/c), type (g/c), loops (g/l), p (g/n)</span></span>
<span><span class="co">## + edges from 791051c:</span></span>
<span><span class="co">## [1] 1--2 2--3 2--5 3--5</span></span></code></pre>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">cgnp_g1</span><span class="op">[</span><span class="op">]</span></span></code></pre></div>
<pre><code><span><span class="co">## 5 x 5 sparse Matrix of class "dgCMatrix"</span></span>
<span><span class="co">##               </span></span>
<span><span class="co">## [1,] . 1 . . .</span></span>
<span><span class="co">## [2,] 1 . 1 . 1</span></span>
<span><span class="co">## [3,] . 1 . . 1</span></span>
<span><span class="co">## [4,] . . . . .</span></span>
<span><span class="co">## [5,] . 1 1 . .</span></span></code></pre>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">cgnp_g2</span> <span class="op">&lt;-</span> <span class="va">cgnp_pair</span><span class="op">$</span><span class="va">graph2</span></span></code></pre></div>
<p>Since we didn’t obscure the vertex correspondence by assigning a
value to the <code>permutation</code> argument, the underlying true
alignment is the identity.</p>
<p>For the more general heterogeneous correlated graph model, one needs
to specify an edge probability matrix and a Pearson correlation matrix.
To sample a pair of graphs from the heterogeneous correlated model again
with 5 nodes in each graph, and with random edge probabilities and
Pearson correlations:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span><span class="va">p</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">5</span><span class="op">^</span><span class="fl">2</span>, <span class="fl">.5</span>, <span class="fl">.8</span><span class="op">)</span>,<span class="fl">5</span><span class="op">)</span></span>
<span><span class="va">c</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">5</span><span class="op">^</span><span class="fl">2</span>, <span class="fl">.5</span>, <span class="fl">.8</span><span class="op">)</span>,<span class="fl">5</span><span class="op">)</span></span>
<span><span class="va">ieg_pair</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sample_ieg.html">sample_correlated_ieg_pair</a></span><span class="op">(</span>n <span class="op">=</span> <span class="fl">5</span>, p_mat <span class="op">=</span> <span class="va">p</span>, c_mat <span class="op">=</span> <span class="va">c</span><span class="op">)</span></span></code></pre></div>
<p>Since the default is undirected graphs without self-loops, the
entries of <code>p</code> and <code>c</code> along and below the
diagonal are effectively ignored.</p>
<p>The stochastic block model requires block-to-block edge probabilities
stored in the <code>pref.matrix</code> argument and the
<code>block.sizes</code> argument indicates the size of each block,
along with the Pearson correlation parameter <code>corr</code>. Next, we
sample a pair of graphs from the stochastic block model with two blocks
of size 2 nodes and 3 nodes respectively, within-group edge
probabilities of .7 and .5, across-group edge probability of .001, and
Pearson correlation equal to .5.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pm</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">.7</span>, <span class="fl">.001</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">.001</span>, <span class="fl">.5</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">sbm_pair</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sample_sbm.html">sample_correlated_sbm_pair</a></span><span class="op">(</span>n <span class="op">=</span> <span class="fl">5</span>, pref.matrix <span class="op">=</span> <span class="va">pm</span>,</span>
<span>                                       block.sizes <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">3</span><span class="op">)</span>, corr <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<p>The <code>iGraphMatch</code> package also provides functions for
sampling a pair of correlated random graphs with junk vertices, i.e
vertices that don’t have true correspondence in the other graph by
specifying the number of overlapping vertices in the argument
<code>ncore</code> or overlapping block sizes in the argument
<code>core.block.sizes</code>.</p>
<p>The <code>iGraphMatch</code> package offers auxiliary tools for
centering graphs to penalize the incorrect matches as well, which is
implemented in the <code>center_graph</code> function with syntax:</p>
<pre><code><span><span class="fu"><a href="../reference/center_graph.html">center_graph</a></span><span class="op">(</span><span class="va">A</span>, scheme <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">1</span>, <span class="fl">1</span><span class="op">)</span>, use_splr <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre>
<p>with the first input being either a matrix-like or igraph object. The
<code>scheme</code> argument specifies the method for centering graphs.
Options include a pair of scalars where the entries of the adjacency
matrix are linearly rescaled so that their minimum is
<code>min(scheme)</code> and their maximum is <code>max(scheme)</code>.
Note, <code>scheme = "center"</code> is the same as
<code>scheme = c(-1, 1)</code>. Another option is to pass in a single
integer, where the returned value is the adjacency matrix minus its best
rank-<code>scheme</code> approximation. The last argument
<code>use_splr</code> is a boolean indicating whether to return a
<code>splrMatrix</code> object. We use <code>use_splr = FALSE</code>
here to better display the matrices but <code>use_splr = TRUE</code>
will often result in improved performance, especially for large sparse
networks. Here, we center the sampled graph <code>cgnp_g1</code> using
different schemes:</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/center_graph.html">center_graph</a></span><span class="op">(</span><span class="va">cgnp_g1</span>, scheme <span class="op">=</span> <span class="st">"center"</span>, use_splr <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## 5 x 5 Matrix of class "dgeMatrix"</span></span>
<span><span class="co">##      [,1] [,2] [,3] [,4] [,5]</span></span>
<span><span class="co">## [1,]   -1    1   -1   -1   -1</span></span>
<span><span class="co">## [2,]    1   -1    1   -1    1</span></span>
<span><span class="co">## [3,]   -1    1   -1   -1    1</span></span>
<span><span class="co">## [4,]   -1   -1   -1   -1   -1</span></span>
<span><span class="co">## [5,]   -1    1    1   -1   -1</span></span></code></pre>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/center_graph.html">center_graph</a></span><span class="op">(</span><span class="va">cgnp_g1</span>, scheme <span class="op">=</span> <span class="fl">2</span>, use_splr <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## 5 x 5 Matrix of class "dgeMatrix"</span></span>
<span><span class="co">##        [,1]   [,2]   [,3] [,4]   [,5]</span></span>
<span><span class="co">## [1,]  0.207  0.064 -0.093    0 -0.093</span></span>
<span><span class="co">## [2,]  0.064  0.020 -0.029    0 -0.029</span></span>
<span><span class="co">## [3,] -0.093 -0.029 -0.458    0  0.542</span></span>
<span><span class="co">## [4,]  0.000  0.000  0.000    0  0.000</span></span>
<span><span class="co">## [5,] -0.093 -0.029  0.542    0 -0.458</span></span></code></pre>
<p>Users can then use the centered graphs as inputs to the implemented
graph matching algorithms, which serve to alter rewards and penalties
for common edges, common non-edges, missing edges, and extra edges.</p>
</div>
<div class="section level3">
<h3 id="graph-matching-methods">Graph matching methods<a class="anchor" aria-label="anchor" href="#graph-matching-methods"></a>
</h3>
<p>The graph matching methods share the same basic syntax:</p>
<pre><code>gm(A, B, seeds = NULL, similarity = NULL, method = "indefinite", 
  ***algorithm parameters***)</code></pre>
<table class="table">
<caption>(#tab:gm-alg) Overview of arguments for different graph
matching functions.</caption>
<colgroup>
<col width="17%">
<col width="21%">
<col width="39%">
<col width="21%">
</colgroup>
<thead><tr class="header">
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
<th>Functions</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>start</code></td>
<td>Matrix or character</td>
<td>Initialization of the start matrix for iterations.</td>
<td><code>FW, convex</code></td>
</tr>
<tr class="even">
<td><code>lap_method</code></td>
<td>Character</td>
<td>Method for solving linear assignment problem.</td>
<td><code>FW, convex, PATH, IsoRank</code></td>
</tr>
<tr class="odd">
<td><code>max_iter</code></td>
<td>Number</td>
<td>Maximum number of iterations.</td>
<td><code>FW, convex, PATH, IsoRank</code></td>
</tr>
<tr class="even">
<td><code>tol</code></td>
<td>Number</td>
<td>Tolerance of edge disagreements.</td>
<td><code>FW, convex, PATH</code></td>
</tr>
<tr class="odd">
<td><code>r</code></td>
<td>Number</td>
<td>Threshold of neighboring pair scores.</td>
<td><code>percolation</code></td>
</tr>
<tr class="even">
<td><code>ExpandWhenStuck</code></td>
<td>Boolean</td>
<td>
<code>TRUE</code> if performs <span class="smallcaps">ExpandWhenStuck</span> algorithm.</td>
<td><code>percolation</code></td>
</tr>
</tbody>
</table>
<p>The first two arguments for graph matching algorithms represent two
networks which can be matrices, igraph objects, or two lists of either
form in the case of multi-layer matching. The <code>seeds</code>
argument contains prior information on the known partial correspondence
of two graphs. It can be a vector of logicals or indices if the seed
pairs have the same indices in both graphs. In general, the
<code>seeds</code> argument takes a matrix or a data frame as input with
two columns indicating the indices of seeds in the two graphs
respectively. The <code>similarity</code> parameter is for a matrix of
similarity scores between the two vertex sets, with larger scores
indicating higher similarity. Notably, one should be careful with the
different scales of the graph topological structure and the vertex
similarity information in order to properly address the relative
importance of each part of the information. The <code>method</code>
argument specifies a graph matching algorithm to use, and one can choose
from “indefinite” (default), “convex”, “PATH”, “percolation”, “IsoRank”,
“Umeyama”, or a self-defined graph matching function which enables users
to test out their own algorithms while remaining compatible with the
package. If <code>method</code> is a function, it should take at least
two networks, seeds and similarity scores as arguments. Users can also
include additional arguments if applicable. The self-defined graph
matching function should return an object of the “graphMatch” class with
matching correspondence, sizes of two input graphs, and other matching
details. As an illustrative example, <code>graph_match_rand</code>
defines a new graph matching function which matches by randomly
permuting the vertex label of the second graph using a random seed
<code>rand_seed</code>. We then apply this self-defined GM method to
matching the correlated graphs sampled earlier with a specified random
seed:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph_match_rand</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">A</span>, <span class="va">B</span>, <span class="va">seeds</span> <span class="op">=</span> <span class="cn">NULL</span>, </span>
<span>                             <span class="va">similarity</span> <span class="op">=</span> <span class="cn">NULL</span>, <span class="va">rand_seed</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="va">totv1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">A</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">)</span></span>
<span>  <span class="va">totv2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">B</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">)</span></span>
<span>  <span class="va">nv</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="va">totv1</span>, <span class="va">totv2</span><span class="op">)</span></span>
<span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="va">rand_seed</span><span class="op">)</span></span>
<span>  <span class="va">corr</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>corr_A <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="va">nv</span>, </span>
<span>                     corr_B <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">nv</span><span class="op">)</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="va">nv</span><span class="op">)</span><span class="op">]</span><span class="op">)</span></span>
<span></span>
<span>  <span class="fu"><a href="../reference/graphMatch_constructor.html">graphMatch</a></span><span class="op">(</span></span>
<span>    corr <span class="op">=</span> <span class="va">corr</span>,</span>
<span>    nnodes <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">totv1</span>, <span class="va">totv2</span><span class="op">)</span>,</span>
<span>    detail <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span></span>
<span>      rand_seed <span class="op">=</span> <span class="va">rand_seed</span></span>
<span>    <span class="op">)</span></span>
<span>  <span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="va">match_rand</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/gm.html">gm</a></span><span class="op">(</span><span class="va">cgnp_g1</span>, <span class="va">cgnp_g2</span>, </span>
<span>                 method <span class="op">=</span> <span class="va">graph_match_rand</span>, rand_seed <span class="op">=</span> <span class="fl">123</span><span class="op">)</span></span></code></pre></div>
<p>Other arguments vary for different graph matching algorithms with an
overview given in Table <span class="math inline">\(\ref{tab:gm-alg}\)</span>. The <code>start</code>
argument for the <span class="smallcaps">FW</span> methodology with
“indefinite” and “convex” relaxations takes any <span class="math inline">\(nns\text{-by-}nns\)</span> matrix or an
initialization method including “bari”, “rds” or “convex”. These
represent initializing the iterations at a specific matrix, the
barycenter, a random doubly stochastic matrix, or the doubly stochastic
solution from “convex” method on the same graphs, respectively.</p>
<p>Moreover, sometimes we have access to side information on partial
correspondence with uncertainty. If we still treat such prior
information as hard seeds and pass them through the <code>seeds</code>
argument for “indefinite” and “convex” methods, incorrect information
can yield unsatisfactory matching results. Instead, we provide the
option of soft seeding by incorporating the noisy partial correspondence
into the initialization of the start matrix. The core function used for
initializing the start matrix with versatile options is the
<code>init_start</code> function.</p>
<p>Suppose the first two pairs of nodes are hard seeds and another pair
of incorrect seed <span class="math inline">\((3,4)\)</span> is soft
seeds:</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">hard_seeds</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">:</span><span class="fl">5</span> <span class="op">&lt;=</span> <span class="fl">2</span></span>
<span><span class="va">soft_seeds</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>seed_A <span class="op">=</span> <span class="fl">3</span>, seed_B <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span></code></pre></div>
<p>We generate a start matrix incorporating soft seeds initialized at
the barycenter:</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">as.matrix</a></span><span class="op">(</span><span class="va">start_bari</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/init_start.html">init_start</a></span><span class="op">(</span>start <span class="op">=</span> <span class="st">"bari"</span>, nns <span class="op">=</span> <span class="fl">3</span>,</span>
<span>      ns <span class="op">=</span> <span class="fl">2</span>, soft_seeds <span class="op">=</span> <span class="va">soft_seeds</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##      [,1] [,2] [,3]</span></span>
<span><span class="co">## [1,]  0.0    1  0.0</span></span>
<span><span class="co">## [2,]  0.5    0  0.5</span></span>
<span><span class="co">## [3,]  0.5    0  0.5</span></span></code></pre>
<p>An alternative is to generate a start matrix that is a random doubly
stochastic matrix incorporating soft seeds as follow</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">as.matrix</a></span><span class="op">(</span><span class="va">start_rds</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/init_start.html">init_start</a></span><span class="op">(</span>start <span class="op">=</span> <span class="st">"rds"</span>, nns <span class="op">=</span> <span class="fl">3</span>,</span>
<span>      ns <span class="op">=</span> <span class="fl">2</span>, soft_seeds <span class="op">=</span> <span class="va">soft_seeds</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##      [,1] [,2] [,3]</span></span>
<span><span class="co">## [1,] 0.00    1 0.00</span></span>
<span><span class="co">## [2,] 0.52    0 0.48</span></span>
<span><span class="co">## [3,] 0.48    0 0.52</span></span></code></pre>
<p>Then we can initialize the <span class="smallcaps">Frank-Wolfe</span>
iterations at any of the start matrix by specifying the
<code>start</code> parameter.</p>
<p>When there are no soft seeds, we no longer need to initialize the
start matrix by using <code>init_start</code> first. Instead we can
directly assign an initialization method to the <code>start</code>
argument in the <code>gm</code> function:</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">match_rds</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/gm.html">gm</a></span><span class="op">(</span><span class="va">cgnp_g1</span>, <span class="va">cgnp_g2</span>, seeds <span class="op">=</span> <span class="va">hard_seeds</span>,</span>
<span>                method <span class="op">=</span> <span class="st">"indefinite"</span>, start <span class="op">=</span> <span class="st">"rds"</span><span class="op">)</span></span></code></pre></div>
<p>Below use solution from the convex relaxation as the initialization
for the indefinite relaxation.</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span><span class="va">match_convex</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/gm.html">gm</a></span><span class="op">(</span><span class="va">cgnp_g1</span>, <span class="va">cgnp_g2</span>, seeds <span class="op">=</span> <span class="va">hard_seeds</span>,</span>
<span>                   method <span class="op">=</span> <span class="st">"indefinite"</span>, start <span class="op">=</span> <span class="st">"convex"</span><span class="op">)</span></span></code></pre></div>
<p>Now let’s match the sampled pair of graphs from the stochastic block
model by using <span class="smallcaps">Percolation</span> algorithm.
Apart from the common arguments for all the graph matching algorithms,
<span class="smallcaps">Percolation</span> has another argument
representing the minimum number of matched neighbors required for
matching a new qualified vertex pair. Here we adopt the default value
which is 2. Also, at least one of similarity scores and seeds is
required for <span class="smallcaps">Percolation</span> algorithm to
kick off. Let’s utilize the same set of hard seeds and assume there is
no available prior information on similarity scores.</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sbm_g1</span> <span class="op">&lt;-</span> <span class="va">sbm_pair</span><span class="op">$</span><span class="va">graph1</span></span>
<span><span class="va">sbm_g2</span> <span class="op">&lt;-</span> <span class="va">sbm_pair</span><span class="op">$</span><span class="va">graph2</span></span>
<span><span class="va">match_perco</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/gm.html">gm</a></span><span class="op">(</span><span class="va">sbm_g1</span>, <span class="va">sbm_g1</span>, seeds <span class="op">=</span> <span class="va">hard_seeds</span>, </span>
<span>                  method <span class="op">=</span> <span class="st">"percolation"</span>, r <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="va">match_perco</span></span></code></pre></div>
<pre><code><span><span class="co">## gm(A = sbm_g1, B = sbm_g1, seeds = hard_seeds, method = "percolation", </span></span>
<span><span class="co">##     r = 2)</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Match (5 x 5):</span></span>
<span><span class="co">##   corr_A corr_B</span></span>
<span><span class="co">## 1      1      1</span></span>
<span><span class="co">## 2      2      2</span></span></code></pre>
<p>Without enough prior information on partial correspondence, <span class="smallcaps">Percolation</span> couldn’t find any qualifying
matches. Suppose in addition to the current pair of sampled graphs, the
above sampled correlated homogeneous and heterogeneous graphs are
different layers of connectivity for the same set of vertices. We can
then match the nonseed vertices based on the topological information in
all of these three graph layers. To be consistent, let’s still use the
<span class="smallcaps">Percolation</span> algorithm with threshold
equal to 2 and the same set of seeds.</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">matrix_lA</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">sbm_g1</span>, <span class="va">ieg_pair</span><span class="op">$</span><span class="va">graph1</span>, <span class="va">cgnp_g1</span><span class="op">)</span></span>
<span><span class="va">matrix_lB</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">sbm_g2</span>, <span class="va">ieg_pair</span><span class="op">$</span><span class="va">graph2</span>, <span class="va">cgnp_g2</span><span class="op">)</span></span>
<span><span class="va">match_perco_list</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/gm.html">gm</a></span><span class="op">(</span>A <span class="op">=</span> <span class="va">matrix_lA</span>, B <span class="op">=</span> <span class="va">matrix_lB</span>, seeds <span class="op">=</span> <span class="va">hard_seeds</span>, </span>
<span>                       method <span class="op">=</span> <span class="st">"percolation"</span>, r <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="va">match_perco_list</span></span></code></pre></div>
<pre><code><span><span class="co">## gm(A = matrix_lA, B = matrix_lB, seeds = hard_seeds, method = "percolation", </span></span>
<span><span class="co">##     r = 2)</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Match (5 x 5):</span></span>
<span><span class="co">##   corr_A corr_B</span></span>
<span><span class="co">## 1      1      1</span></span>
<span><span class="co">## 2      2      2</span></span>
<span><span class="co">## 3      3      3</span></span>
<span><span class="co">## 4      4      4</span></span>
<span><span class="co">## 5      5      5</span></span></code></pre>
<p>With the same amount of available prior information, we are now able
to match all the nodes correctly.</p>
<p>Finally, we will give an example of matching multi-layers of graphs
using <span class="smallcaps">IsoRank</span> algorithm. Unlike the other
algorithm, similarity scores are required for <span class="smallcaps">IsoRank</span> algorithm. Without further information,
we adopt the barycenter as the similarity matrix here.</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span>
<span><span class="va">sim</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">as.matrix</a></span><span class="op">(</span><span class="fu"><a href="../reference/init_start.html">init_start</a></span><span class="op">(</span>start <span class="op">=</span> <span class="st">"bari"</span>, nns <span class="op">=</span> <span class="fl">5</span>, </span>
<span>                            soft_seeds <span class="op">=</span> <span class="va">hard_seeds</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">match_IsoRank</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/gm.html">gm</a></span><span class="op">(</span>A <span class="op">=</span> <span class="va">matrix_lA</span>, B <span class="op">=</span> <span class="va">matrix_lB</span>, </span>
<span>                    seeds <span class="op">=</span> <span class="va">hard_seeds</span>, similarity <span class="op">=</span> <span class="va">sim</span>, </span>
<span>                    method <span class="op">=</span> <span class="st">"IsoRank"</span>, lap_method <span class="op">=</span> <span class="st">"LAP"</span><span class="op">)</span></span></code></pre></div>
<p>Graph matching functions return an object of class “graphMatch” which
contains the details of the matching results, including a list of the
matching correspondence, a call to the graph matching function and
dimensions of the original two graphs.</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">match_convex</span><span class="op">@</span><span class="va">corr</span></span></code></pre></div>
<pre><code><span><span class="co">##   corr_A corr_B</span></span>
<span><span class="co">## 1      1      1</span></span>
<span><span class="co">## 2      2      2</span></span>
<span><span class="co">## 3      3      5</span></span>
<span><span class="co">## 4      4      4</span></span>
<span><span class="co">## 5      5      3</span></span></code></pre>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">match_convex</span><span class="op">@</span><span class="va">call</span></span></code></pre></div>
<pre><code><span><span class="co">## gm(A = cgnp_g1, B = cgnp_g2, seeds = hard_seeds, method = "indefinite", </span></span>
<span><span class="co">##     start = "convex")</span></span></code></pre>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">match_convex</span><span class="op">@</span><span class="va">nnodes</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 5 5</span></span></code></pre>
<p>Additionally, “graphMatch” also returns a list of matching details
corresponding to the specified method. Table <span class="math inline">\(\ref{tab:gm-value}\)</span> provides an overview
of returned values for different graph matching methods. With the
<code>seeds</code> information, one can obtain a node mapping for
non-seeds accordingly</p>
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">match_convex</span><span class="op">[</span><span class="op">!</span><span class="va">match_convex</span><span class="op">$</span><span class="va">seeds</span><span class="op">]</span></span></code></pre></div>
<pre><code><span><span class="co">##   corr_A corr_B</span></span>
<span><span class="co">## 3      3      5</span></span>
<span><span class="co">## 4      4      4</span></span>
<span><span class="co">## 5      5      3</span></span></code></pre>
<table class="table">
<caption>(#tab:gm-value) Overview of return values for different graph
matching functions.</caption>
<colgroup>
<col width="22%">
<col width="50%">
<col width="27%">
</colgroup>
<thead><tr class="header">
<th align="left">Parameter</th>
<th align="center">Description</th>
<th align="right">Functions</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left"><code>seeds</code></td>
<td align="center">A vector of logicals indicating if the corresponding
vertex is a seed</td>
<td align="right">All the functions</td>
</tr>
<tr class="even">
<td align="left"><code>soft</code></td>
<td align="center">The functional similarity score matrix with which one
can extract more than one matching candidates</td>
<td align="right"><code>FW, convex, PATH, IsoRank, Umeyama</code></td>
</tr>
<tr class="odd">
<td align="left"><code>lap_method</code></td>
<td align="center">Choice for solving the LAP.</td>
<td align="right"><code>FW, convex, Umeyama, IsoRank</code></td>
</tr>
<tr class="even">
<td align="left"><code>iter</code></td>
<td align="center">Number of iterations until convergence or reaches the
max_iter.</td>
<td align="right"><code>FW, convex, PATH</code></td>
</tr>
<tr class="odd">
<td align="left"><code>max_iter</code></td>
<td align="center">Maximum number of replacing matches.</td>
<td align="right"><code>FW, convex</code></td>
</tr>
<tr class="even">
<td align="left"><code>match_order</code></td>
<td align="center">The order of vertices getting matched.</td>
<td align="right"><code>percolation, IsoRank</code></td>
</tr>
</tbody>
</table>
<p>The “graphMatch” class object can also be flexibly used as a matrix.
In addition to the returned list of matching correspondence, one can
obtain the corresponding permutation matrix in the sparse form.</p>
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">match_convex</span><span class="op">[</span><span class="op">]</span></span></code></pre></div>
<pre><code><span><span class="co">## 5 x 5 sparse Matrix of class "dgCMatrix"</span></span>
<span><span class="co">##               </span></span>
<span><span class="co">## [1,] 1 . . . .</span></span>
<span><span class="co">## [2,] . 1 . . .</span></span>
<span><span class="co">## [3,] . . . . 1</span></span>
<span><span class="co">## [4,] . . . 1 .</span></span>
<span><span class="co">## [5,] . . 1 . .</span></span></code></pre>
<p>Notably, multiplicity is applicable to the “graphMatch” object
directly without converting to the permutation matrix. This enables
obtaining the permuted second graph, that is <span class="math inline">\(PBP^T\)</span> simply by</p>
<div class="sourceCode" id="cb38"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">match_convex</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="va">cgnp_g2</span></span></code></pre></div>
<pre><code><span><span class="co">## IGRAPH e9e1241 UN-- 5 5 -- Erdos-Renyi (gnp) graph</span></span>
<span><span class="co">## + attr: name_1 (g/c), name_2 (g/c), type_1 (g/c), type_2 (g/c), loops_1</span></span>
<span><span class="co">## | (g/l), loops_2 (g/l), p_1 (g/n), p_2 (g/n), name (g/c), type (g/c),</span></span>
<span><span class="co">## | loops (g/l), p (g/n), name (v/n)</span></span>
<span><span class="co">## + edges from e9e1241 (vertex names):</span></span>
<span><span class="co">## [1] 5--3 2--5 2--3 1--5 1--2</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="evaluation-of-goodness-of-matching">Evaluation of goodness of matching<a class="anchor" aria-label="anchor" href="#evaluation-of-goodness-of-matching"></a>
</h3>
<p>Along with the graph matching methodology, <code>iGraphMatch</code>
has many capabilities for evaluating and visualizing the matching
performance. After matching two graphs, the function
<code>summary</code> can be used to get a summary of the overall
matching result in terms of commonly used measures including the number
of matches, the number of correct matches, common edges, missing edges,
extra edges and the objective function value. The edge matching
information is stored in a data frame named
<code>edge_match_info</code>. Note that <code>summary</code> outputs the
number of correct matches only when the true correspondence is known by
specifying the <code>true_label</code> argument with a vector indicating
the true correspondence in the second graph. Applying the
<code>summary</code> function on the matching result
<code>match_convex</code> with <code>true_label = 1:5</code>, indicating
the true correspondence is the identity that provides these
summaries.</p>
<div class="sourceCode" id="cb40"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">match_convex</span>, <span class="va">cgnp_g1</span>, <span class="va">cgnp_g2</span>, true_label <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Call: gm(A = cgnp_g1, B = cgnp_g2, seeds = hard_seeds, method = "indefinite", </span></span>
<span><span class="co">##     start = "convex")</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## # Matches: 3</span></span>
<span><span class="co">## # True Matches:  1, # Seeds:  2, # Vertices:  5, 5</span></span>
<span><span class="co">##                   </span></span>
<span><span class="co">##   common_edges 4.0</span></span>
<span><span class="co">##  missing_edges 0.0</span></span>
<span><span class="co">##    extra_edges 1.0</span></span>
<span><span class="co">##          fnorm 1.4</span></span></code></pre>
<p>Applying the <code>summary</code> function to a multi-layer graph
matching result returns edge statistics for each layer.</p>
<div class="sourceCode" id="cb42"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">match_IsoRank</span>, <span class="va">matrix_lA</span>, <span class="va">matrix_lB</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Call: gm(A = matrix_lA, B = matrix_lB, seeds = hard_seeds, similarity = sim, </span></span>
<span><span class="co">##     method = "IsoRank", lap_method = "LAP")</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## # Matches: 3, # Seeds:  2, # Vertices:  5, 5</span></span>
<span><span class="co">##          layer   1   2   3</span></span>
<span><span class="co">##   common_edges 2.0 6.0 4.0</span></span>
<span><span class="co">##  missing_edges 0.0 1.0 0.0</span></span>
<span><span class="co">##    extra_edges 1.0 0.0 1.0</span></span>
<span><span class="co">##          fnorm 1.4 1.4 1.4</span></span></code></pre>
<p>In realistic scenarios, the true correspondence is not available. As
introduced in section <span class="math inline">\(\ref{sec:background}\)</span>, the user can use
vertex level statistics to evaluate match performance. The
<code>best_matches</code> function evaluates a vertex-level metric and
returns a sorted <code>data.frame</code> of the vertex-matches with the
metrics. The arguments are the two networks, a specific measure to use,
the number of top-ranked vertex-matches to output, and the matching
correspondence in the second graph if applicable. As an example here, we
apply <code>best_matches</code> to rank the matches from above with the
true underlying alignment</p>
<div class="sourceCode" id="cb44"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/best_matches.html">best_matches</a></span><span class="op">(</span><span class="va">cgnp_g1</span>, <span class="va">cgnp_g2</span>, match <span class="op">=</span> <span class="va">match_convex</span>, </span>
<span>             measure <span class="op">=</span> <span class="st">"row_perm_stat"</span>, num <span class="op">=</span> <span class="fl">3</span>, </span>
<span>             true_label <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fu">igraph</span><span class="fu">::</span><span class="fu"><a href="https://r.igraph.org/reference/gorder.html" class="external-link">vcount</a></span><span class="op">(</span><span class="va">cgnp_g1</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##   A_best B_best measure_value precision</span></span>
<span><span class="co">## 1      4      4          -1.4      1.00</span></span>
<span><span class="co">## 2      3      5          -1.2      0.50</span></span>
<span><span class="co">## 3      5      3          -1.2      0.33</span></span></code></pre>
<p>Note, <code>best_matches</code> uses seed information from the
<code>match</code> parameter and only outputs non-seed matches. Without
the true correspondence, <code>true_label</code> would take the default
value and the output data frame only contains the first three
columns.</p>
<p>To visualize the matches of smaller graphs, the function
<code>plot</code> displays edge discrepancies of the two matched graphs
by an adjacency matrix or a ball-and-stick plot, depending on the input
format of two graphs.</p>
<div class="sourceCode" id="cb46"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">cgnp_g1</span>, <span class="va">cgnp_g2</span>, <span class="va">match_convex</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">cgnp_g1</span><span class="op">[</span><span class="op">]</span>, <span class="va">cgnp_g2</span><span class="op">[</span><span class="op">]</span>, <span class="va">match_convex</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="iGraphMatch_files/figure-html/visualization-1.png" alt=" Match visualizations. Grey, blue, and red colors indicate common edges, missing edges present only in the first network, and extra edges present only in the second network, respectively." width="47.5%"><img src="iGraphMatch_files/figure-html/visualization-2.png" alt=" Match visualizations. Grey, blue, and red colors indicate common edges, missing edges present only in the first network, and extra edges present only in the second network, respectively." width="47.5%"><p class="caption">
Match visualizations. Grey, blue, and red colors indicate common edges,
missing edges present only in the first network, and extra edges present
only in the second network, respectively.
</p>
</div>
<p>The plots for visualizing matching performance of
<code>match_convex</code> are shown in Figure @ref(fig:visualization).
Grey edges and pixels indicate common edges, red ones indicate edges
only in the second graph. If they were present, blue pixels and edges
represent missing edges that only exist in the first graph. The
corresponding linetypes are solid, short dash, and long dash.</p>
</div>
</div>
<div class="section level2">
<h2 id="sec:example">Examples<a class="anchor" aria-label="anchor" href="#sec:example"></a>
</h2>
<p>In this section, we demonstrate graph matching analysis using
<code>iGraphMatch</code> via examples on real datasets, including
communication networks, neuronal networks, and transportation networks.
Table @ref(tab:dataset-overview) presents brief overviews of the first
two datasets. Note that the number of edges doesn’t consider weights for
weighted graphs, and for directed graphs, an edge from node <span class="math inline">\(i\)</span> to node <span class="math inline">\(j\)</span> and another edge from <span class="math inline">\(j\)</span> to <span class="math inline">\(i\)</span> will be counted as two edges. Tables
@ref(tab:edge-summary) and @ref(tab:edge-summary-trans) summarize the
edge correspondence between two graphs under the true alignment
including the number of common edges, missing edges, and extra edges in
two graphs.</p>
<p>In the first Enron email network example, we demonstrate the usage of
<span class="smallcaps">Frank-Wolfe</span> methodology and how to
improve matching performance by using the centering technique and
incorporating adaptive seeds. In the second example using <em>C.
Elegans</em> synapses networks, we illustrate how to use soft matching
for a challenging graph matching task using <span class="smallcaps">Frank-Wolfe</span> methodology, <span class="smallcaps">PATH</span> algorithm and <span class="smallcaps">IsoRank</span> algorithm. Finally, we include an
example of matching two multi-layer graphs with similarity scores on the
Britain transportation networks.</p>
<table class="table">
<caption>Overview of the Enron and C. Elegans graphs.</caption>
<colgroup>
<col width="15%">
<col width="12%">
<col width="16%">
<col width="16%">
<col width="12%">
<col width="12%">
<col width="13%">
</colgroup>
<thead><tr class="header">
<th align="left">Dataset</th>
<th align="left"># Nodes</th>
<th align="left"># Edges</th>
<th align="right">Correlation</th>
<th align="left">Weighted</th>
<th align="left">Directed</th>
<th align="left">Loop</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">Enron</td>
<td align="left">184</td>
<td align="left">488 / 482</td>
<td align="right">0.85</td>
<td align="left">No</td>
<td align="left">Yes</td>
<td align="left">Yes / Yes</td>
</tr>
<tr class="even">
<td align="left">C. Elegans</td>
<td align="left">279</td>
<td align="left">2194 / 1031</td>
<td align="right">0.10</td>
<td align="left">Yes</td>
<td align="left">Yes</td>
<td align="left">No / Yes</td>
</tr>
</tbody>
</table>
<table class="table">
<caption>Edge summary under the true alignments of the Enron and C.
Elegans graphs. The columns indicate the number of common edges, missing
edges in <span class="math inline">\(G_1\)</span>, and extra edges in
<span class="math inline">\(G_2\)</span>. For weighted graphs, we define
a pair of corresponding edges as a common edge as long as they both have
positive weights.</caption>
<thead><tr class="header">
<th align="left">Dataset</th>
<th align="right">Common edges</th>
<th align="right">Missing edges</th>
<th align="right">Extra edges</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">Enron</td>
<td align="right">412</td>
<td align="right">76</td>
<td align="right">70</td>
</tr>
<tr class="even">
<td align="left">C. Elegans</td>
<td align="right">116</td>
<td align="right">981</td>
<td align="right">400</td>
</tr>
</tbody>
</table>
<div class="section level3">
<h3 id="sec:Enron">Example: Enron Email Network Data<a class="anchor" aria-label="anchor" href="#sec:Enron"></a>
</h3>
<p>The Enron email network data was originally made public by the
Federal Energy Commission during the investigation into the Enron
Corporation (<span class="citation">Leskovec et al. (2008)</span>).
<!-- DLS: Citation --> Each node of Enron network represents an email
address and if there is at least one email sent from one address to
another address, a directed edge exists between the corresponding
nodes.</p>
<p>The <code>iGraphMatch</code> package includes the Enron email network
data in the form of a pair of <code>igraph</code> objects derived from
the original data where each graph represents one week of emails between
184 email addresses. The two networks are unweighted and directed with
edge densities around 0.01 in each graph and the empirical correlation
between two graphs is 0.85.</p>
<p>First, let’s load packages required for the following analysis:</p>
<div class="sourceCode" id="cb47"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://r.igraph.org/" class="external-link">igraph</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/dpmcsuss/iGraphMatch" class="external-link">iGraphMatch</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://purrr.tidyverse.org/" class="external-link">purrr</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://dplyr.tidyverse.org" class="external-link">dplyr</a></span><span class="op">)</span></span></code></pre></div>
<div class="section level4">
<h4 id="visualization-of-enron-networks">Visualization of Enron networks<a class="anchor" aria-label="anchor" href="#visualization-of-enron-networks"></a>
</h4>
<p>We visualize the aligned Enron networks using the function with
vertices sorted by a community detection algorithm (<span class="citation">Clauset, Newman, and Moore (2004)</span>) and degree.
For detailed interpretations to figure @ref(fig:Enron-graph), please
refer to figure @ref(fig:visualization).</p>
<div class="sourceCode" id="cb48"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">g</span> <span class="op">&lt;-</span> <span class="fu">igraph</span><span class="fu">::</span><span class="fu"><a href="https://r.igraph.org/reference/as.directed.html" class="external-link">as.undirected</a></span><span class="op">(</span><span class="va">Enron</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="va">com</span> <span class="op">&lt;-</span> <span class="fu">igraph</span><span class="fu">::</span><span class="fu"><a href="https://r.igraph.org/reference/communities.html" class="external-link">membership</a></span><span class="op">(</span><span class="fu">igraph</span><span class="fu">::</span><span class="fu"><a href="https://r.igraph.org/reference/cluster_fast_greedy.html" class="external-link">cluster_fast_greedy</a></span><span class="op">(</span><span class="va">g</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">deg</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">rowSums</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">as.matrix</a></span><span class="op">(</span><span class="va">g</span><span class="op">[</span><span class="op">]</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">ord</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/order.html" class="external-link">order</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="va">deg</span><span class="op">)</span><span class="op">*</span><span class="va">com</span><span class="op">+</span><span class="va">deg</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">Enron</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">[</span><span class="op">]</span><span class="op">[</span><span class="va">ord</span>,<span class="va">ord</span><span class="op">]</span>, <span class="va">Enron</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span><span class="op">[</span><span class="op">]</span><span class="op">[</span><span class="va">ord</span>,<span class="va">ord</span><span class="op">]</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="iGraphMatch_files/figure-html/Enron-graph-1.png" alt="Asymmetric adjacency matrices of aligned Enron Corporation communication networks. The vertices are sorted by a community detection algorithm (@community_detection) and degree." width="700"><p class="caption">
Asymmetric adjacency matrices of aligned Enron Corporation communication
networks. The vertices are sorted by a community detection algorithm
(<span class="citation">Clauset, Newman, and Moore (2004)</span>) and
degree.
</p>
</div>
<p>Note that 37 and 32 out of the total 184 nodes are isolated from the
other nodes in two graphs respectively, indicating the corresponding
employees haven’t sent or received emails from other employees. This
adds difficulty to matching since it’s impossible to distinguish the
isolated nodes based on topological structure alone. We first keep only
the largest connected component of each graph.</p>
<div class="sourceCode" id="cb49"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vid1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/which.html" class="external-link">which</a></span><span class="op">(</span><span class="fu"><a href="../reference/largest_common_cc.html">largest_cc</a></span><span class="op">(</span><span class="va">Enron</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">)</span><span class="op">$</span><span class="va">keep</span><span class="op">)</span></span>
<span><span class="va">vid2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/which.html" class="external-link">which</a></span><span class="op">(</span><span class="fu"><a href="../reference/largest_common_cc.html">largest_cc</a></span><span class="op">(</span><span class="va">Enron</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span><span class="op">)</span><span class="op">$</span><span class="va">keep</span><span class="op">)</span></span>
<span></span>
<span><span class="va">vinsct</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://generics.r-lib.org/reference/setops.html" class="external-link">intersect</a></span><span class="op">(</span><span class="va">vid1</span>, <span class="va">vid2</span><span class="op">)</span> </span>
<span><span class="va">v1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://generics.r-lib.org/reference/setops.html" class="external-link">setdiff</a></span><span class="op">(</span><span class="va">vid1</span>, <span class="va">vid2</span><span class="op">)</span></span>
<span><span class="va">v2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://generics.r-lib.org/reference/setops.html" class="external-link">setdiff</a></span><span class="op">(</span><span class="va">vid2</span>, <span class="va">vid1</span><span class="op">)</span></span>
<span><span class="va">A</span> <span class="op">&lt;-</span> <span class="va">Enron</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">[</span><span class="op">]</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">vinsct</span>, <span class="va">v1</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">vinsct</span>, <span class="va">v1</span><span class="op">)</span><span class="op">]</span></span>
<span><span class="va">B</span> <span class="op">&lt;-</span> <span class="va">Enron</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span><span class="op">[</span><span class="op">]</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">vinsct</span>, <span class="va">v2</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">vinsct</span>, <span class="va">v2</span><span class="op">)</span><span class="op">]</span></span></code></pre></div>
<p>The sizes of largest connect components of two graphs are 146 and
151, which are different. We reorder two graphs so that the first 145
nodes are aligned and common to both graphs.</p>
</div>
<div class="section level4">
<h4 id="matching-largest-connected-components-using-fw-algorithm">Matching largest connected components using FW Algorithm<a class="anchor" aria-label="anchor" href="#matching-largest-connected-components-using-fw-algorithm"></a>
</h4>
<p>Let’s assume the Enron email communication network from the second
week is anonymous, and we aim at finding an alignment between the email
addresses from the first network and the second one to de-anonymize the
latter. Additionally, we want to find the email addresses that are
active in both months.</p>
<p>Suppose no prior information on partial alignment is available in
this example. We match the two largest connected components using the
<span class="smallcaps">FW</span> algorithm with indefinite relaxation
since seeds and similarity scores are not mandatory for this method.</p>
<p>Without any prior information, and arguments take default values
which are . For the argument, we assign equal likelihood to all the
possible matches by initializing at the barycenter. Since two graphs are
of different sizes, the function automatically pads the smaller graph
with extra 0’s.</p>
<div class="sourceCode" id="cb50"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span>
<span><span class="va">match_FW</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/gm.html">gm</a></span><span class="op">(</span>A <span class="op">=</span> <span class="va">A</span>, B <span class="op">=</span> <span class="va">B</span>, start <span class="op">=</span> <span class="st">"bari"</span>, max_iter <span class="op">=</span> <span class="fl">200</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">match_FW</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##   corr_A corr_B</span></span>
<span><span class="co">## 1      1     27</span></span>
<span><span class="co">## 2      2      2</span></span>
<span><span class="co">## 3      3     30</span></span>
<span><span class="co">## 4      4      4</span></span>
<span><span class="co">## 5      5      5</span></span>
<span><span class="co">## 6      6      6</span></span></code></pre>
<p>Then, we check the summary of matching performance in terms of
matched nodes, matched edges and the graph matching objective
function.</p>
<div class="sourceCode" id="cb52"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">match_FW</span>, <span class="va">A</span>, <span class="va">B</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Call: gm(A = A, B = B, start = "bari", max_iter = 200)</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## # Matches: 151, # Seeds:  0, # Vertices:  146, 151</span></span>
<span><span class="co">##                   </span></span>
<span><span class="co">##   common_edges 353</span></span>
<span><span class="co">##  missing_edges 134</span></span>
<span><span class="co">##    extra_edges 128</span></span>
<span><span class="co">##          fnorm  16</span></span></code></pre>
<p>In this example, we can evaluate the matching result based on
statistics on matched edges. Without any seeds or similarity scores,
around 72% of edges are correctly matched.</p>
</div>
<div class="section level4">
<h4 id="centering-the-larger-graph">Centering the larger graph<a class="anchor" aria-label="anchor" href="#centering-the-larger-graph"></a>
</h4>
<p>We can try to improve performance by centering <code>B</code> by
assigning -1 to non-edges, so that we penalize edges that are missing in
<code>B</code> but present in <code>A</code>.</p>
<div class="sourceCode" id="cb54"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">A_center</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/center_graph.html">center_graph</a></span><span class="op">(</span>A <span class="op">=</span> <span class="va">A</span>, scheme <span class="op">=</span> <span class="st">"naive"</span>, use_splr <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">B_center</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/center_graph.html">center_graph</a></span><span class="op">(</span>A <span class="op">=</span> <span class="va">B</span>, scheme <span class="op">=</span> <span class="st">"center"</span>, use_splr <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span>
<span><span class="va">match_FW_center</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/gm.html">gm</a></span><span class="op">(</span>A <span class="op">=</span> <span class="va">A_center</span>, B <span class="op">=</span> <span class="va">B_center</span>, </span>
<span>                           start <span class="op">=</span> <span class="st">"bari"</span>, max_iter <span class="op">=</span> <span class="fl">200</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">match_FW_center</span>, <span class="va">A</span>, <span class="va">B</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Call: gm(A = A_center, B = B_center, start = "bari", max_iter = 200)</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## # Matches: 151, # Seeds:  0, # Vertices:  146, 151</span></span>
<span><span class="co">##                   </span></span>
<span><span class="co">##   common_edges 396</span></span>
<span><span class="co">##  missing_edges  91</span></span>
<span><span class="co">##    extra_edges  85</span></span>
<span><span class="co">##          fnorm  13</span></span></code></pre>
<p>From the summary tables, we would prefer matching Enron networks with
the application of the centering scheme, since we get more matched
common edges, as well as fewer missing edges and extra edges.</p>
</div>
<div class="section level4">
<h4 id="matching-with-adaptive-seeds">Matching with adaptive seeds<a class="anchor" aria-label="anchor" href="#matching-with-adaptive-seeds"></a>
</h4>
<p>Supposing we have no access to ground truth, we use the function to
measure and rank the vertex-wise matching performance. Below shows the 6
matches that minimize the row permutation statistic.</p>
<div class="sourceCode" id="cb56"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">bm</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/best_matches.html">best_matches</a></span><span class="op">(</span>A <span class="op">=</span> <span class="va">A</span>, B <span class="op">=</span> <span class="va">B</span>, match <span class="op">=</span> <span class="va">match_FW_center</span>, </span>
<span>             measure <span class="op">=</span> <span class="st">"row_perm_stat"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">bm</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##      A_best B_best measure_value</span></span>
<span><span class="co">## V83      65     65         -40.6</span></span>
<span><span class="co">## V75      57     57          -3.4</span></span>
<span><span class="co">## V147    115    115          -3.2</span></span>
<span><span class="co">## V59      43     43          -2.9</span></span>
<span><span class="co">## V64      48     48          -2.3</span></span>
<span><span class="co">## V51      36     36          -1.9</span></span></code></pre>
<p>Since seeded graph matching enhances the graph matching performance
substantially (<span class="citation">Vince Lyzinski, Fishkind, and
Priebe (2014)</span>), it may be useful to use some of these best
matches as seeds to improve matching results. Here, we use adaptive
seeds, taking the <span class="math inline">\(ns\)</span> best matches
and using them as seeds in a second run of the matching algorithm. The
table below displays edge statistics and objective function values for
different number of adaptive seeds used. The second column in the table
shows the matching precision of the adaptive seeds based on ground
truth. Incorporating adaptive seeds and repeating the <span class="smallcaps">FW</span> matching procedure on centered graphs
further improve the matching results, compared with the case without any
adaptive seeds when <span class="math inline">\(ns=0\)</span>. The first
40 pairs of matched nodes ranked by function are all correctly matched,
and this is also when matching is improved the most.</p>
<div class="sourceCode" id="cb58"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">match_w_hard_seeds</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">ns</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="va">seeds_bm</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">bm</span>, <span class="va">ns</span><span class="op">)</span></span>
<span>  <span class="va">precision</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="va">seeds_bm</span><span class="op">$</span><span class="va">A_best</span> <span class="op">==</span> <span class="va">seeds_bm</span><span class="op">$</span><span class="va">B_best</span><span class="op">)</span></span>
<span>  <span class="va">match_FW_center_seeds</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/gm.html">gm</a></span><span class="op">(</span>A <span class="op">=</span> <span class="va">A_center</span>, B <span class="op">=</span> <span class="va">B_center</span>,</span>
<span>                           seeds <span class="op">=</span> <span class="va">seeds_bm</span>, similarity <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>                           start <span class="op">=</span> <span class="st">"bari"</span>, max_iter <span class="op">=</span> <span class="fl">100</span><span class="op">)</span></span>
<span>  <span class="va">edge_info</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">match_FW_center_seeds</span>, <span class="va">A</span>, <span class="va">B</span><span class="op">)</span><span class="op">$</span><span class="va">edge_match_info</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="va">ns</span>, <span class="va">precision</span>, <span class="va">edge_info</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">12345</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://purrr.tidyverse.org/reference/map_dfr.html" class="external-link">map_dfr</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span>from <span class="op">=</span> <span class="fl">0</span>, to <span class="op">=</span> <span class="fl">80</span>, by <span class="op">=</span> <span class="fl">20</span><span class="op">)</span>, <span class="va">match_w_hard_seeds</span><span class="op">)</span></span></code></pre></div>
<table class="table">
<thead><tr class="header">
<th align="right">ns</th>
<th align="right">precision</th>
<th align="right">common</th>
<th align="right">missing</th>
<th align="right">extra</th>
<th align="right">fnorm</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="right">0</td>
<td align="right">NaN</td>
<td align="right">327</td>
<td align="right">160</td>
<td align="right">154</td>
<td align="right">18</td>
</tr>
<tr class="even">
<td align="right">20</td>
<td align="right">1.00</td>
<td align="right">411</td>
<td align="right">76</td>
<td align="right">70</td>
<td align="right">12</td>
</tr>
<tr class="odd">
<td align="right">40</td>
<td align="right">0.98</td>
<td align="right">407</td>
<td align="right">80</td>
<td align="right">74</td>
<td align="right">12</td>
</tr>
<tr class="even">
<td align="right">60</td>
<td align="right">0.90</td>
<td align="right">393</td>
<td align="right">94</td>
<td align="right">88</td>
<td align="right">13</td>
</tr>
<tr class="odd">
<td align="right">80</td>
<td align="right">0.86</td>
<td align="right">397</td>
<td align="right">90</td>
<td align="right">84</td>
<td align="right">13</td>
</tr>
</tbody>
</table>
<p>As the number of adaptive seeds increases, the precision of adaptive
seeds decreases. Note that if they are treated as hard seeds, incorrect
matches will remain in the matched set and might cause a cascade of
errors. An alternative way is to treat the top-ranked matches as soft
seeds embedded in the start matrix to handle the uncertainty. In this
way, adaptive seeds not only provide prior information but also evolve
over iterations. The table below shows that the soft seeding approach
always outperforms or performs as good as the hard seeding approach
regardless of the number of adaptive seeds being used.</p>
<div class="sourceCode" id="cb59"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">match_w_soft_seeds</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">ns</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="va">seeds_bm</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">bm</span>, <span class="va">ns</span><span class="op">)</span></span>
<span>  <span class="va">precision</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="va">seeds_bm</span><span class="op">$</span><span class="va">A_best</span> <span class="op">==</span> <span class="va">seeds_bm</span><span class="op">$</span><span class="va">B_best</span><span class="op">)</span></span>
<span>  <span class="va">start_soft</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/init_start.html">init_start</a></span><span class="op">(</span>start <span class="op">=</span> <span class="st">"bari"</span>, </span>
<span>                           nns <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/dim.html" class="external-link">dim</a></span><span class="op">(</span><span class="va">A</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>, <span class="fu"><a href="https://rdrr.io/r/base/dim.html" class="external-link">dim</a></span><span class="op">(</span><span class="va">B</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span>, </span>
<span>                           soft_seeds <span class="op">=</span> <span class="va">seeds_bm</span><span class="op">)</span></span>
<span>  <span class="va">match_FW_center_soft_seeds</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/gm.html">gm</a></span><span class="op">(</span>A <span class="op">=</span> <span class="va">A_center</span>, B <span class="op">=</span> <span class="va">B_center</span>, </span>
<span>                           start <span class="op">=</span> <span class="va">start_soft</span>, max_iter <span class="op">=</span> <span class="fl">100</span><span class="op">)</span></span>
<span>  <span class="va">edge_info</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">match_FW_center_soft_seeds</span>, <span class="va">A</span>, <span class="va">B</span><span class="op">)</span><span class="op">$</span><span class="va">edge_match_info</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="va">ns</span>, <span class="va">precision</span>, <span class="va">edge_info</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">12345</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://purrr.tidyverse.org/reference/map_dfr.html" class="external-link">map_dfr</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span>from <span class="op">=</span> <span class="fl">0</span>, to <span class="op">=</span> <span class="fl">80</span>, by <span class="op">=</span> <span class="fl">20</span><span class="op">)</span>, <span class="va">match_w_soft_seeds</span><span class="op">)</span></span></code></pre></div>
<table class="table">
<thead><tr class="header">
<th align="right">ns</th>
<th align="right">precision</th>
<th align="right">common</th>
<th align="right">missing</th>
<th align="right">extra</th>
<th align="right">fnorm</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="right">0</td>
<td align="right">NaN</td>
<td align="right">327</td>
<td align="right">160</td>
<td align="right">154</td>
<td align="right">18</td>
</tr>
<tr class="even">
<td align="right">20</td>
<td align="right">1.00</td>
<td align="right">410</td>
<td align="right">77</td>
<td align="right">71</td>
<td align="right">12</td>
</tr>
<tr class="odd">
<td align="right">40</td>
<td align="right">0.98</td>
<td align="right">407</td>
<td align="right">80</td>
<td align="right">74</td>
<td align="right">12</td>
</tr>
<tr class="even">
<td align="right">60</td>
<td align="right">0.90</td>
<td align="right">398</td>
<td align="right">89</td>
<td align="right">83</td>
<td align="right">13</td>
</tr>
<tr class="odd">
<td align="right">80</td>
<td align="right">0.86</td>
<td align="right">398</td>
<td align="right">89</td>
<td align="right">83</td>
<td align="right">13</td>
</tr>
</tbody>
</table>
</div>
<div class="section level4">
<h4 id="core-vertices-detection">Core vertices detection<a class="anchor" aria-label="anchor" href="#core-vertices-detection"></a>
</h4>
<p>The function can also be used to detect core vertices. Suppose the
ground truth is known and that the first 145 vertices are core vertices.
The mean precision of detecting core vertices and junk vertices using
function is displayed in figure <span class="math inline">\(\ref{fig:core}\)</span>. A lower rank is a
stronger indicator of a core vertex and a higher rank is a stronger
indicator of a junk vertex. Let <span class="math inline">\(r^C_i, 1\le
i\le n_c\)</span> and <span class="math inline">\(r^J_j, 1\le j\le
n_j\)</span> denote the ranks associated with each core vertex and each
junk vertex. The figure shows the precision of identifying core vertices
at each low rank <span class="math inline">\(r\)</span>, i.e. <span class="math inline">\(\frac{1}{r}\sum_{i = 1}^{n_c}1_{r^C_i\le
r}\)</span>, and the precision of identifying junk vertices at each high
rank <span class="math inline">\(r\)</span>, i.e. <span class="math inline">\(\frac{1}{r}\sum_{j = 1}^{n_j}1_{r^J_j\ge
n_c+n_j-r}\)</span>, which are separated by the vertical lines.</p>
<div class="sourceCode" id="cb60"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">nc</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">vinsct</span><span class="op">)</span></span>
<span><span class="va">nj</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">v1</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">v2</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">core_precision</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">:</span><span class="va">nc</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html" class="external-link">%&gt;%</a></span> <span class="fu"><a href="https://purrr.tidyverse.org/reference/map.html" class="external-link">map_dbl</a></span><span class="op">(</span><span class="op">~</span><span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="va">bm</span><span class="op">$</span><span class="va">A_best</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="va">.x</span><span class="op">]</span><span class="op">&lt;=</span><span class="va">nc</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">junk_precision</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">:</span><span class="va">nj</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html" class="external-link">%&gt;%</a></span> <span class="fu"><a href="https://purrr.tidyverse.org/reference/map.html" class="external-link">map_dbl</a></span><span class="op">(</span><span class="op">~</span><span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="va">bm</span><span class="op">$</span><span class="va">A_best</span><span class="op">[</span><span class="op">(</span><span class="va">nc</span><span class="op">+</span><span class="va">.x</span><span class="op">)</span><span class="op">:</span><span class="op">(</span><span class="va">nc</span><span class="op">+</span><span class="va">nj</span><span class="op">)</span><span class="op">]</span><span class="op">&gt;</span><span class="va">nc</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>Core detection performance is substantially better than chance, as
represented by the dotted horizontal lines. The top 88 are all core
vertices indicating good overall performance for core identification.
For junk identification, the junk vertices are ranked 63, 62, 61, 49,
15, 10 according to which have the lowest score, indicating that some
junk vertices are difficult to identify.</p>
<div class="figure">
<img src="iGraphMatch_files/figure-html/unnamed-chunk-1-1.png" alt="\label{fig:core}Mean precision for identifying core and junk vertices for the Enron networks by using the row permutation test. The vertical lines separate the performance of identifying core vertices with low ranks from junk vertices with high ranks. The horizontal lines indicate the performance of a random classifier." width="0.5\textwidth" height="0.24\textheight"><p class="caption">
Mean precision for identifying core and junk vertices for the Enron
networks by using the row permutation test. The vertical lines separate
the performance of identifying core vertices with low ranks from junk
vertices with high ranks. The horizontal lines indicate the performance
of a random classifier.
</p>
</div>
</div>
</div>
<div class="section level3">
<h3 id="sec:CE">Example: C. Elegans Network Data<a class="anchor" aria-label="anchor" href="#sec:CE"></a>
</h3>
<p>The <em>C. Elegans</em> networks consist of the chemical synapses
network and the electrical synapses network of the roundworm, where each
of 279 nodes represents a neuron and each edge represents the intensity
of synapse connections between two neurons (<span class="citation">Chen
et al. (2015)</span>). Matching the chemical synapses network to the
electrical synapses network is essential for understanding how the brain
functions. These networks are quite sparse with edge densities of 0.03
and 0.01 in each graph and the empirical correlation between two graphs
is 0.1.</p>
<div class="section level4">
<h4 id="a-challenging-task">A challenging task<a class="anchor" aria-label="anchor" href="#a-challenging-task"></a>
</h4>
<p>For simplicity, we made the networks unweighted and undirected for
the experiments, and we assume the ground truth is known to be the
identity.</p>
<div class="sourceCode" id="cb61"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">C1</span> <span class="op">&lt;-</span> <span class="va">C.Elegans</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">[</span><span class="op">]</span> <span class="op">&gt;</span> <span class="fl">0</span></span>
<span><span class="va">C2</span> <span class="op">&lt;-</span> <span class="va">C.Elegans</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span><span class="op">[</span><span class="op">]</span> <span class="op">&gt;</span> <span class="fl">0</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">C1</span><span class="op">[</span><span class="op">]</span>, <span class="va">C2</span><span class="op">[</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="va">match</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/gm.html">gm</a></span><span class="op">(</span><span class="va">C1</span>, <span class="va">C2</span>, start <span class="op">=</span> <span class="fu">Matrix</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/Matrix/man/Diagonal.html" class="external-link">Diagonal</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">C1</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">C1</span><span class="op">[</span><span class="op">]</span>, <span class="va">C2</span><span class="op">[</span><span class="op">]</span>, <span class="va">match</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="iGraphMatch_files/figure-html/C-Elegans-edge-1.png" alt="Edge discrepancies for the matched graphs with the true correspondence (left) and FW algorithm starting at the true correspondence (right). Green pixels represents an edge in the chemical graph while no edge in the electrical graph. Red pixels represent only an edge in the electrical graph. Grey pixels represent there is an edge in both graphs and white represents no edge in both graphs." width="700"><img src="iGraphMatch_files/figure-html/C-Elegans-edge-2.png" alt="Edge discrepancies for the matched graphs with the true correspondence (left) and FW algorithm starting at the true correspondence (right). Green pixels represents an edge in the chemical graph while no edge in the electrical graph. Red pixels represent only an edge in the electrical graph. Grey pixels represent there is an edge in both graphs and white represents no edge in both graphs." width="700"><p class="caption">
Edge discrepancies for the matched graphs with the true correspondence
(left) and FW algorithm starting at the true correspondence (right).
Green pixels represents an edge in the chemical graph while no edge in
the electrical graph. Red pixels represent only an edge in the
electrical graph. Grey pixels represent there is an edge in both graphs
and white represents no edge in both graphs.
</p>
</div>
<div class="sourceCode" id="cb62"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">nv</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">C1</span><span class="op">)</span></span>
<span><span class="va">id_match</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/graphMatch_constructor.html">graphMatch</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>corr_A <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="va">nv</span>, corr_B <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="va">nv</span><span class="op">)</span>, <span class="va">nv</span><span class="op">)</span></span>
<span><span class="va">i_sum</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">id_match</span>, <span class="va">C.Elegans</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>, <span class="va">C.Elegans</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="va">m_sum</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">match</span>, <span class="va">C.Elegans</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>, <span class="va">C.Elegans</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span>, <span class="va">id_match</span><span class="op">)</span></span>
<span><span class="va">i_emi</span> <span class="op">&lt;-</span> <span class="va">i_sum</span><span class="op">$</span><span class="va">edge_match_info</span></span>
<span><span class="va">m_emi</span> <span class="op">&lt;-</span> <span class="va">m_sum</span><span class="op">$</span><span class="va">edge_match_info</span></span></code></pre></div>
<p>Matching the <em>C. Elegans</em> networks is a challenging task.
Figures @ref(fig:C-Elegans-edge) depict the edge discrepancies of two
networks under the true alignment and the matching correspondence using
<span class="smallcaps">FW</span> algorithm initialized at the true
alignment. The alignment found using <span class="smallcaps">FW</span>
is not the identity with 124 out of 279 nodes correctly matched and
improves upon the identity in terms of the number of edge discrepancies.
For the true alignment, there are 116 edge errors and 1380 common edges
while the alignment yielded by <span class="smallcaps">FW</span>
initialized at the true correspondence has 267.5 edge errors and 1078
common edges. Hence, this graph matching object does not have a solution
at the true alignment. One can try to use other objective functions to
enhance the matching result, however we do not investigate this here.
Overall, while most performance measures are poor, our results
illustrate the spectrum of challenges for graph matching.</p>
</div>
<div class="section level4">
<h4 id="soft-matching-map3">Soft matching: MAP@3<a class="anchor" aria-label="anchor" href="#soft-matching-map3"></a>
</h4>
<p>Considering matching <em>C. Elegans</em> graphs is quite challenging,
let’s assume 20 pairs of vertices are known as seeds, which are chosen
at random. Accordingly, we generate a similarity matrix with 1’s
corresponding to seeds, and the rest being barycenter.</p>
<div class="sourceCode" id="cb63"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">seeds</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">C1</span><span class="op">)</span>, <span class="fl">20</span><span class="op">)</span></span>
<span><span class="va">sim</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/init_start.html">init_start</a></span><span class="op">(</span>start <span class="op">=</span> <span class="st">"bari"</span>, nns <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">C1</span><span class="op">)</span>, soft_seeds <span class="op">=</span> <span class="va">seeds</span><span class="op">)</span></span></code></pre></div>
<p>In addition to one-on-one matching, we will also conduct soft
matching, which is to find three most promising matches to each non-seed
vertex. We achieve the goal of soft matching by finding the top 3
largest values in each row of the doubly stochastic matrix from the last
iteration of <span class="smallcaps">Frank Wolfe</span> methodology with
indefinite relaxation and <span class="smallcaps">PATH</span> algorithm,
as well as the normalized matrix from the last iteration of the power
method for <span class="smallcaps">IsoRank</span> algorithm. To evaluate
the matching performance, we will look at both matching precision: <span class="math inline">\(precision=\frac{1}{n_m-s}\sum_{i\in V_m\setminus
S}P_{ii}\)</span>, and Mean Average Precision @ 3 (MAP@ 3):<span class="math inline">\(MAP@3 = \frac{1}{n_m-s}\sum_{i\in V_m\setminus
S}1_{\{i\in T_i\}}\)</span>, where <span class="math inline">\(T_i\)</span> is the set of 3 most promising
matches to node <span class="math inline">\(i\)</span>.</p>
<div class="sourceCode" id="cb64"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span><span class="va">m_FW</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/gm.html">gm</a></span><span class="op">(</span>A <span class="op">=</span> <span class="va">C1</span>, B <span class="op">=</span> <span class="va">C2</span>, seeds <span class="op">=</span> <span class="va">seeds</span>, </span>
<span>           similarity <span class="op">=</span> <span class="va">sim</span>, method <span class="op">=</span> <span class="st">"indefinite"</span>,</span>
<span>           start <span class="op">=</span> <span class="st">"bari"</span>, max_iter <span class="op">=</span> <span class="fl">100</span><span class="op">)</span></span>
<span><span class="va">m_PATH</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/gm.html">gm</a></span><span class="op">(</span>A <span class="op">=</span> <span class="va">C1</span>, B <span class="op">=</span> <span class="va">C2</span>, seeds <span class="op">=</span> <span class="va">seeds</span>,</span>
<span>             similarity <span class="op">=</span> <span class="cn">NULL</span>, method <span class="op">=</span> <span class="st">"PATH"</span>,</span>
<span>             epsilon <span class="op">=</span> <span class="fl">1</span>, tol <span class="op">=</span> <span class="fl">1e-05</span><span class="op">)</span></span>
<span><span class="va">m_Iso</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/gm.html">gm</a></span><span class="op">(</span>A <span class="op">=</span> <span class="va">C1</span>, B <span class="op">=</span> <span class="va">C2</span>, seeds <span class="op">=</span> <span class="va">seeds</span>,</span>
<span>             similarity <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">as.matrix</a></span><span class="op">(</span><span class="va">sim</span><span class="op">)</span>, method <span class="op">=</span> <span class="st">"IsoRank"</span>,</span>
<span>             max_iter <span class="op">=</span> <span class="fl">50</span>, lap_method <span class="op">=</span> <span class="st">"LAP"</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb65"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">match_eval</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">match</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="va">precision</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="va">match</span><span class="op">$</span><span class="va">corr_A</span> <span class="op">==</span> <span class="va">match</span><span class="op">$</span><span class="va">corr_B</span><span class="op">)</span> </span>
<span>  <span class="va">order</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/apply.html" class="external-link">apply</a></span><span class="op">(</span><span class="va">match</span><span class="op">$</span><span class="va">soft</span>, MARGIN <span class="op">=</span> <span class="fl">1</span>, FUN <span class="op">=</span> <span class="va">order</span>, decreasing <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span>  <span class="va">top3</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">order</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span>,<span class="op">]</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">order</span><span class="op">)</span> </span>
<span>  <span class="va">MAP3</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/apply.html" class="external-link">apply</a></span><span class="op">(</span><span class="va">top3</span>, MARGIN <span class="op">=</span> <span class="fl">1</span>, FUN <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">v</span><span class="op">)</span><span class="op">{</span><span class="fl">0</span> <span class="op"><a href="https://rdrr.io/r/base/match.html" class="external-link">%in%</a></span> <span class="va">v</span><span class="op">}</span><span class="op">)</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span><span class="va">precision</span>, <span class="va">MAP3</span><span class="op">)</span>,<span class="fl">4</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">sapply</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">m_FW</span>, <span class="va">m_PATH</span>, <span class="va">m_Iso</span><span class="op">)</span>, <span class="va">match_eval</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html" class="external-link">%&gt;%</a></span> </span>
<span>  <span class="fu">knitr</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/knitr/man/kable.html" class="external-link">kable</a></span><span class="op">(</span>col.names <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Frank Wolfe"</span>, <span class="st">"PATH"</span>, <span class="st">"IsoRank"</span><span class="op">)</span>, </span>
<span>               booktabs <span class="op">=</span> <span class="cn">TRUE</span>, digits <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<table class="table">
<thead><tr class="header">
<th align="left"></th>
<th align="left">Frank Wolfe</th>
<th align="left">PATH</th>
<th align="left">IsoRank</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">precision</td>
<td align="left">0.0896</td>
<td align="left">0.086</td>
<td align="left">0.0789</td>
</tr>
<tr class="even">
<td align="left">MAP3</td>
<td align="left">0.0968</td>
<td align="left">0.1111</td>
<td align="left">0.0824</td>
</tr>
</tbody>
</table>
<p>MAP@ 3 is slightly higher than precision for each method. Soft
matching provides an alternative way of matching by generating a set of
promising matching candidates.</p>
</div>
</div>
<div class="section level3">
<h3 id="sec:Transp">Example: Britain Transportation Network<a class="anchor" aria-label="anchor" href="#sec:Transp"></a>
</h3>
<p>To demonstrate matching multi-layer networks-layers, we consider two
graphs derived from the Britain Transportation network (<span class="citation">Riccardo and Marc (2015)</span>). The network reflects
the transportation connections in the UK, with five layers representing
ferry, rail, metro, coach, and bus. A smaller template graph was
constructed based on a random walk starting from a randomly chosen hub
node, a node that has connections in all the layers. The template graph
has 53 nodes and 56 connections in total and is an induced subgraph of
the original graph.</p>
<p>Additionally, based on filter methods from , the authors of that
paper also provided a list of candidate matches for each template node,
where the true correspondence is guaranteed to be among the candidates.
The number of candidates ranges from 3 to 1059 at most, with an average
of 241 candidates for each template vertex. Thus, we made an induced
subgraph from the transportation network with only candidates, which
gave us the world graph with 2075 vertices and 8368 connections.</p>
<div class="sourceCode" id="cb66"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">tm</span> <span class="op">&lt;-</span> <span class="va">Transportation</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span></span>
<span><span class="va">cm</span> <span class="op">&lt;-</span> <span class="va">Transportation</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span></span>
<span><span class="va">candidate</span> <span class="op">&lt;-</span> <span class="va">Transportation</span><span class="op">[[</span><span class="fl">3</span><span class="op">]</span><span class="op">]</span></span></code></pre></div>
<p>Figure <span class="math inline">\(\ref{Fig:trans_net}\)</span>
visualizes the transportation connections for the induced subgraphs,
where means of transportation are represented by different colors. Note
that all edges in the template are common edges shared by two graphs,
where 40%, 24.1%, 37.5%, 31.7% and 25.6% of edges in the world graph are
in template for each layer. All graphs are unweighted, directed, and do
not have self-loops. Tables @ref(tab:edge-summary-trans) further
displays an overview and edge summary regarding each layer of the
Britain Transportation Network. A true correspondence exists for each
template vertex in the world graph, our goal is to locate each template
vertex in the Britain Transportation network by matching two multi-layer
graphs with different number of vertices.</p>
<table class="table">
<caption>Overview of the Britain Transportation Network layers.
Correlation is calculted using the template graph and the aligned
induced subgraph of the world graph. The final three columns indicate
the number of common edges, missing edges, and extra edges in the
aligned subgraph of the world graph.</caption>
<thead><tr class="header">
<th align="left">Layer</th>
<th align="left"># Nodes</th>
<th align="left"># Edges</th>
<th align="right">Correlation</th>
<th align="right">Common</th>
<th align="right">Missing</th>
<th align="right">Extra</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">Ferry</td>
<td align="left">53 / 2075</td>
<td align="left">10 / 42</td>
<td align="right">0.63</td>
<td align="right">10</td>
<td align="right">0</td>
<td align="right">15</td>
</tr>
<tr class="even">
<td align="left">Rail</td>
<td align="left">53 / 2075</td>
<td align="left">14 / 4185</td>
<td align="right">0.49</td>
<td align="right">14</td>
<td align="right">0</td>
<td align="right">44</td>
</tr>
<tr class="odd">
<td align="left">Metro</td>
<td align="left">53 / 2075</td>
<td align="left">9 / 445</td>
<td align="right">0.61</td>
<td align="right">9</td>
<td align="right">0</td>
<td align="right">15</td>
</tr>
<tr class="even">
<td align="left">Coach</td>
<td align="left">53 / 2075</td>
<td align="left">13 / 2818</td>
<td align="right">0.56</td>
<td align="right">13</td>
<td align="right">0</td>
<td align="right">28</td>
</tr>
<tr class="odd">
<td align="left">Bus</td>
<td align="left">53 / 2075</td>
<td align="left">10 / 878</td>
<td align="right">0.50</td>
<td align="right">10</td>
<td align="right">0</td>
<td align="right">29</td>
</tr>
</tbody>
</table>
<div class="figure">
<img src="iGraphMatch_files/figure-html/unnamed-chunk-2-1.png" alt="\label{Fig:trans_net} Visualization of the template graph (left) and the world graph (right) with corresponding vertices, both derived from the Britain Transportation network with five layers: ferry, rail, metro, coach, and bus. Edges represent transportation transactions and each color indicates a different means of transportation from a different layer of network." width="47.5%"><img src="iGraphMatch_files/figure-html/unnamed-chunk-2-2.png" alt="\label{Fig:trans_net} Visualization of the template graph (left) and the world graph (right) with corresponding vertices, both derived from the Britain Transportation network with five layers: ferry, rail, metro, coach, and bus. Edges represent transportation transactions and each color indicates a different means of transportation from a different layer of network." width="47.5%"><p class="caption">
Visualization of the template graph (left) and the world graph (right)
with corresponding vertices, both derived from the Britain
Transportation network with five layers: ferry, rail, metro, coach, and
bus. Edges represent transportation transactions and each color
indicates a different means of transportation from a different layer of
network.
</p>
</div>
<p>Based on the candidates, we specify a start matrix that is
row-stochastic which can be used for the argument in the graph matching
function for <span class="smallcaps">FW</span> methodology. For each row
node, its value is either zero or the inverse of the number of
candidates for that node. To ensure that template nodes only get matched
to candidates, we constructed a similarity score matrix by taking the
start matrix <span class="math inline">\(\times 10^5\)</span>, so that a
high similarity score is assigned to all the template-candidate
pairs.</p>
<p>Then we match the template graph with the world graph using <span class="smallcaps">Percolation</span> algorithm. The template graph
stored in and world graph are lists of 5 matrices of dimensions 53 and
2075 respectively. Since we have no information on seeds, we assign to
the argument, the <span class="smallcaps">Percolation</span> algorithm
will initialize the mark matrix using prior information in the
similarity score matrix.</p>
<div class="sourceCode" id="cb67"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">match</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/gm.html">gm</a></span><span class="op">(</span>A <span class="op">=</span> <span class="va">tm</span>, B <span class="op">=</span> <span class="va">cm</span>, similarity <span class="op">=</span> <span class="va">similarity</span>, </span>
<span>            method <span class="op">=</span> <span class="st">"percolation"</span>, r <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">match</span>, <span class="va">tm</span>, <span class="va">cm</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Call: gm(A = tm, B = cm, similarity = similarity, method = "percolation", </span></span>
<span><span class="co">##     r = 4)</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## # Matches: 53, # Seeds:  0, # Vertices:  53, 2075</span></span>
<span><span class="co">##          layer    1    2    3    4    5</span></span>
<span><span class="co">##   common_edges 10.0 13.0  9.0 11.0 10.0</span></span>
<span><span class="co">##  missing_edges  0.0  1.0  0.0  2.0  0.0</span></span>
<span><span class="co">##    extra_edges 22.0 36.0 21.0 24.0 35.0</span></span>
<span><span class="co">##          fnorm  4.7  6.1  4.6  5.1  5.9</span></span></code></pre>
<p>The function outputs edge statistics and objective function values
for each layer separately. To further improve matching performance, one
can replicate all the analysis in the first example on Enron dataset,
such as using the centering scheme and adaptive seeds. Finally, one can
refer to the match report to compare matching performance and pick the
best one.</p>
</div>
</div>
<div class="section level2">
<h2 id="sec:conclusion">Conclusions<a class="anchor" aria-label="anchor" href="#sec:conclusion"></a>
</h2>
<p>In this work, we detail the methods and usage of the R package
<code>iGraphMatch</code> for finding and assessing an alignment between
the vertex sets of two edge-correlated graphs. The package implements
common steps for the analysis of graph matching: seamless matching of
generalized graphs, evaluation of matching performance, and
visualization. For each of the graph matching methodologies, we provide
versatile options for the form of input graphs and the specification of
available prior information. Through the discussion in section <span class="math inline">\(\ref{sec:example}\)</span>, we demonstrate the
broad functionality and flexibility of the package by analyzing diverse
graph matching problems on real data step by step. The package also
provides tools for simulating correlated graphs which can be used in the
development and enhancement of graph matching methods.</p>
<p>Methods for graph matching are still under active development. We
plan to include other novel methods as the field continues to develop.
In the short term we are looking to introduce a suite of additional
matching methods that have recently been proposed in the literature.</p>
<p>One of the biggest challenges for graph matching is evaluating the
quality of a match, especially at the vertex level. This has received
minimal attention in the previous literature. We provide measures of
goodness of matching on the vertex level and demonstrate their
effectiveness empirically. These baseline methods implement a
permutation testing framework for assessing matches that can be readily
extended to other metrics.</p>
<p>The primary authors for the package are Vince Lyzinski, Zihuan Qiao,
and Daniel Sussman. Joshua Agterberg, Lujia Wang, and Yixin Kong also
provided important contributions. We also want to thank all of our
users, especially Youngser Park, for their feedback and patience as we
continue to develop the package.</p>
<p>This work was supported in part by grants from DARPA
(FA8750-20-2-1001 and FA8750-18-0035) and from MIT Lincoln Labs.</p>
</div>
<div class="section level2">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-relax_paper" class="csl-entry">
Aflalo, Yonathan, Alexander Bronstein, and Ron Kimmel. 2015b. <span>“On
Convex Relaxation of Graph Isomorphism.”</span> <em>Proceedings of the
National Academy of Sciences</em> 112 (10): 2942–47. <a href="https://doi.org/10.1073/pnas.1401651112" class="external-link">https://doi.org/10.1073/pnas.1401651112</a>.
</div>
<div id="ref-friendly" class="csl-entry">
———. 2015a. <span>“On Convex Relaxation of Graph Isomorphism.”</span>
<em>Proceedings of the National Academy of Sciences</em> 112 (10):
2942–47. <a href="https://doi.org/10.1073/pnas.1401651112" class="external-link">https://doi.org/10.1073/pnas.1401651112</a>.
</div>
<div id="ref-SimilarityScore" class="csl-entry">
Belongie, S., J. Malik, and J. Puzicha. 2002. <span>“Shape Matching and
Object Recognition Using Shape Contexts.”</span> <em>IEEE Transactions
on Pattern Analysis and Machine Intelligence</em> 24 (4): 509–22. <a href="https://doi.org/10.1109/34.993558" class="external-link">https://doi.org/10.1109/34.993558</a>.
</div>
<div id="ref-PatternRec1" class="csl-entry">
Berg, A. C., T. L. Berg, and J. Malik. 2005. <span>“Shape Matching and
Object Recognition Using Low Distortion Correspondences”</span> 1: 26–33
vol. 1. <a href="https://doi.org/10.1109/CVPR.2005.320" class="external-link">https://doi.org/10.1109/CVPR.2005.320</a>.
</div>
<div id="ref-AP" class="csl-entry">
Burkard, Rainer, Mauro Dell’Amico, and Silvano Martello. 2009.
<em>Assignment Problems</em>. Philadelphia, PA, USA: Society for
Industrial; Applied Mathematics.
</div>
<div id="ref-PatternRec2" class="csl-entry">
Caelli, T., and S. Kosinov. 2004. <span>“An Eigenspace Projection
Clustering Method for Inexact Graph Matching.”</span> <em>IEEE
Transactions on Pattern Analysis and Machine Intelligence</em> 26 (4):
515–19. <a href="https://doi.org/10.1109/TPAMI.2004.1265866" class="external-link">https://doi.org/10.1109/TPAMI.2004.1265866</a>.
</div>
<div id="ref-neuro" class="csl-entry">
Chen, Li, Joshua T. Vogelstein, Vince Lyzinski, and Carey E. Priebe.
2015. <span>“A Joint Graph Inference Case Study: The c.elegans Chemical
and Electrical Connectomes.”</span> <a href="https://arxiv.org/abs/1507.08376" class="external-link">https://arxiv.org/abs/1507.08376</a>.
</div>
<div id="ref-community_detection" class="csl-entry">
Clauset, Aaron, M. E. J. Newman, and Cristopher Moore. 2004.
<span>“Finding Community Structure in Very Large Networks.”</span>
<em>Physical Review E</em> 70 (6). <a href="https://doi.org/10.1103/physreve.70.066111" class="external-link">https://doi.org/10.1103/physreve.70.066111</a>.
</div>
<div id="ref-PatternRec3" class="csl-entry">
Conte, Donatello, Pasquale Foggia, Mario Vento, and Carlo Sansone. 2004.
<span>“<span>Thirty Years Of Graph Matching In Pattern
Recognition</span>.”</span> <em><span>International Journal of Pattern
Recognition and Artificial Intelligence</span></em> 18 (3): 265–98. <a href="https://doi.org/10.1142/S0218001404003228" class="external-link">https://doi.org/10.1142/S0218001404003228</a>.
</div>
<div id="ref-ML2" class="csl-entry">
Cour, Timothee, Praveen Srinivasan, and Jianbo Shi. 2007.
<span>“Balanced Graph Matching.”</span> Edited by B. Schölkopf, J. C.
Platt, and T. Hoffman, 313–20. <a href="http://papers.nips.cc/paper/2960-balanced-graph-matching.pdf" class="external-link">http://papers.nips.cc/paper/2960-balanced-graph-matching.pdf</a>.
</div>
<div id="ref-igraph" class="csl-entry">
Csardi, Gabor, and Tamas Nepusz. 2006. <span>“The Igraph Software
Package for Complex Network Research.”</span> <em>InterJournal</em>
Complex Systems: 1695. <a href="https://igraph.org" class="external-link">https://igraph.org</a>.
</div>
<div id="ref-GRAMPA" class="csl-entry">
Fan, Zhou, Cheng Mao, Yihong Wu, and Jiaming Xu. 2020. <span>“Spectral
Graph Matching and Regularized Quadratic Relaxations: Algorithm and
Theory.”</span> In <em>Proceedings of the 37th International Conference
on Machine Learning</em>, edited by Hal Daumé III and Aarti Singh,
119:2985–95. Proceedings of Machine Learning Research. PMLR. <a href="https://proceedings.mlr.press/v119/fan20a.html" class="external-link">https://proceedings.mlr.press/v119/fan20a.html</a>.
</div>
<div id="ref-soft_seeding" class="csl-entry">
Fang, Fei, Daniel Sussman, and Vince Lyzinski. 2018. <span>“Tractable
Graph Matching via Soft Seeding,”</span> July.
</div>
<div id="ref-QAP" class="csl-entry">
Finke, Gerd, Rainer E. Burkard, and Franz Rendl. 1987. <span>“Quadratic
Assignment Problems.”</span> In <em>Surveys in Combinatorial
Optimization</em>, edited by Silvano Martello, Gilbert Laporte, Michel
Minoux, and Celso Ribeiro, 132:61–82. North-Holland Mathematics Studies.
North-Holland. https://doi.org/<a href="https://doi.org/10.1016/S0304-0208(08)73232-8" class="external-link">https://doi.org/10.1016/S0304-0208(08)73232-8</a>.
</div>
<div id="ref-FW" class="csl-entry">
Frank, Marguerite, and Philip Wolfe. 1956. <span>“An Algorithm for
Quadratic Programming.”</span> <em>Naval Research Logistics
Quarterly</em> 3 (1‐2): 95–110. <a href="https://EconPapers.repec.org/RePEc:wly:navlog:v:3:y:1956:i:1-2:p:95-110" class="external-link">https://EconPapers.repec.org/RePEc:wly:navlog:v:3:y:1956:i:1-2:p:95-110</a>.
</div>
<div id="ref-SBM" class="csl-entry">
Holland, Paul, Kathryn Laskey, and Samuel Leinhardt. 1983.
<span>“Stochastic Blockmodels: First Steps.”</span> <em>Social Networks
- SOC NETWORKS</em> 5 (June): 109–37. <a href="https://doi.org/10.1016/0378-8733(83)90021-7" class="external-link">https://doi.org/10.1016/0378-8733(83)90021-7</a>.
</div>
<div id="ref-Hu2018-hd" class="csl-entry">
Hu, S, L Zou, J X Yu, H Wang, and D Zhao. 2018. <span>“Answering Natural
Language Questions by Subgraph Matching over Knowledge Graphs.”</span>
<em>IEEE Transactions on Knowledge and Data Engineering</em> 30 (5):
824–37.
</div>
<div id="ref-Corbi" class="csl-entry">
Huang, Qiang, Ling-Yun Wu, and Xiang-Sun Zhang. 2013. <span>“Corbi: A
New r Package for Biological Network Alignment and Querying.”</span>
</div>
<div id="ref-bio2" class="csl-entry">
Ito, Takashi, Tomoko Chiba, Ritsuko Ozawa, Mikio Yoshida, Masahira
Hattori, and Yoshiyuki Sakaki. 2001. <span>“A Comprehensive Two-Hybrid
Analysis to Explore the Yeast Protein Interactome.”</span>
<em>Proceedings of the National Academy of Sciences</em> 98 (8):
4569–74. <a href="https://doi.org/10.1073/pnas.061034498" class="external-link">https://doi.org/10.1073/pnas.061034498</a>.
</div>
<div id="ref-lap_solver" class="csl-entry">
Jonker, Roy, and Ton Volgenant. 1988. <span>“A Shortest Augmenting Path
Algorithm for Dense and Sparse Linear Assignment Problems.”</span> In
<em>DGOR/NSOR</em>, edited by Helmut Schellhaas, Paul van Beek, Heinz
Isermann, Reinhart Schmidt, and Mynt Zijlstra, 622–22. Berlin,
Heidelberg: Springer Berlin Heidelberg.
</div>
<div id="ref-ExpandWhenStuck" class="csl-entry">
Kazemi, Ehsan, S Hamed Hassani, and Matthias Grossglauser. 2015.
<span>“Growing a Graph Matching from a Handful of Seeds.”</span>
<em>Proceedings of the VLDB Endowment</em> 8 (June): 1010–21. <a href="https://doi.org/10.14778/2794367.2794371" class="external-link">https://doi.org/10.14778/2794367.2794371</a>.
</div>
<div id="ref-BLAST" class="csl-entry">
Kelley, Brian, Bingbing Yuan, Fran Lewitter, Roded Sharan, Brent
Stockwell, and Trey Ideker. 2004. <span>“PathBLAST: A Tool for Alignment
of Protein Interaction Networks.”</span> <em>Nucleic Acids Research</em>
32 (August): W83–8.
</div>
<div id="ref-multilayer" class="csl-entry">
Kivelä, Mikko, Alex Arenas, Marc Barthelemy, James P. Gleeson, Yamir
Moreno, and Mason A. Porter. 2014. <span>“<span class="nocase">Multilayer networks</span>.”</span> <em>Journal of
Complex Networks</em> 2 (3): 203–71.
</div>
<div id="ref-measure" class="csl-entry">
Kuchaiev, Oleksii, and Natasa Przulj. 2011. <span>“Integrative Network
Alignment Reveals Large Regions of Global Network Similarity in Yeast
and Human.”</span> <em>Bioinformatics (Oxford, England)</em> 27 (March):
1390–96.
</div>
<div id="ref-Hungarian" class="csl-entry">
Kuhn, H. W. 1955. <span>“The Hungarian Method for the Assignment
Problem.”</span> <em>Naval Res. Logist. Quart.</em> 2 (January): 83–98.
<a href="https://doi.org/10.1002/nav.20053" class="external-link">https://doi.org/10.1002/nav.20053</a>.
</div>
<div id="ref-Enron" class="csl-entry">
Leskovec, Jure, Kevin J. Lang, Anirban Dasgupta, and Michael W. Mahoney.
2008. <span>“Community Structure in Large Networks: Natural Cluster
Sizes and the Absence of Large Well-Defined Clusters.”</span> <a href="https://arxiv.org/abs/0810.1355" class="external-link">https://arxiv.org/abs/0810.1355</a>.
</div>
<div id="ref-Lin" class="csl-entry">
Li, Lin, and Daniel L. Sussman. 2019. <span>“Graph Matching via
Multi-Scale Heat Diffusion.”</span> In <em>2019 IEEE International
Conference on Big Data (Big Data)</em>, 1157–62. <a href="https://doi.org/10.1109/BigData47090.2019.9005526" class="external-link">https://doi.org/10.1109/BigData47090.2019.9005526</a>.
</div>
<div id="ref-ML1" class="csl-entry">
Liu, Zhi-Yong, and Hong Qiao. 2012. <span>“A Convex-Concave Relaxation
Procedure Based Subgraph Matching Algorithm.”</span> Edited by Steven C.
H. Hoi and Wray Buntine, Proceedings of machine learning research, 25:
237–52. <a href="http://proceedings.mlr.press/v25/liu12a.html" class="external-link">http://proceedings.mlr.press/v25/liu12a.html</a>.
</div>
<div id="ref-FAQ" class="csl-entry">
Lyzinski, V., D. E. Fishkind, M. Fiori, J. T. Vogelstein, C. E. Priebe,
and G. Sapiro. 2016. <span>“Graph Matching: Relax at Your Own
Risk.”</span> <em>IEEE Transactions on Pattern Analysis and Machine
Intelligence</em> 38 (1): 60–73. <a href="https://doi.org/10.1109/TPAMI.2015.2424894" class="external-link">https://doi.org/10.1109/TPAMI.2015.2424894</a>.
</div>
<div id="ref-SGM" class="csl-entry">
Lyzinski, Vince, Donniell E. Fishkind, and Carey E. Priebe. 2014.
<span>“Seeded Graph Matching for Correlated Erdös-r<span>é</span>nyi
Graphs.”</span> <em>J. Mach. Learn. Res.</em> 15 (1): 3513–40. <a href="https://dl.acm.org/doi/10.5555/2627435.2750357" class="external-link">https://dl.acm.org/doi/10.5555/2627435.2750357</a>.
</div>
<div id="ref-row_perm" class="csl-entry">
Lyzinski, Vince, and Daniel Sussman. 2017. <span>“Graph Matching the
Matchable Nodes When Some Nodes Are Unmatchable.”</span> In. SIAM
Workshop on Network Science.
</div>
<div id="ref-SpecMatch" class="csl-entry">
Mateus, Diana, Radu P. Horaud, David Knossow, Fabio Cuzzolin, and Edmond
Boyer. 2008. <span>“Articulated Shape Matching Using Laplacian
Eigenfunctions and Unsupervised Point Registration.”</span> In
<em>Proceedings of the IEEE Conference on Computer Vision and Pattern
Recognition</em>. <a href="http://perception.inrialpes.fr/Publications/2008/MHKCB08/" class="external-link">http://perception.inrialpes.fr/Publications/2008/MHKCB08/</a>.
</div>
<div id="ref-bio3" class="csl-entry">
Nabieva, Elena, Kam Jim, Amit Agarwal, Bernard Chazelle, and Mona Singh.
2005. <span>“Whole-Proteome Prediction of Protein Function via
Graph-Theoretic Analysis of Interaction Maps.”</span>
</div>
<div id="ref-SocialNetwork" class="csl-entry">
Narayanan, A., and V. Shmatikov. 2009. <span>“De-Anonymizing Social
Networks.”</span> In <em>2009 30th IEEE Symposium on Security and
Privacy</em>, 173–87. <a href="https://doi.org/10.1109/SP.2009.22" class="external-link">https://doi.org/10.1109/SP.2009.22</a>.
</div>
<div id="ref-Papadimitriou1998-lz" class="csl-entry">
Papadimitriou, Christos H, and Kenneth Steiglitz. 1998.
<em>Combinatorial Optimization: Algorithms and Complexity</em>. Courier
Corporation. <a href="https://play.google.com/store/books/details?id=cDY-joeCGoIC" class="external-link">https://play.google.com/store/books/details?id=cDY-joeCGoIC</a>.
</div>
<div id="ref-transportation" class="csl-entry">
Riccardo, Gallotti, and Barthelemy Marc. 2015. <span>“The Multilayer
Temporal Network of Public Transport in Great Britain.”</span>
<em>Scientific Data</em> 2 (January). <a href="https://doi.org/10.1038/sdata.2014.56" class="external-link">https://doi.org/10.1038/sdata.2014.56</a>.
</div>
<div id="ref-IsoRank" class="csl-entry">
Singh, Rohit, Jinbo Xu, and Bonnie Berger. 2008. <span>“Global Alignment
of Multiple Protein Interaction Networks with Application to Functional
Orthology Detection.”</span> <em>Proceedings of the National Academy of
Sciences</em> 105 (35): 12763–68. <a href="https://doi.org/10.1073/pnas.0806627105" class="external-link">https://doi.org/10.1073/pnas.0806627105</a>.
</div>
<div id="ref-centering" class="csl-entry">
Sussman, Daniel L., Vince Lyzinski, Youngser Park, and Carey E. Priebe.
2018. <span>“<span class="nocase">Matched Filters for Noisy Induced
Subgraph Detection</span>.”</span> <em>arXiv e-Prints</em>, March,
arXiv:1803.02423. <a href="https://arxiv.org/abs/1803.02423" class="external-link">https://arxiv.org/abs/1803.02423</a>.
</div>
<div id="ref-Umeyama" class="csl-entry">
Umeyama, S. 1988. <span>“An Eigendecomposition Approach to Weighted
Graph Matching Problems.”</span> <em>IEEE Transactions on Pattern
Analysis and Machine Intelligence</em> 10 (5): 695–703. <a href="https://doi.org/10.1109/34.6778" class="external-link">https://doi.org/10.1109/34.6778</a>.
</div>
<div id="ref-Volgenant1996-o" class="csl-entry">
Volgenant, A. 1996. <span>“Linear and Semi-Assignment Problems: A Core
Oriented Approach.”</span> <em>Computer and Operations Research</em> 23:
917–32.
</div>
<div id="ref-Percolation" class="csl-entry">
Yartseva, Lyudmila, and Matthias Grossglauser. 2013. <span>“On the
Performance of Percolation Graph Matching,”</span> COSN ’13, 119–30. <a href="https://doi.org/10.1145/2512938.2512952" class="external-link">https://doi.org/10.1145/2512938.2512952</a>.
</div>
<div id="ref-rdpg" class="csl-entry">
Young, Stephen J., and Edward R. Scheinerman. 2007. <span>“Random Dot
Product Graph Models for Social Networks.”</span> In <em>Proceedings of
the 5th International Conference on Algorithms and Models for the
Web-Graph</em>, 138–49. WAW’07. Berlin, Heidelberg: Springer-Verlag. <a href="https://dl.acm.org/doi/10.5555/1777879.1777890" class="external-link">https://dl.acm.org/doi/10.5555/1777879.1777890</a>.
</div>
<div id="ref-PATH" class="csl-entry">
Zaslavskiy, M., F. Bach, and J. Vert. 2009. <span>“A Path Following
Algorithm for the Graph Matching Problem.”</span> <em>IEEE Transactions
on Pattern Analysis and Machine Intelligence</em> 31 (12): 2227–42. <a href="https://doi.org/10.1109/TPAMI.2008.245" class="external-link">https://doi.org/10.1109/TPAMI.2008.245</a>.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Daniel Sussman, Zihuan Qiao.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.9.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
